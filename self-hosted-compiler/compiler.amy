//
// ==================================================================================================
// STANDARD LIBRARY STUFFS
// ==================================================================================================
//

// Loops while a condition is true.
(defmacro
    while condy
        stat
    &key else
    (loop
        (cond
            (condy stat)
            (:else (break else)))))

// Performs a short circuiting logical and.
(defmacro
    and x y
    (cond
        (x y)
        (:else 0)))

// Performs a short circuiting logical or.
(defmacro
    or x y
    (cond
        (x 1)
        (:else y)))

// Performs a logical not
(defmacro
    not x
    (cond
        (x 0)
        (:else 1)))

// Prints out a string onto stdout.
(defun print (str (@ mut u8))
    (seqn
        (syscall 1 1 (cast str.ptr) str.len 0 0 0)))

// Helper function for printing out an integer
(defun print-int-helper (i u64) (printer (fn ((@ mut u8))))
    (cond
        ((== i 0) (printer "0"))
        (:else (seqn
            (let p = (alloca 20))
            (let start = 19)
            (while (!= i 0) (seqn
                (let c = (+ '0' (cast (% i 10))))
                (set start = (- start 1))
                (set (get p start) = c)
                (set i = (/ i 10))))
            (printer (subslice p start (- p.len 1)))))))

// Prints out a number onto stdout.
(defun print-int (i u64)
    (print-int-helper i print))

// Prints out a number onto stderr.
(defun eprint-int (i u64)
    (print-int-helper i eprint))

// Prints out a string onto stderr.
(defun eprint (str (@ mut u8))
    (seqn
        (syscall 1 2 (cast str.ptr) str.len 0 0 0)))

// Exits the program
(defun exit (code i32)
    (seqn
        (syscall 60 (cast code) 0 0 0 0 0)))

// Creates a subslice from a given slice and range.
(defun subslice (s (@ mut 'a)) (start u64) (end u64) : (@ mut 'a)
    (slice (- end start) (ptr-add s.ptr start)))

// Defines a file (wrapper around a file descriptor).
(defstruct File
    (descriptor i32))

(defun file-is-valid (file File) : u1
    (> file.descriptor 0))

(defmacro FILE_OPEN_FLAG_READ_ONLY   0)
(defmacro FILE_OPEN_FLAG_WRITE_ONLY  1)
(defmacro FILE_OPEN_FLAG_CREATE     64)
(defmacro FILE_OPEN_FLAG_TRUNCATE  512)

// Opens a file.
(defun file-open (path (@ mut u8)) (flags u64) : File
    (seq
        (let null-term = (alloca (+ path.len 1)))
        (let i = 0)
        (while (< i path.len)
            (seqn
                (set (get null-term i) = (get path i))
                (set i = (+ i 1))))
        (set (get null-term i) = '\0')
        (inst File
            (descriptor
                (cast (syscall 2 (cast null-term.ptr) flags 438 0 0 0))))))

// Reads a file into a vec of u8s.
(defun file-read-all (file File) (A (* mut Allocator)) : (Vec u8) (seq
    (let vec = (ref (new-vec A)))
    (let slice = (alloca 64))
    (while (let len = (syscall 0 (cast file.descriptor) (cast slice.ptr) slice.len 0 0 0)) (seqn
        (let i = 0)
        (while (< i len) (seqn
            (vec-push vec (get slice i))
            (set i = (+ i 1))))))
    (deref vec)))

(defun file-write (file File) (str (@ mut u8)) (seqn
    (syscall 1 (cast file.descriptor) (cast str.ptr) (cast str.len) 0 0 0)))

(defun file-write-int (file File) (i u64)
    (cond
        ((== i 0) (file-write file "0"))
        (:else (seqn
            (let p = (alloca 20))
            (let start = 19)
            (while (!= i 0) (seqn
                (let c = (+ '0' (cast (% i 10))))
                (set start = (- start 1))
                (set (get p start) = c)
                (set i = (/ i 10))))
            (file-write file (subslice p start (- p.len 1)))))))


// Closes a previously opened file.
(defun file-close (file File)
    (seqn
        (syscall 3 (cast file.descriptor) 0 0 0 0 0)))

// Maps memory for the program.
(defun mmap (len u64) : (* mut 'a)
    (cast (syscall 9 0 len 3 34 (- 0 1) 0)))

// Unmaps memory previously mapped by mmap.
(defun munmap (addr (* mut 'a)) (len u64)
    (seqn
        (syscall 11 (cast addr) len 0 0 0 0)))

// Creates a null constant.
(defun null : (* mut 'a)
    (cast (: u64 0)))

// Defines a free bucket linked list node for the memory allocator.
(defstruct FreeBucket
    (next (* mut FreeBucket)))

// Defines an allocator.
(defstruct Allocator
    (free16    (* mut FreeBucket))
    (free64    (* mut FreeBucket))
    (free256   (* mut FreeBucket))
    (free1024  (* mut FreeBucket))
    (free4096  (* mut FreeBucket))
    (free16384 (* mut FreeBucket))
    (free65536 (* mut FreeBucket)))

// Helper function for allocation to create size buckets.
(defun create-buckets (bucket-size u64) : (* mut FreeBucket)
    (seq
        (let p = (: (* mut u8) (mmap 65536)))
        (let i = (- bucket-size (sizeof FreeBucket)))
        (let q = (cast (ptr-add p i)))
        (while (< i 65536) (seqn
            (let q = (: (* mut FreeBucket) (cast (ptr-add p i))))
            (set i = (+ i bucket-size))
            (cond
                ((< i 65536) (seqn
                    (set (deref q).next = (cast (ptr-add p i)))))
                (:else (seqn
                    (set (deref q).next = (null)))))))
        q))

// Helper function for allocation.
(defun alloc-helper (A (* mut Allocator)) (size u64) : (* mut 'a)
    (cond
        ((== size 0) (null))
        ((<= size 8) (seq
            (cond
                ((== (deref A).free16 (null)) (seqn
                    (set (deref A).free16 = (create-buckets 16)))))
            (let ptr = (deref A).free16)
            (set (deref A).free16 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 8))))

        ((<= size 56) (seq
            (cond
                ((== (deref A).free64 (null)) (seqn
                    (set (deref A).free64 = (create-buckets 64)))))
            (let ptr = (deref A).free64)
            (set (deref A).free64 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 56))))

        ((<= size 248) (seq
            (cond
                ((== (deref A).free256 (null)) (seqn
                    (set (deref A).free256 = (create-buckets 256)))))
            (let ptr = (deref A).free256)
            (set (deref A).free256 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 248))))

        ((<= size 1016) (seq
            (cond
                ((== (deref A).free1024 (null)) (seqn
                    (set (deref A).free1024 = (create-buckets 1024)))))
            (let ptr = (deref A).free1024)
            (set (deref A).free1024 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 1016))))

        ((<= size 4088) (seq
            (cond
                ((== (deref A).free4096 (null)) (seqn
                    (set (deref A).free4096 = (create-buckets 4096)))))
            (let ptr = (deref A).free4096)
            (set (deref A).free4096 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 4088))))

        ((<= size 16376) (seq
            (cond
                ((== (deref A).free16384 (null)) (seqn
                    (set (deref A).free16384 = (create-buckets 16384)))))
            (let ptr = (deref A).free16384)
            (set (deref A).free16384 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 16376))))

        ((<= size 65528) (seq
            (cond
                ((== (deref A).free65536 (null)) (seqn
                    (set (deref A).free65536 = (create-buckets 65536)))))
            (let ptr = (deref A).free65536)
            (set (deref A).free65536 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 65528))))

        (:else
            (mmap size))))

// Helper function for deallocation.
(defun dealloc-helper (A (* mut Allocator)) (ptr (* mut 'a)) (size u64)
    (cond
        ((or (== size 0) (== ptr (null))) ())
        ((<= size 8) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 8))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16)
            (set (deref A).free16 = bucket)))

        ((<= size 56) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 56))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free64)
            (set (deref A).free64 = bucket)))

        ((<= size 248) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 248))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free256)
            (set (deref A).free256 = bucket)))

        ((<= size 1016) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 1016))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free1024)
            (set (deref A).free1024 = bucket)))

        ((<= size 4088) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 4088))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free4096)
            (set (deref A).free4096 = bucket)))

        ((<= size 16376) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 16376))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16384)
            (set (deref A).free16384 = bucket)))

        ((<= size 65528) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 65528))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free65536)
            (set (deref A).free65536 = bucket)))

        (:else
            (munmap ptr size))))

// Allocates a pointer to some data.
(defun alloc (A (* mut Allocator)) : (* mut 'a)
    (alloc-helper A (sizeof 'a)))

// Deallocates a pointer.
(defun dealloc (A (* mut Allocator)) (ptr (* mut 'a))
    (dealloc-helper A ptr (sizeof 'a)))

// Allocates an array of data.
(defun alloc-array (A (* mut Allocator)) (len u64) : (@ mut 'a)
    (slice len (alloc-helper A (* len (sizeof 'a)))))

// Deallocates an array of data.
(defun dealloc-array (A (* mut Allocator)) (s (@ mut 'a)) 
    (dealloc-helper A s.ptr (* s.len (sizeof 'a))))

// Creates a new empty allocator.
(defun new-alloc : Allocator
    (inst Allocator
        (free16    (null))
        (free64    (null))
        (free256   (null))
        (free1024  (null))
        (free4096  (null))
        (free16384 (null))
        (free65536 (null))))

// Defines a vector (ie a list).
(defstruct Vec
    (vals (@ mut 'a))
    (len u64)
    (A (* mut Allocator)))

// Creates a new empty vector.
(defun new-vec (A (* mut Allocator)) : (Vec 'a)
    (inst Vec
        (vals (slice 0 (null)))
        (len 0)
        (A A)))

// Gets the ith element of a vector.
(defun vec-get (v (* mut (Vec 'a))) (i u64) : (* mut 'a)
    (cond
        ((< i (deref v).len) (ptr-add (deref v).vals.ptr i))
        (:else (null))))

// Pushes a value onto a vector.
(defun vec-push (vec (* mut (Vec 'a))) (v 'a) (seqn
    (cond
        ((<= (deref vec).vals.cap (deref vec).len) (seqn
            (let new-cap = (cond
                ((== (deref vec).vals.cap 0) 8)
                (:else (* (deref vec).vals.cap 2))))
            (let new-vals = (alloc-array (deref vec).A new-cap))
            (let i = 0)
            (while (< i (deref vec).len) (seqn
                (set (get new-vals i) = (get (deref vec).vals i))
                (set i = (+ i 1))))
            (dealloc-array (deref vec).A (deref vec).vals)
            (set (deref vec).vals = new-vals))))
    (set (get (deref vec).vals (deref vec).len) = v)
    (set (deref vec).len = (+ (deref vec).len 1))))

// Pops a value from a vector
// TODO: this leaks memory
(defun vec-pop (vec (* mut (Vec 'a))) (seqn
    (cond
        ((> (deref vec).len 0) (seqn
            (set (deref vec).len = (- (deref vec).len 1)))))))

// Creates a slice from a vector.
(defun vec-slice (vec (* mut (Vec 'a))) : (@ mut 'a)
    (subslice (deref vec).vals 0 (deref vec).len))

(defun vec-find (vec (* mut (Vec 'a))) (pred (fn ((* mut 'a) 'b) : u1)) (data 'b) : (* mut 'a) (seq
    (let i = 0)
    (while (< i (deref vec).len) (seqn
        (let item = (vec-get vec i))
        (cond
            ((pred item data)
                (break item)))
        (set i = (+ i 1)))
    :else (null))))

// Empty deallocator
(defun empty-dealloc (v (* mut 'a)) ())

// Drops a vector
(defun vec-drop (vec (* mut (Vec 'a))) (callback (fn ((* mut 'a)))) (seqn
    (let i = 0)
    (while (< i (deref vec).len) (seqn
        (callback (ptr-add (deref vec).vals.ptr i))
        (set i = (+ i 1))))
    (dealloc-array (deref vec).A (deref vec).vals)))

// Checks if a string slice contains a character.
(defun str-contains (str (@ mut u8)) (c u8) : u1 (seq
    (let i = 0)
    (while (< i str.len) (seqn
        (cond
            ((== c (get str i))
                (break true)))
        (set i = (+ i 1)))
    :else false)))

(defun str-equals (a (@ mut u8)) (b (@ mut u8)) : u1
    (cond
        ((!= a.len b.len) false)
        (:else (seq
            (let i = 0)
            (while (< i a.len) (seqn
                (cond
                    ((!= (get a i) (get b i))
                        (break false)))
                (set i = (+ i 1)))
            :else true)))))

(defun get-argv (argv (* mut (* mut u8))) (i u64) : (@ mut u8) (seq
    (let j = 0)
    (while (<= j i) (seqn
        (cond
            ((== (deref (ptr-add argv j)) (null))
                (break (slice 0 (null)))))
        (set j = (+ j 1)))
    :else (seq
        (let p = (deref (ptr-add argv i)))
        (let len = 0)
        (while (deref (ptr-add p len)) (seqn
            (set len = (+ len 1))))
        (slice len p)))))

(defstruct Pair
    (a 'a)
    (b 'b))

(defun matches-key (pair (* mut (Pair (@ mut u8) 'a))) (str (@ mut u8)) : u1
    (str-equals (deref pair).a str))



//
// ==================================================================================================
// LEXING
// ==================================================================================================
//

// Defines a location in source code.
(defstruct Location
    (start u64)
    (end u64))

// Defines a token.
(defstruct Token
    (loc Location)
    (type u64)
    (value (@ mut u8)))

(defmacro TOKEN_TYPE_EOF     0)
(defmacro TOKEN_TYPE_INVALID 1)
(defmacro TOKEN_TYPE_LPAREN  2)
(defmacro TOKEN_TYPE_RPAREN  3)
(defmacro TOKEN_TYPE_INT     4)
(defmacro TOKEN_TYPE_SYMBOL  5)
(defmacro TOKEN_TYPE_KEY     6)
(defmacro TOKEN_TYPE_DOT     7)
(defmacro TOKEN_TYPE_QUOTE   8)
(defmacro TOKEN_TYPE_STRING  9)
(defmacro TOKEN_TYPE_CHAR   10)
(defmacro TOKEN_TYPE_BOOL   11)

// Defines a lexer.
(defstruct Lexer
    (str (@ mut u8))
    (pos u64)
    (tokens (Vec Token))
    (token-pos u64))

// Creates a new lexer.
(defun new-lexer (A (* mut Allocator)) (str (@ mut u8)) : Lexer
    (inst Lexer
        (str str)
        (pos 0)
        (tokens (new-vec A))
        (token-pos 0)))

// Lexes a string.
(defun lex-next (lexer (* mut Lexer)) : Token
    (cond
        ((< (deref lexer).token-pos (deref lexer).tokens.len) (seq
            (let v = (vec-get (ref (deref lexer).tokens) (deref lexer).token-pos))
            (set (deref lexer).token-pos = (+ (deref lexer).token-pos 1))
            (deref v)))
        (:else (seq
            (let i = (deref lexer).pos)
            (let state = 0)
            (let comment-mode = 0)
            (let type = (TOKEN_TYPE_INVALID))
            (while (< i (deref lexer).str.len) (seqn
                (let c = (get (deref lexer).str i))
                (set i = (+ i 1))
                (let next = (cond
                    ((< i (deref lexer).str.len) (get (deref lexer).str i))
                    (:else 0)))
                (cond
                    // Line comments
                    ((and (== comment-mode 1) (== c '\n')) (seqn
                        (set comment-mode = 0)
                        (set (deref lexer).pos = i)))
                    ((== comment-mode 1) ())

                    // Block comments
                    ((and (== comment-mode 2) (and (== c '*') (== next '/'))) (seqn
                        (set comment-mode = 0)
                        (set i = (+ i 1))
                        (set (deref lexer).pos = i)))
                    ((== comment-mode 2) ())

                    // Initial state
                    ((== state 0) (cond
                        // Line comments
                        ((and (== c '/') (== next '/')) (seqn
                            (set comment-mode = 1)))

                        // Block comments
                        ((and (== c '/') (== next '*')) (seqn
                            (set comment-mode = 2)))

                        // Whitespace
                        ((str-contains " \n\t\r" c) (seqn
                            (set (deref lexer).pos = i)))

                        // Left parenthesis
                        ((== c 40) (seqn
                            (set type = (TOKEN_TYPE_LPAREN))
                            (break)))

                        // Right parenthesis
                        ((== c 41) (seqn
                            (set type = (TOKEN_TYPE_RPAREN))
                            (break)))

                        // Dot
                        ((== c '.') (seqn
                            (set type = (TOKEN_TYPE_DOT))
                            (break)))

                        // Quote
                        ((== c '\'') (seqn
                            (set type = (TOKEN_TYPE_CHAR))
                            (set state = 1)))

                        // Integers
                        ((and (<= '0' c) (<= c '9')) (seqn
                            (set type = (TOKEN_TYPE_INT))
                            (set state = 1)))

                        // Colon symbol
                        ((and (== c ':') (not (str-contains "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" next))) (seqn
                            (set type = (TOKEN_TYPE_SYMBOL))
                            (break)))

                        // Symbols
                        ((str-contains "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c) (seqn
                            (set type = (TOKEN_TYPE_SYMBOL))
                            (set state = 1)))

                        // Keys
                        ((== c ':') (seqn
                            (set type = (TOKEN_TYPE_KEY))
                            (set state = 1)))

                        ((== c '"') (seqn
                            (set type = (TOKEN_TYPE_STRING))
                            (set state = 1)))

                        // Everything else is invalid
                        (:else (break))))

                    // Integers
                    ((== type (TOKEN_TYPE_INT))
                        (cond
                            ((or (> '0' c) (> c '9')) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // Symbols
                    ((== type (TOKEN_TYPE_SYMBOL))
                        (cond
                            ((or (not (str-contains "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c)) (and (== c '/') (== next '*'))) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // Keys
                    ((== type (TOKEN_TYPE_KEY))
                        (cond
                            ((or (not (str-contains "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c)) (and (== c '/') (== next '*'))) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // String unescaped character
                    ((and (== type (TOKEN_TYPE_STRING)) (== state 1))
                        (cond
                            ((== c '\\') (seqn
                                (set state = 2)))
                            ((== c '"')
                                (break))))

                    // String escaped character
                    ((and (== type (TOKEN_TYPE_STRING)) (== state 2)) (seqn
                        (set state = 1)))

                    // Beginning of a character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 1))
                        (cond
                            ((== c '\\') (seqn
                                (set state = 2)))
                            ((!= next '\'') (seqn
                                (set i = (- i 1))
                                (set type = (TOKEN_TYPE_QUOTE))
                                (break)))
                            (:else (seqn
                                (set state = 3)))))

                    // Escaped character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 2))
                        (cond
                            ((str-contains "nrt0\\'\"" c) (seqn
                                (set state = 3)))
                            (:else (seqn
                                (set type = (TOKEN_TYPE_INVALID))
                                (break)))))

                    // End of character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 3))
                        (cond
                            ((== c '\'')
                                (break))
                            (:else (seqn
                                (set type = (TOKEN_TYPE_INVALID))
                                (break))))))))

            (let start = (deref lexer).pos)
            (cond ((== start i) (seqn
                (set type = (TOKEN_TYPE_EOF)))))
            (set (deref lexer).pos = i)
            (let value = (subslice (deref lexer).str start i))
            (cond
                ((or (str-equals value "true") (str-equals value "false")) (seqn
                    (set type = (TOKEN_TYPE_BOOL)))))
            (let token = (inst Token
                (loc (inst Location
                    (start start)
                    (end i)))
                (type type)
                (value value)))
            (let token-vec = (ref (deref lexer).tokens))
            (vec-push token-vec token)
            (set (deref lexer).tokens = (deref token-vec))
            (set (deref lexer).token-pos = (+ (deref lexer).token-pos 1))
            token))))

// Peeks into the lexer and returns the next token without consuming it.
(defun lex-peek (lexer (* mut Lexer)) : Token (seq
    (let token = (lex-next lexer))
    (set (deref lexer).token-pos = (- (deref lexer).token-pos 1))
    token))

// Drops a lexer.
(defun lexer-drop (lexer (* mut Lexer))
    (vec-drop (ref (deref lexer).tokens) empty-dealloc))

// Prints out a token.
(defstruct LexerResult
    (token Token)
    (fail ParseFailure)
    (success u1))

// Expects a type of token and fails if the token is not next.
(defun lexer-expect (lexer (* mut Lexer)) (type u64) : LexerResult
    (cond
        ((== type (lex-peek lexer).type)
            (inst LexerResult
                (token (lex-next lexer))
                (fail (inst ParseFailure
                    (loc (inst Location
                        (start 0)
                        (end 0)))
                    (expected 0)
                    (received 0)))
                (success true)))
        (:else
            (inst LexerResult
                (token (inst Token
                    (loc (inst Location
                        (start 0)
                        (end 0)))
                    (type 0)
                    (value "")))
                (fail (inst ParseFailure
                    (loc (lex-peek lexer).loc)
                    (expected type)
                    (received (lex-peek lexer).type)))
                (success false)))))



//
// ==================================================================================================
// PARSER
// ==================================================================================================
//

(defmacro AST_NODE_TYPE_INVALID  0)
(defmacro AST_NODE_TYPE_ROOT     1)
(defmacro AST_NODE_TYPE_SEXPR    2)
(defmacro AST_NODE_TYPE_INT      3)
(defmacro AST_NODE_TYPE_SYMBOL   4)
(defmacro AST_NODE_TYPE_KEY      5)
(defmacro AST_NODE_TYPE_ATTR     6)
(defmacro AST_NODE_TYPE_QUOTE    7)
(defmacro AST_NODE_TYPE_STRING   8)
(defmacro AST_NODE_TYPE_CHAR     9)
(defmacro AST_NODE_TYPE_BOOL    10)

(defmacro ERROR_TYPE_VALUE (- 0 1))

(defstruct Ast
    (type u64)
    (loc Location)
    (typed Type)
    (value (@ mut u8))
    (children (Vec Ast)))

(defun ast-clone (ast Ast) : Ast
    (seq
        (let children = (ref (new-vec ast.children.A)))
        (let i = 0)
        (while (< i ast.children.len) (seqn
            (vec-push children (ast-clone (deref (vec-get (ref ast.children) i))))
            (set i = (+ i 1))))
        (inst Ast
            (type ast.type)
            (loc ast.loc)
            (typed (empty-type ast.children.A))
            (value ast.value)
            (children (deref children)))))

(defun ast-drop (ast (* mut Ast))
    // TODO: dropping types
    (vec-drop (ref (deref ast).children) ast-drop))

(defun print-ast-helper (ast (* mut Ast)) (level u64) (seqn
    (let i = 0)
    (while (< i level) (seqn
        (print "    ")
        (set i = (+ i 1))))
    (print-int (deref ast).loc.start)
    (print "..")
    (print-int (deref ast).loc.end)
    (print " ")
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_INVALID))
            (print "INVALID"))
        ((== (deref ast).type (AST_NODE_TYPE_ROOT))
            (print "ROOT"))
        ((== (deref ast).type (AST_NODE_TYPE_SEXPR))
            (print "SEXPR"))
        ((== (deref ast).type (AST_NODE_TYPE_INT))
            (print "INT"))
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL))
            (print "SYMBOL"))
        ((== (deref ast).type (AST_NODE_TYPE_KEY))
            (print "KEY"))
        ((== (deref ast).type (AST_NODE_TYPE_ATTR))
            (print "ATTRIBUTE"))
        ((== (deref ast).type (AST_NODE_TYPE_QUOTE))
            (print "QUOTE"))
        ((== (deref ast).type (AST_NODE_TYPE_STRING))
            (print "STRING"))
        ((== (deref ast).type (AST_NODE_TYPE_CHAR))
            (print "CHAR"))
        ((== (deref ast).type (AST_NODE_TYPE_BOOL))
            (print "BOOL"))
        (:else
            (print "UNKNOWN")))
    (print " ")
    (print (deref ast).value)
    (print " : ")
    (print-type (ref (deref ast).typed))
    (print "\n")
    (let i = 0)
    (while (!= (let child = (vec-get (ref (deref ast).children) i)) (null)) (seqn
        (print-ast-helper child (+ level 1))
        (set i = (+ i 1))))))

(defun print-ast (ast (* mut Ast))
    (print-ast-helper ast 0))

(defstruct LineColumn
    (line-start u64)
    (col-start u64)
    (line-end u64)
    (col-end u64))

(defun loc-to-line-col (contents (@ mut u8)) (loc Location) : LineColumn (seq
    (let i = 0)
    (let line-start = 1)
    (let col-start = 0)
    (while (< i loc.start) (seqn
        (cond
            ((== (get contents i) '\n') (seqn
                (set line-start = (+ line-start 1))
                (set col-start = 0)))
            (:else (seqn
                (set col-start = (+ col-start 1)))))
        (set i = (+ i 1))))
    (let line-end = line-start)
    (let col-end = col-start)
    (while (< i loc.end) (seqn
        (cond
            ((== (get contents i) '\n') (seqn
                (set line-end = (+ line-end 1))
                (set col-end = 0)))
            (:else (seqn
                (set col-end = (+ col-end 1)))))
        (set i = (+ i 1))))
    (inst LineColumn
        (line-start line-start)
        (col-start col-start)
        (line-end line-end)
        (col-end col-end))))

(defun print-parse-error-helper (type u64)
    (cond
        ((== type (ERROR_TYPE_VALUE))
            (eprint "VALUE"))
        ((== type (TOKEN_TYPE_EOF))
            (eprint "EOF"))
        ((== type (TOKEN_TYPE_INVALID))
            (eprint "INVALID"))
        ((== type (TOKEN_TYPE_LPAREN))
            (eprint "LPAREN"))
        ((== type (TOKEN_TYPE_RPAREN))
            (eprint "RPAREN"))
        ((== type (TOKEN_TYPE_INT))
            (eprint "INT"))
        ((== type (TOKEN_TYPE_SYMBOL))
            (eprint "SYMBOL"))
        ((== type (TOKEN_TYPE_KEY))
            (eprint "KEY"))
        ((== type (TOKEN_TYPE_DOT))
            (eprint "DOT"))
        ((== type (TOKEN_TYPE_QUOTE))
            (eprint "QUOTE"))
        ((== type (TOKEN_TYPE_STRING))
            (eprint "STRING"))
        ((== type (TOKEN_TYPE_CHAR))
            (eprint "CHAR"))
        ((== type (TOKEN_TYPE_BOOL))
            (eprint "BOOL"))
        (:else
            (eprint "UNKNOWN"))))

(defun print-parse-error (contents (@ mut u8)) (fail (* mut ParseFailure)) (seqn
    (eprint "error: expected ")
    (print-parse-error-helper (deref fail).expected)
    (eprint ", got ")
    (print-parse-error-helper (deref fail).received)
    (let line-col = (loc-to-line-col contents (deref fail).loc))
    (eprint " (")
    (eprint-int line-col.line-start)
    (eprint ":")
    (eprint-int line-col.col-start)
    (eprint "..")
    (eprint-int line-col.line-end)
    (eprint ":")
    (eprint-int line-col.col-end)
    (eprint ")\n")))

(defstruct ParseFailure
    (loc Location)
    (expected u64)
    (received u64))

(defstruct ParseResult
    (ast Ast)
    (fail ParseFailure)
    (success u1))

(defun parse-fail (fail ParseFailure) : ParseResult
    (inst ParseResult
        (ast (inst Ast
            (type 0)
            (loc (inst Location
                (start 0)
                (end 0)))
            (typed (empty-type (null)))
            (value (slice 0 (null)))
            (children (new-vec (null)))))
        (fail fail)
        (success false)))

(defun parse-success (ast Ast) : ParseResult
    (inst ParseResult
        (ast ast)
        (fail (inst ParseFailure
            (loc (inst Location
                (start 0)
                (end 0)))
            (expected 0)
            (received 0)))
        (success true)))

(defmacro
    pguard var = value
        stats
    &key else
    (seq
        (let var = value)
        (cond
            (var.success (seq
                (let var = var.ast)
                stats))
            (:else (seq
                else
                var)))))

(defmacro
    lguard var = value
        stats
    &key else
    (seq
        (let var = value)
        (cond
            (var.success (seq
                (let var = var.token)
                stats))
            (:else (seq
                else
                (parse-fail var.fail))))))

(defun parse-value (lexer (* mut Lexer)) : ParseResult
    (seq
        (let token = (lex-peek lexer))
        (cond
            ((== token.type (TOKEN_TYPE_LPAREN))
                (parse-sexpr lexer))

            ((== token.type (TOKEN_TYPE_SYMBOL)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_SYMBOL))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_INT)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_INT))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_KEY)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_KEY))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_QUOTE)) (seq
                (lex-next lexer)
                (pguard quoted = (parse-value lexer) (seq
                    (let children = (ref (new-vec (deref lexer).tokens.A)))
                    (vec-push children quoted)
                    (parse-success (inst Ast
                        (type (AST_NODE_TYPE_QUOTE))
                        (loc token.loc)
                        (typed (empty-type (deref lexer).tokens.A))
                        (value "")
                        (children (deref children))))))))

            ((== token.type (TOKEN_TYPE_STRING)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_STRING))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_CHAR)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_CHAR))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_BOOL)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_BOOL))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            (:else (parse-fail (inst ParseFailure
                (loc token.loc)
                (expected (ERROR_TYPE_VALUE))
                (received token.type)))))))

(defun parse-attr-item (lexer (* mut Lexer)) : ParseResult (seq
    (let token = (lex-peek lexer))
    (cond
        ((== token.type (TOKEN_TYPE_SYMBOL)) (seq
            (lex-next lexer)
            (parse-success (inst Ast
                (type (AST_NODE_TYPE_SYMBOL))
                (loc token.loc)
                (typed (empty-type (deref lexer).tokens.A))
                (value token.value)
                (children (new-vec (deref lexer).tokens.A))))))

        (:else (parse-fail (inst ParseFailure
                (loc token.loc)
                (expected (ERROR_TYPE_VALUE))
                (received token.type)))))))

(defun parse-attribute (lexer (* mut Lexer)) : ParseResult
    (pguard top = (parse-value lexer)
        (seq
            (let attrs = (ref (new-vec (deref lexer).tokens.A)))
            (vec-push attrs top)
            (while (== (lex-peek lexer).type (TOKEN_TYPE_DOT))
                (seqn
                    (lex-next lexer)
                    (let attr = (parse-attr-item lexer))
                    (cond
                        (attr.success
                            (vec-push attrs attr.ast))
                        (:else (seqn
                            (vec-drop attrs ast-drop)
                            (break attr)))))
            :else (cond
                ((> (deref attrs).len 1)
                    (parse-success (inst Ast
                        (type (AST_NODE_TYPE_ATTR))
                        (loc (inst Location
                            (start top.loc.start)
                            (end (deref (vec-get attrs (- (deref attrs).len 1))).loc.end)))
                        (typed (empty-type (deref lexer).tokens.A))
                        (value "")
                        (children (deref attrs)))))
                (:else (seq
                    (vec-drop attrs empty-dealloc)
                    (parse-success top))))))))

(defun parse-sexpr (lexer (* mut Lexer)) : ParseResult
    (lguard left = (lexer-expect lexer (TOKEN_TYPE_LPAREN)) (seq
        (let v = (ref (new-vec (deref lexer).tokens.A)))
        (while (let var = (parse-attribute lexer)).success (seqn
            (vec-push v var.ast)))
        (lguard right = (lexer-expect lexer (TOKEN_TYPE_RPAREN))
            (parse-success (inst Ast
                (type (AST_NODE_TYPE_SEXPR))
                (loc (inst Location
                    (start left.loc.start)
                    (end right.loc.end)))
                (typed (empty-type (deref lexer).tokens.A))
                (value "")
                (children (deref v))))
        :else (vec-drop v ast-drop)))))

(defun parse (lexer (* mut Lexer)) : ParseResult (seq
    (let asts = (ref (new-vec (deref lexer).tokens.A)))
    (let end = 0)
    (while (!= (lex-peek lexer).type (TOKEN_TYPE_EOF)) (seqn
        (let sexpr = (parse-sexpr lexer))
        (cond
            ((not sexpr.success) (seqn
                (vec-drop asts ast-drop)
                (break sexpr))))
        (set end = sexpr.ast.loc.end)
        (vec-push asts sexpr.ast))
    :else (parse-success
        (inst Ast
            (type (AST_NODE_TYPE_ROOT))
            (loc (inst Location
                (start 0)
                (end end)))
            (typed (empty-type (deref lexer).tokens.A))
            (value (slice 0 (null)))
            (children (deref asts)))))))



//
// ==================================================================================================
// MACROS
// ==================================================================================================
//

(defmacro MACRO_ARG_TYPE_ORDERED  0)
(defmacro MACRO_ARG_TYPE_ATOM     1)
(defmacro MACRO_ARG_TYPE_KEY      2)
(defmacro MACRO_ARG_TYPE_REST     3)

(defstruct MacroArg
    (name (@ mut u8))
    (type u64)
    (value Ast))

(defstruct Macro
    (args (Vec MacroArg))
    (body Ast))

(defun extract-macros (map (* mut (Vec (Pair (@ mut u8) Macro)))) (root (* mut Ast)) (seqn
    (let i = 0)
    (while (< i (deref root).children.len) (seqn
        (let ast = (vec-get (ref (deref root).children) i))
        (let contents = (ref (deref ast).children))
        (cond
            ((and (>= (deref contents).len 2) (== (deref ast).type (AST_NODE_TYPE_SEXPR))) (seqn
                (let name = (vec-get contents 0))
                (cond
                    ((and (== (deref name).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref name).value "defmacro"))
                        (seqn
                            (let name = (vec-get contents 1))
                            (cond
                                ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                    (let name = (deref name).value)
                                    (let args = (ref (new-vec (deref contents).A)))
                                    (let type = (MACRO_ARG_TYPE_ORDERED))
                                    (let i = 2)
                                    (while (< i (- (deref contents).len 1)) (seqn
                                        (let arg = (vec-get contents i))
                                        (cond
                                            ((and (== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref arg).value "&key")) (seqn
                                                (set type = (MACRO_ARG_TYPE_KEY))))
                                            ((and (== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref arg).value "&rest")) (seqn
                                                (set type = (MACRO_ARG_TYPE_REST))))

                                            ((== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                                (vec-push args (inst MacroArg
                                                    (name (deref arg).value)
                                                    (type type)
                                                    (value (inst Ast
                                                        (type 0)
                                                        (loc (inst Location
                                                            (start 0)
                                                            (end 0)))
                                                        (typed (empty-type (deref args).A))
                                                        (value "")
                                                        (children (new-vec (deref args).A))))))))

                                            ((and (== (deref arg).type (AST_NODE_TYPE_SEXPR)) (== (deref arg).children.len 2)) (seqn
                                                (let ast = (deref (vec-get (ref (deref arg).children) 1)))
                                                (let name = (deref (vec-get (ref (deref arg).children) 0)))
                                                (cond
                                                    ((== name.type (AST_NODE_TYPE_SYMBOL))
                                                        (vec-push args (inst MacroArg
                                                            (name name.value)
                                                            (type type)
                                                            (value ast)))))))

                                            ((and (== (deref arg).type (AST_NODE_TYPE_QUOTE)) (== (deref (vec-get (ref (deref arg).children) 0)).type (AST_NODE_TYPE_SYMBOL)))
                                                (vec-push args (inst MacroArg
                                                    (name (deref (vec-get (ref (deref arg).children) 0)).value)
                                                    (type (MACRO_ARG_TYPE_ATOM))
                                                    (value (inst Ast
                                                        (type 0)
                                                        (loc (inst Location
                                                            (start 0)
                                                            (end 0)))
                                                        (typed (empty-type (deref args).A))
                                                        (value "")
                                                        (children (new-vec (deref args).A))))))))

                                        (set i = (+ i 1))))

                                    (let ast = (cond
                                        ((> (deref contents).len 2)
                                            (deref (vec-get contents (- (deref contents).len 1))))
                                        (:else (inst Ast
                                            (type 0)
                                            (loc (inst Location
                                                (start 0)
                                                (end 0)))
                                            (typed (empty-type (deref args).A))
                                            (value "")
                                            (children (new-vec (deref args).A))))))
                                    (vec-push map (inst Pair
                                        (a name)
                                        (b (inst Macro
                                            (args (deref args))
                                            (body ast))))))))))))))
        (set i = (+ i 1))))))

(defun print-macros (map (* mut (Vec (Pair (@ mut u8) Macro)))) (seqn
    (let i = 0)
    (while (< i (deref map).len) (seqn
        (let macro = (deref (vec-get map i)))
        (print "Macro ")
        (print macro.a)
        (let macro = macro.b)
        (print ":\n    Args:\n")
        (let j = 0)
        (while (< j macro.args.len) (seqn
            (print "        ")
            (let arg = (deref (vec-get (ref macro.args) j)))
            (print arg.name)
            (print " ")
            (cond
                ((== arg.type (MACRO_ARG_TYPE_ORDERED))
                    (print "ORDERED"))
                ((== arg.type (MACRO_ARG_TYPE_ATOM))
                    (print "ATOM"))
                ((== arg.type (MACRO_ARG_TYPE_KEY))
                    (print "KEY"))
                ((== arg.type (MACRO_ARG_TYPE_REST))
                    (print "REST"))
                (:else
                    (print "UNKNOWN")))
            (print "\n")
            (print-ast-helper (ref arg.value) 3)
            (set j = (+ j 1))))
        (print "    Body:\n")
        (print-ast-helper (ref macro.body) 2)
        (set i = (+ i 1))))))

(defmacro CAPTURED_MACRO_ARG_NONE   0)
(defmacro CAPTURED_MACRO_ARG_SINGLE 1)
(defmacro CAPTURED_MACRO_ARG_REST   2)

(defstruct CapturedMacroArg
    (type u64)
    (start u64))

(defun macro-bind (args (@ mut Ast)) (macro (* mut Macro)) (arg-bindings (* mut (Vec (Pair (@ mut u8) CapturedMacroArg)))) : u1 (seq
    (let i = 0)
    (while (< i (deref macro).args.len) (seqn
        (let arg = (deref (vec-get (ref (deref macro).args) i)))
        (cond
            ((!= arg.type (MACRO_ARG_TYPE_ATOM))
                (vec-push arg-bindings (inst Pair
                    (a arg.name)
                    (b (inst CapturedMacroArg
                        (type (CAPTURED_MACRO_ARG_NONE))
                        (start 0)))))))
        (set i = (+ i 1))))

    (let ordered-arg = 0)
    (let last-key = "")
    (let i = 0)
    (while (< i args.len) (seqn
        (let arg = (get args i))
        (cond
            ((== arg.type (AST_NODE_TYPE_KEY))
                (cond
                    (last-key.len
                        (break false))
                    ((: u64 (cast (vec-find arg-bindings matches-key (let key = (subslice arg.value 1 arg.value.len))))) (seqn
                        (set last-key = key)))
                    (:else
                        (break false))))
            ((> last-key.len 0) (seqn
                (let arg = (get args (- i 1)))
                (let binding = (vec-find arg-bindings matches-key (let key = (subslice arg.value 1 arg.value.len))))
                (set (deref binding).b = (inst CapturedMacroArg
                    (type (CAPTURED_MACRO_ARG_SINGLE))
                    (start i)))
                (set last-key = "")))
            ((: u64 (cast (let arg = (vec-get (ref (deref macro).args) ordered-arg)))) (seqn
                (let arg = (deref arg))
                (cond
                    ((== arg.type (MACRO_ARG_TYPE_ORDERED)) (seqn
                        (let binding = (vec-find arg-bindings matches-key arg.name))
                        (set (deref binding).b = (inst CapturedMacroArg
                            (type (CAPTURED_MACRO_ARG_SINGLE))
                            (start i)))))
                    ((== arg.type (MACRO_ARG_TYPE_ATOM)) (seqn
                        (let arg-actual = (get args i))
                        (cond
                            ((or (!= arg-actual.type (AST_NODE_TYPE_SYMBOL)) (not (str-equals arg-actual.value arg.name)))
                                (break false)))))
                    ((== arg.type (MACRO_ARG_TYPE_REST)) (seqn
                        (let j = (+ i 1))
                        (cond
                            ((while (< j args.len) (seqn
                                (let arg = (get args j))
                                (cond
                                    ((== arg.type (MACRO_ARG_TYPE_KEY))
                                        (break true)))
                                (set j = (+ j 1)))
                            :else false)
                                (break false)))
                        (let binding = (vec-find arg-bindings matches-key arg.name))
                        (set (deref binding).b = (inst CapturedMacroArg
                            (type (CAPTURED_MACRO_ARG_REST))
                            (start i))))))

                (set ordered-arg = (+ ordered-arg 1))
                (while (and (: u64 (cast (let v = (vec-get (ref (deref macro).args) ordered-arg)))) (== (deref v).type (MACRO_ARG_TYPE_KEY))) (seqn
                    (set ordered-arg = (+ ordered-arg 1))))))

            (:else
                (break false)))
        (set i = (+ i 1)))
    :else (not (and (: u64 (cast (let arg = (vec-get (ref (deref macro).args) ordered-arg)))) (== (deref arg).type (MACRO_ARG_TYPE_ORDERED)))))))

(defun bind-macro-args (ast (* mut Ast)) (arg-bindings (* mut (Vec (Pair (@ mut u8) CapturedMacroArg)))) (old (* mut Ast))
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seqn
            (let bound = (vec-find arg-bindings matches-key (deref ast).value))
            (cond
                ((: u64 (cast bound)) (seqn
                    (let bound = (deref bound).b)
                    (cond
                        ((== bound.type (CAPTURED_MACRO_ARG_NONE)) (seqn
                            (set (deref ast) = (inst Ast
                                (type (AST_NODE_TYPE_SEXPR))
                                (loc (inst Location
                                    (start 0)
                                    (end 0)))
                                (typed (empty-type (deref arg-bindings).A))
                                (value "")
                                (children (new-vec (deref arg-bindings).A))))))
                        ((== bound.type (CAPTURED_MACRO_ARG_SINGLE)) (seqn
                            (set (deref ast) = (ast-clone (deref (vec-get (ref (deref old).children) (+ bound.start 1)))))))

                        ((== bound.type (CAPTURED_MACRO_ARG_REST)) (seqn
                            (eprint "&rest for macros is not implemented yet\n")
                            (exit 1)))))))))
        (:else (seqn
            (let i = 0)
            (while (< i (deref ast).children.len) (seqn
                (bind-macro-args (vec-get (ref (deref ast).children) i) arg-bindings old)
                (set i = (+ i 1))))))))

(defun replace-macros (map (* mut (Vec (Pair (@ mut u8) Macro)))) (ast (* mut Ast)) (seqn
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seqn
            (let sym = (vec-get (ref (deref ast).children) 0))
            (cond
                ((and (: u64 (cast sym)) (== (deref sym).type (AST_NODE_TYPE_SYMBOL)))
                    (cond
                        ((: u64 (cast (let macro = (vec-find map matches-key (deref sym).value)))) (seqn
                            (let macro = (ref (deref macro).b))
                            (let arg-bindings = (ref (new-vec (deref map).A)))

                            (cond
                                ((macro-bind (subslice (vec-slice (ref (deref ast).children)) 1 (deref ast).children.len) macro arg-bindings) (seqn
                                    (let old = (deref ast))
                                    (set (deref ast) = (ast-clone (deref macro).body))
                                    (bind-macro-args ast arg-bindings (ref old))
                                    (ast-drop (ref old)))))))))))))

    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let child = (vec-get (ref (deref ast).children) i))
        (replace-macros map child)
        (set i = (+ i 1))))))



//
// ==================================================================================================
// TYPE CHECKING
// ==================================================================================================
//

(defmacro TYPE_TYPE_UNKNOWN        0)
(defmacro TYPE_TYPE_INT            1)
(defmacro TYPE_TYPE_F32            2)
(defmacro TYPE_TYPE_F64            3)
(defmacro TYPE_TYPE_TUPLE          4)
(defmacro TYPE_TYPE_POINTER        5)
(defmacro TYPE_TYPE_SLICE          6)
(defmacro TYPE_TYPE_STRUCT         7)
(defmacro TYPE_TYPE_GENERIC        8)
(defmacro TYPE_TYPE_FUNCTION       9)
(defmacro TYPE_TYPE_TYPE_VARIABLE 10)

// Defines a type
(defstruct Type
    (type u64)
    (signed-mutable u1)
    (subtypes (Vec Type))
    (boxed (* mut Type))
    (name (@ mut u8))
    (type-var-width u64))

(defun empty-type (A (* mut Allocator)) : Type
    (inst Type
        (type (TYPE_TYPE_UNKNOWN))
        (signed-mutable false)
        (subtypes (new-vec A))
        (boxed (null))
        (name "")
        (type-var-width 0)))

(defstruct Signature
    (arg-types (Vec Type))
    (ret-type Type)
    (index u64))

(defstruct Struct
    (generics (Vec (@ mut u8)))
    (fields (Vec (Pair (@ mut u8) Type))))

(defstruct TypeError
    (loc Location)
    (message (@ mut u8)))

(defun type-error (loc Location) (message (@ mut u8)) : TypeError
    (inst TypeError
        (loc loc)
        (message message)))

(defun parse-type-int (loc Location) (str (@ mut u8)) (errors (* mut (Vec TypeError))) : u64 (seq
    (let i = 0)
    (let n = 0)
    (while (< i str.len) (seqn
        (let c = (get str i))
        (cond
            ((and (<= '0' c) (<= c '9')) (seqn
                (set n = (+ (* n 10) (cast (- c '0'))))))
            (:else (seqn
                (vec-push errors (type-error loc "could not parse int type"))
                (break 0))))
        (set i = (+ i 1)))
    :else n)))

(defun parse-type (ast (* mut Ast)) (errors (* mut (Vec TypeError))) : Type (seq
    (let type = (ref (empty-type (deref errors).A)))
    (cond
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref ast).value "f32")) (seq
            (set (deref type).type = (TYPE_TYPE_F32))
            (deref type)))
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref ast).value "f64")) (seq
            (set (deref type).type = (TYPE_TYPE_F64))
            (deref type)))
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (or (== (get (deref ast).value 0) 'i') (== (get (deref ast).value 0) 'u'))) (seq
            (set (deref type).type = (TYPE_TYPE_INT))
            (set (deref type).type-var-width = (parse-type-int (deref ast).loc (subslice (deref ast).value 1 (deref ast).value.len) errors))
            (set (deref type).signed-mutable = (== (get (deref ast).value 0) 'i'))
            (deref type)))
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seq
            (set (deref type).type = (TYPE_TYPE_STRUCT))
            (set (deref type).name = (deref ast).value)
            (deref type)))
        ((== (deref ast).type (AST_NODE_TYPE_QUOTE)) (seq
            (let child = (vec-get (ref (deref ast).children) 0))
            (cond
                ((== (deref child).type (AST_NODE_TYPE_SYMBOL)) (seqn
                    (set (deref type).type = (TYPE_TYPE_GENERIC))
                    (set (deref type).name = (deref child).value)))
                ((== (deref child).type (AST_NODE_TYPE_SEXPR)) (seqn
                    (set (deref type).type = (TYPE_TYPE_TUPLE))
                    (let i = 0)
                    (let v = (ref (deref type).subtypes))
                    (while (< i (deref child).children.len) (seqn
                        (vec-push v (parse-type (vec-get (ref (deref child).children) i) errors))
                        (set i = (+ i 1))))
                    (set (deref type).subtypes = (deref v))))
                (:else
                    (vec-push errors (type-error (deref child).loc "could not parse quoted type"))))
            (deref type)))

        ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (== (deref ast).children.len 0)) (seq
            (set (deref type).type = (TYPE_TYPE_TUPLE))
            (deref type)))

        ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seq
            (let first = (vec-get (ref (deref ast).children) 0))
            (cond
                ((== (deref first).type (AST_NODE_TYPE_SYMBOL))
                    (cond
                        ((str-equals (deref first).value "*")
                            (cond
                                ((and (== (deref ast).children.len 3) (and (== (let v = (deref (vec-get (ref (deref ast).children) 1))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "mut"))) (seqn
                                    (set (deref type).type = (TYPE_TYPE_POINTER))
                                    (set (deref type).signed-mutable = true)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                ((== (deref ast).children.len 2) (seqn
                                    (set (deref type).type = (TYPE_TYPE_POINTER))
                                    (set (deref type).signed-mutable = false)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse pointer type")))))

                        ((str-equals (deref first).value "@")
                            (cond
                                ((and (== (deref ast).children.len 3) (and (== (let v = (deref (vec-get (ref (deref ast).children) 1))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "mut"))) (seqn
                                    (set (deref type).type = (TYPE_TYPE_SLICE))
                                    (set (deref type).signed-mutable = true)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                ((== (deref ast).children.len 2) (seqn
                                    (set (deref type).type = (TYPE_TYPE_SLICE))
                                    (set (deref type).signed-mutable = false)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse slice type")))))

                        ((str-equals (deref first).value "fn")
                            (cond
                                ((>= (deref ast).children.len 2) (seqn
                                    (let arg-types = (ref (new-vec (deref ast).children.A)))
                                    (let args = (vec-get (ref (deref ast).children) 1))
                                    (cond
                                        ((== (deref args).type (AST_NODE_TYPE_SEXPR)) (seqn
                                            (let i = 0)
                                            (while (< i (deref args).children.len) (seqn
                                                (vec-push arg-types (parse-type (vec-get (ref (deref args).children) i) errors))
                                                (set i = (+ i 1))))))
                                        (:else
                                            (vec-push errors (type-error (deref ast).loc "could not parse function arg types"))))

                                    (let ret-type = (ref (empty-type (deref args).children.A)))
                                    (cond
                                        ((and (== (deref ast).children.len 4) (and (== (deref (let v = (vec-get (ref (deref ast).children) 2))).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref v).value ":"))) (seqn
                                            (set (deref ret-type) = (parse-type (vec-get (ref (deref ast).children) 3) errors))))
                                        ((== (deref ast).children.len 2) (seqn
                                            (set (deref ret-type).type = (TYPE_TYPE_TUPLE))))
                                        (:else
                                            (vec-push errors (type-error (deref ast).loc "could not parse function return type"))))
                                    (set (deref type).type = (TYPE_TYPE_FUNCTION))
                                    (set (deref type).subtypes = (deref arg-types))
                                    (set (deref type).boxed = (alloc (deref args).children.A))
                                    (set (deref (deref type).boxed) = (deref ret-type))))
                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse function type")))))

                        (:else (seqn
                            (set (deref type).type = (TYPE_TYPE_STRUCT))
                            (set (deref type).name = (deref first).value)
                            (let i = 1)
                            (let subtypes-ref = (ref (deref type).subtypes))
                            (while (< i (deref ast).children.len) (seqn
                                (vec-push subtypes-ref (parse-type (vec-get (ref (deref ast).children) i) errors))
                                (set i = (+ i 1))))
                            (set (deref type).subtypes = (deref subtypes-ref))))))

                (:else
                    (vec-push errors (type-error (deref ast).loc "could not parse parenthesised type type"))))
            (deref type)))

        (:else (seq
            (vec-push errors (type-error (deref ast).loc "could not parse type"))
            (deref type))))))

(defun extract-structs (ast (* mut Ast)) (result (* mut (Vec (Pair (@ mut u8) Struct)))) (errors (* mut (Vec TypeError))) (seqn
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (cond
            ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (>= (deref ast).children.len 2)) (seqn
                (let defstruct = (vec-get (ref (deref ast).children) 0))
                (cond
                    ((and (== (deref defstruct).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref defstruct).value "defstruct")) (seqn
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                (let name = (deref name).value)
                                (let generics = (ref (new-vec (deref ast).children.A)))
                                (let fields = (ref (new-vec (deref ast).children.A)))
                                (let i = 2)
                                (while (< i (deref ast).children.len) (seqn
                                    (let field = (vec-get (ref (deref ast).children) i))
                                    (cond
                                        ((and (== (deref field).type (AST_NODE_TYPE_SEXPR)) (== (deref field).children.len 2)) (seqn
                                            (let name = (vec-get (ref (deref field).children) 0))
                                            (let type = (vec-get (ref (deref field).children) 1))
                                            (let type = (parse-type type errors))
                                            (cond
                                                ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                                    (vec-push fields (inst Pair
                                                        (a (deref name).value)
                                                        (b type)))
                                                    (find-generics (ref type) generics))))))
                                        (:else
                                            (vec-push errors (type-error (deref field).loc "invalid struct field"))))
                                    (set i = (+ i 1))))
                                (cond
                                    ((: u64 (cast (vec-find result matches-key name)))
                                        (vec-push errors (type-error (deref ast).loc "structure defined twice")))
                                    (:else
                                        (vec-push result (inst Pair
                                            (a name)
                                            (b (inst Struct
                                                (generics (deref generics))
                                                (fields (deref fields)))))))))))))))))
        (set i = (+ i 1))))))

(defun print-structs (struct-map (* mut (Vec (Pair (@ mut u8) Struct)))) (seqn
    (let i = 0)
    (while (< i (deref struct-map).len) (seqn
        (let struct = (vec-get struct-map i))
        (print (deref struct).a)
        (let j = 0)
        (while (< j (deref struct).b.generics.len) (seqn
            (print " '")
            (print (deref (vec-get (ref (deref struct).b.generics) j)))
            (set j = (+ j 1))))
        (print ":\n")
        (let j = 0)
        (while (< j (deref struct).b.fields.len) (seqn
            (let field = (vec-get (ref (deref struct).b.fields) j))
            (print "    ")
            (print (deref field).a)
            (print ": ")
            (print-type (ref (deref field).b))
            (print "\n")
            (set j = (+ j 1))))
        (set i = (+ i 1))))))

(defun extract-functions
    (ast (* mut Ast))
    (result (* mut (Vec (Pair (@ mut u8) Signature))))
    (errors (* mut (Vec TypeError)))
(seqn
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (cond
            ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (>= (deref ast).children.len 3)) (seqn
                (let defun = (vec-get (ref (deref ast).children) 0))
                (cond
                    ((and (== (deref defun).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref defun).value "defun")) (seqn
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                (let name = (deref name).value)
                                (let colon? = (vec-get (ref (deref ast).children) (- (deref ast).children.len 3)))
                                (let has-ret-type = (and (== (deref colon?).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref colon?).value ":")))

                                (let ret-type = (cond
                                    (has-ret-type (seq
                                        (let type-ast = (vec-get (ref (deref ast).children) (- (deref ast).children.len 2)))
                                        (parse-type type-ast errors)))
                                    (:else (seq
                                        (let type = (ref (empty-type (deref ast).children.A)))
                                        (set (deref type).type = (TYPE_TYPE_TUPLE))
                                        (deref type)))))

                                (let j = 2)
                                (let args = (ref (new-vec (deref ast).children.A)))
                                (let last = (- (deref ast).children.len (cond
                                    (has-ret-type 3)
                                    (:else 1))))
                                (while (< j last) (seqn
                                    (let child = (vec-get (ref (deref ast).children) j))
                                    (cond
                                        ((and (== (deref child).type (AST_NODE_TYPE_SEXPR)) (== (deref child).children.len 2)) (seqn
                                            (let arg = (vec-get (ref (deref child).children) 0))
                                            (cond
                                                ((!= (deref arg).type (AST_NODE_TYPE_SYMBOL))
                                                    (vec-push errors (type-error (deref arg).loc "invalid function argument"))))
                                            (let type = (vec-get (ref (deref child).children) 1))
                                            (vec-push args (parse-type type errors))))
                                        (:else
                                            (vec-push errors (type-error (deref child).loc "invalid function argument"))))
                                    (set j = (+ j 1))))
                                (let func-type = (ref (empty-type (deref errors).A)))
                                (set (deref func-type).type = (TYPE_TYPE_FUNCTION))
                                (set (deref func-type).subtypes = (deref args))
                                (set (deref func-type).boxed = (alloc (deref errors).A))
                                (set (deref (deref func-type).boxed) = ret-type)
                                (set (deref ast).typed = (deref func-type))
                                (cond
                                    ((: u64 (cast (vec-find result matches-key name)))
                                        (vec-push errors (type-error (deref ast).loc "function defined twice")))
                                    (:else
                                        (vec-push result (inst Pair
                                            (a name)
                                            (b (inst Signature
                                                (arg-types (deref args))
                                                (ret-type ret-type)
                                                (index i))))))))))))))))
        (set i = (+ i 1))))))

(defun has-generic (type (* mut Type)) : u1
    (cond
        ((== (deref type).type (TYPE_TYPE_GENERIC))
            true)
        (:else
            (or (and (: u64 (cast (deref type).boxed)) (has-generic (deref type).boxed)) (seq
                (let i = 0)
                (while (< i (deref type).subtypes.len) (seqn
                    (cond
                        ((has-generic (vec-get (ref (deref type).subtypes) i))
                            (break true)))
                    (set i = (+ i 1)))
                :else false))))))

(defun contains-generic (name (* mut (@ mut u8))) (generic (@ mut u8)) : u1
    (str-equals (deref name) generic))

(defun find-generics (type (* mut Type)) (generics (* mut (Vec (@ mut u8))))
    (cond
        ((== (deref type).type (TYPE_TYPE_GENERIC))
            (cond
                ((not (: u64 (cast (vec-find generics contains-generic (deref type).name))))
                    (vec-push generics (deref type).name))))
        (:else (seqn
            (cond
                ((: u64 (cast (deref type).boxed))
                    (find-generics (deref type).boxed generics)))
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (find-generics (vec-get (ref (deref type).subtypes) i) generics)
                (set i = (+ i 1))))))))

(defun replace-generics (type (* mut Type)) (generics (* mut (Vec (Pair (@ mut u8) Type)))) (substitutions (* mut (Vec (Pair Type u64))))
    (cond
        ((== (deref type).type (TYPE_TYPE_GENERIC)) (seqn
            (let new = (vec-find generics matches-key (deref type).name))
            (cond
                ((: u64 (cast new)) (seqn
                    (set (deref type) = (type-clone (ref (deref new).b)))))
                (:else (seqn
                    (let new = (ref (empty-type (deref generics).A)))
                    (set (deref new).type = (TYPE_TYPE_TYPE_VARIABLE))
                    (set (deref new).type-var-width = (deref substitutions).len)
                    (vec-push substitutions (inst Pair
                        (a (deref new))
                        (b (COERCION_TYPE_NONE))))
                    (vec-push generics (inst Pair
                        (a (deref type).name)
                        (b (deref new))))
                    (set (deref type) = (deref new)))))))
        (:else (seqn
            (cond
                ((: u64 (cast (deref type).boxed))
                    (replace-generics (deref type).boxed generics substitutions)))
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (replace-generics (vec-get (ref (deref type).subtypes) i) generics substitutions)
                (set i = (+ i 1))))))))

(defun print-type (type (* mut Type))
    (cond
        ((== (deref type).type (TYPE_TYPE_UNKNOWN))
            (print "<unknown>"))
        ((== (deref type).type (TYPE_TYPE_INT)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "i"))
                (:else
                    (print "u")))
            (print-int (deref type).type-var-width)))
        ((== (deref type).type (TYPE_TYPE_F32))
            (print "f32"))
        ((== (deref type).type (TYPE_TYPE_F64))
            (print "f64"))
        ((== (deref type).type (TYPE_TYPE_TUPLE)) (seqn
            (print "'(")
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (cond
                    ((!= i 0)
                        (print " ")))
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_POINTER)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "(*mut "))
                (:else
                    (print "(* ")))
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_SLICE)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "(@mut "))
                (:else
                    (print "(@ ")))
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_STRUCT)) (seqn
            (cond
                ((deref type).subtypes.len
                    (print "(")))
            (print (deref type).name)
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (print " ")
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (cond
                ((deref type).subtypes.len
                    (print ")")))))
        ((== (deref type).type (TYPE_TYPE_GENERIC)) (seqn
            (print "'")
            (print (deref type).name)))
        ((== (deref type).type (TYPE_TYPE_FUNCTION)) (seqn
            (print "(fn (")
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (cond
                    ((!= i 0)
                        (print " ")))
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (print ") : ")
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (print "$")
            (print-int (deref type).type-var-width)))
        (:else
            (print "UNKNOWN"))))

(defun print-signatures (func-map (* mut (Vec (Pair (@ mut u8) Signature)))) (seqn
    (let i = 0)
    (while (< i (deref func-map).len) (seqn
        (let func = (vec-get func-map i))
        (print (deref func).a)
        (print ": (")
        (let j = 0)
        (while (< j (deref func).b.arg-types.len) (seqn
            (cond
                ((!= j 0)
                    (print " ")))
            (print-type (vec-get (ref (deref func).b.arg-types) j))
            (set j = (+ j 1))))
        (print ") : ")
        (print-type (ref (deref func).b.ret-type))
        (print "\n")
        (set i = (+ i 1))))))

(defmacro COERCION_TYPE_NONE   0)
(defmacro COERCION_TYPE_INT    1)
(defmacro COERCION_TYPE_FLOAT  2)

(defun type-clone (type (* mut Type)) : Type (seq
    (let new = (ref (empty-type (deref type).subtypes.A)))
    (set (deref new).type = (deref type).type)
    (set (deref new).signed-mutable = (deref type).signed-mutable)
    (let i = 0)
    (let subtypes = (ref (deref new).subtypes))
    (while (< i (deref type).subtypes.len) (seqn
        (vec-push subtypes (type-clone (vec-get (ref (deref type).subtypes) i)))
        (set i = (+ i 1))))
    (set (deref new).subtypes = (deref subtypes))
    (cond
        ((: u64 (cast (deref type).boxed)) (seqn
            (set (deref new).boxed = (alloc (deref type).subtypes.A))
            (set (deref (deref new).boxed) = (type-clone (deref type).boxed)))))
    (set (deref new).name = (deref type).name)
    (set (deref new).type-var-width = (deref type).type-var-width)
    (deref new)))

(defun type-equals (a Type) (b Type) : u1
    (cond
        ((== a.type b.type)
            (cond
                ((== a.type (TYPE_TYPE_INT))
                    (and (== a.signed-mutable b.signed-mutable) (== a.type-var-width b.type-var-width)))
                ((== a.type (TYPE_TYPE_TUPLE))
                    (and (== a.subtypes.len b.subtypes.len) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((or (== a.type (TYPE_TYPE_POINTER)) (== a.type (TYPE_TYPE_SLICE)))
                    (type-equals (deref a.boxed) (deref b.boxed)))
                ((== a.type (TYPE_TYPE_STRUCT))
                    (and (and (str-equals a.name b.name) (== a.subtypes.len b.subtypes.len)) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((== a.type (TYPE_TYPE_GENERIC))
                    (str-equals a.name b.name))
                ((== a.type (TYPE_TYPE_FUNCTION))
                    (and (and (type-equals (deref a.boxed) (deref b.boxed)) (== a.subtypes.len b.subtypes.len)) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((== a.type (TYPE_TYPE_TYPE_VARIABLE))
                    (== a.type-var-width b.type-var-width))
                (:else true)))
        (:else false)))

(defun get-type-leaf (type (* mut Type)) (substitutions (* mut (Vec (Pair Type u64)))) (seqn
    (while (== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
        (let new = (deref (vec-get substitutions (deref type).type-var-width)).a)
        (cond
            ((and (== new.type (TYPE_TYPE_TYPE_VARIABLE)) (== new.type-var-width (deref type).type-var-width))
                (break)))
        (set (deref type) = new)))))

(defun substitute (loc Location) (assignee (* mut Type)) (assigner (* mut Type)) (substitutions (* mut (Vec (Pair Type u64)))) (errors (* mut (Vec TypeError))) (seqn
    (get-type-leaf assignee substitutions)
    (get-type-leaf assigner substitutions)
    (cond
        ((type-equals (deref assignee) (deref assigner))
            ())

        ((== (deref assignee).type (TYPE_TYPE_UNKNOWN)) (seqn
            (set (deref assignee) = (type-clone assigner))))

        ((== (deref assignee).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (let coercion = (deref (vec-get substitutions (deref assignee).type-var-width)).b)
            (let assign = (cond
                ((and (== coercion (COERCION_TYPE_INT)) (== (deref assigner).type (TYPE_TYPE_INT)))
                    true)
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== (deref assigner).type (TYPE_TYPE_F32)) (== (deref assigner).type (TYPE_TYPE_F32))))
                    true)
                ((== coercion (COERCION_TYPE_NONE))
                    true)
                ((== (deref assigner).type (TYPE_TYPE_TYPE_VARIABLE)) (seq
                    (let pair = (vec-get substitutions (deref assigner).type-var-width))
                    (cond
                        ((== (deref pair).b (COERCION_TYPE_NONE)) (seq
                            (set (deref pair).b = coercion)
                            true))
                        ((== (deref pair).b coercion)
                            true)
                        (:else (seq
                            (vec-push errors (type-error loc "type cannot be coerced"))
                            false)))))
                (:else (seq
                    (vec-push errors (type-error loc "type cannot be coerced"))
                    false))))
            (cond
                (assign (seqn
                    (let v = (vec-get substitutions (deref assignee).type-var-width))
                    (set (deref v).a = (type-clone assigner))
                    (set (deref assignee) = (type-clone assigner)))))))

        ((== (deref assigner).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (let coercion = (deref (vec-get substitutions (deref assigner).type-var-width)).b)
            (let assign = (cond
                ((and (== coercion (COERCION_TYPE_INT)) (== (deref assignee).type (TYPE_TYPE_INT)))
                    true)
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== (deref assignee).type (TYPE_TYPE_F32)) (== (deref assignee).type (TYPE_TYPE_F32))))
                    true)
                ((== coercion (COERCION_TYPE_NONE))
                    true)
                ((== (deref assignee).type (TYPE_TYPE_TYPE_VARIABLE)) (seq
                    (let pair = (vec-get substitutions (deref assignee).type-var-width))
                    (cond
                        ((== (deref pair).b (COERCION_TYPE_NONE)) (seq
                            (set (deref pair).b = coercion)
                            true))
                        ((== (deref pair).b coercion)
                            true)
                        (:else (seq
                            (vec-push errors (type-error loc "type cannot be coerced"))
                            false)))))
                (:else (seq
                    (vec-push errors (type-error loc "type cannot be coerced"))
                    false))))
            (cond
                (assign (seqn
                    (let v = (vec-get substitutions (deref assigner).type-var-width))
                    (set (deref v).a = (type-clone assignee)))))))

        ((type-equals (deref assignee) (deref assigner))
            ())

        ((== (deref assignee).type (deref assigner).type)
            (cond
                ((== (deref assignee).type (TYPE_TYPE_TUPLE))
                    (cond
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "tuple types have incompatible lengths")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))))))

                ((or (== (deref assignee).type (TYPE_TYPE_POINTER)) (== (deref assignee).type (TYPE_TYPE_SLICE)))
                    (substitute loc (deref assignee).boxed (ref (deref (deref assigner).boxed)) substitutions errors))

                ((== (deref assignee).type (TYPE_TYPE_STRUCT))
                    (cond
                        ((not (str-equals (deref assignee).name (deref assigner).name))
                            (vec-push errors (type-error loc "incompatible struct types")))
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "struct types have incompatible number of type parameters")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))))))

                ((== (deref assignee).type (TYPE_TYPE_FUNCTION))
                    (cond
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "function types have incompatible arg numbers")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))
                            (substitute loc (deref assignee).boxed (ref (deref (deref assigner).boxed)) substitutions errors)))))
                (:else (seqn
                    (vec-push errors (type-error loc "the given types cannot be unified"))))))

        (:else (seqn
            (vec-push errors (type-error loc "the given types cannot be unified")))))))

(defun check-ast
    (ast (* mut Ast))
    (errors (* mut (Vec TypeError)))
    (substitutions (* mut (Vec (Pair Type u64))))
    (func-map (* mut (Vec (Pair (@ mut u8) Signature))))
    (struct-map (* mut (Vec (Pair (@ mut u8) Struct))))
    (monomorphisms (* mut (Vec (Pair Type u64))))
    (scopes (* mut (Vec (Vec (Pair (@ mut u8) Type)))))
    (break-type (* mut Type))
(cond
    ((== (deref ast).type (AST_NODE_TYPE_SEXPR))
        (cond
            ((not (deref ast).children.len) (seqn
                (set (deref ast).typed = (empty-type (deref errors).A))
                (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "seqn"))
                (cond
                    ((> (deref ast).children.len 1) (seqn
                        (vec-push scopes (new-vec (deref errors).A))
                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (check-ast (vec-get (ref (deref ast).children) i) errors substitutions func-map struct-map monomorphisms scopes break-type)
                            (set i = (+ i 1))))
                        (set (deref ast).typed = (empty-type (deref errors).A))
                        (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))
                        (vec-pop scopes)))
                    (:else (seqn
                        (vec-push errors (type-error (deref ast).loc "seqn must have one or more arguments"))))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "seq"))
                (cond
                    ((> (deref ast).children.len 1) (seqn
                        (vec-push scopes (new-vec (deref errors).A))
                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (check-ast (vec-get (ref (deref ast).children) i) errors substitutions func-map struct-map monomorphisms scopes break-type)
                            (set i = (+ i 1))))
                        (set (deref ast).typed = (deref (vec-get (ref (deref ast).children) (- i 1))).typed)
                        (vec-pop scopes)))
                    (:else (seqn
                        (vec-push errors (type-error (deref ast).loc "seq must have one or more arguments"))))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "loop"))
                (cond
                    ((== (deref ast).children.len 2) (seqn
                        (vec-push scopes (new-vec (deref errors).A))
                        (let break-type = (ref (empty-type (deref errors).A)))
                        (check-ast (vec-get (ref (deref ast).children) 1) errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (cond
                            ((== (deref break-type).type (TYPE_TYPE_UNKNOWN)) (seqn
                                (set (deref break-type).type = (TYPE_TYPE_TUPLE)))))
                        (set (deref ast).typed = (deref break-type))
                        (vec-pop scopes)))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "loop must have only one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "break")) (seqn
                (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))
                (let type = (cond
                    ((== (deref ast).children.len 2) (seq
                        (let value = (vec-get (ref (deref ast).children) 1))
                        (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (deref value).typed))
                    ((== (deref ast).children.len 1) (seq
                        (let t = (ref (empty-type (deref errors).A)))
                        (set (deref t).type = (TYPE_TYPE_TUPLE))
                        (deref t)))
                    (:else (seq
                        (vec-push errors (type-error (deref ast).loc "break type does not match previous break type"))
                        (empty-type (deref errors).A)))))
                (cond
                    ((: u64 (cast break-type))
                        (substitute (deref ast).loc break-type (ref type) substitutions errors))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "break found outside of loop"))))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "cond"))
                (cond
                    ((> (deref ast).children.len 1) (seqn
                        (let has-else = false)
                        (let type = (ref (empty-type (deref errors).A)))
                        (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
                        (set (deref type).type-var-width = (deref substitutions).len)
                        (vec-push substitutions (inst Pair
                            (a (type-clone type))
                            (b (COERCION_TYPE_NONE))))
                        (set (deref ast).typed = (deref type))
                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (let child = (vec-get (ref (deref ast).children) i))
                            (cond
                                ((and (== (deref child).type (AST_NODE_TYPE_SEXPR)) (== (deref child).children.len 2)) (seqn
                                    (vec-push scopes (new-vec (deref errors).A))
                                    (let condy = (vec-get (ref (deref child).children) 0))
                                    (cond
                                        ((and (== i (- (deref ast).children.len 1)) (and (== (deref condy).type (AST_NODE_TYPE_KEY)) (str-equals (deref condy).value ":else"))) (seqn
                                            (set has-else = true)))
                                        (:else (seqn
                                            (check-ast condy errors substitutions func-map struct-map monomorphisms scopes break-type)
                                            (cond
                                                ((== (deref condy).typed.type (TYPE_TYPE_INT))
                                                    ())
                                                ((== (deref condy).typed.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                                                    (let pair = (deref (vec-get substitutions (deref condy).typed.type-var-width)))
                                                    (cond
                                                        ((== pair.a.type (TYPE_TYPE_INT))
                                                            ())
                                                        ((== pair.b (COERCION_TYPE_INT))
                                                            ())
                                                        (:else
                                                            (vec-push errors (type-error (deref condy).loc "condition must have integer type"))))))
                                                (:else
                                                    (vec-push errors (type-error (deref condy).loc "condition must have an integer type")))))))

                                    (let then = (vec-get (ref (deref child).children) 1))
                                    (check-ast then errors substitutions func-map struct-map monomorphisms scopes break-type)
                                    (let t = (ref (deref ast).typed))
                                    (substitute (deref then).loc t (ref (deref then).typed) substitutions errors)
                                    (set (deref ast).typed = (deref t))
                                    (vec-pop scopes)))
                                (:else
                                    (vec-push errors (type-error (deref child).loc "cond must have S expression as branch"))))
                            (set i = (+ i 1))))
                        (cond
                            ((not has-else) (seqn
                                (let t = (ref (deref ast).typed))
                                (let nil-type = (ref (empty-type (deref errors).A)))
                                (set (deref nil-type).type = (TYPE_TYPE_TUPLE))
                                (substitute (deref ast).loc t nil-type substitutions errors)
                                (set (deref ast).typed = (deref t)))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "cond must have at least one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value ":"))
                (cond
                    ((== (deref ast).children.len 3) (seqn
                        (let type-ast = (vec-get (ref (deref ast).children) 1))
                        (let asserted-type = (parse-type type-ast errors))
                        (set (deref ast).typed = (type-clone (ref asserted-type)))
                        (let v = (vec-get (ref (deref ast).children) 2))
                        (check-ast v errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (let t = (ref (deref v).typed))
                        (substitute (deref ast).loc t (ref asserted-type) substitutions errors)
                        (set (deref v).typed = (deref t))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc ": takes two arguments")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "let"))
                (cond
                    ((== (deref ast).children.len 4) (seqn
                        (let var-name = (vec-get (ref (deref ast).children) 1))
                        (let equals = (vec-get (ref (deref ast).children) 2))
                        (let value = (vec-get (ref (deref ast).children) 3))
                        (cond
                            ((!= (deref var-name).type (AST_NODE_TYPE_SYMBOL))
                                (vec-push errors (type-error (deref var-name).loc "let expects a variable name after it")))
                            ((or (!= (deref equals).type (AST_NODE_TYPE_SYMBOL)) (not (str-equals (deref equals).value "=")))
                                (vec-push errors (type-error (deref equals).loc "let expects an `=` after the variable name")))
                            (:else (seqn
                                (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                                (cond
                                    ((== (deref scopes).len 0)
                                        (vec-push errors (type-error (deref ast).loc "let must occur within a scope")))
                                    (:else (seqn
                                        (let scope = (vec-get scopes (- (deref scopes).len 1)))
                                        (let v = (vec-find scope matches-key (deref var-name).value))
                                        (cond
                                            ((: u64 (cast v)) (seqn
                                                (set (deref v).b = (deref value).typed)))
                                            (:else
                                                (vec-push scope (inst Pair
                                                    (a (deref var-name).value)
                                                    (b (deref value).typed)))))
                                        (set (deref ast).typed = (type-clone (ref (deref value).typed)))))))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "let expects 3 arguments")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "inst"))
                (cond
                    ((>= (deref ast).children.len 2) (seqn
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                (let struct = (vec-find struct-map matches-key (deref name).value))
                                (cond
                                    ((: u64 (cast struct)) (seqn
                                        (let struct = (deref struct).b)
                                        (let generics = (ref (new-vec (deref ast).children.A)))
                                        (let final-generics = (ref (new-vec (deref errors).A)))
                                        (let i = 0)
                                        (while (< i struct.generics.len) (seqn
                                            (let g = (deref (vec-get (ref struct.generics) i)))
                                            (let type = (ref (empty-type (deref errors).A)))
                                            (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
                                            (set (deref type).type-var-width = (deref substitutions).len)
                                            (vec-push substitutions (inst Pair
                                                (a (deref type))
                                                (b (COERCION_TYPE_NONE))))
                                            (vec-push generics (inst Pair
                                                (a g)
                                                (b (deref type))))
                                            (vec-push final-generics (deref type))
                                            (set i = (+ i 1))))
                                        (let i = 2)
                                        (while (< i (deref ast).children.len) (seqn
                                            (let field = (vec-get (ref (deref ast).children) i))
                                            (cond
                                                ((and (== (deref field).type (AST_NODE_TYPE_SEXPR)) (== (deref field).children.len 2)) (seqn
                                                    (let name = (vec-get (ref (deref field).children) 0))
                                                    (let value = (vec-get (ref (deref field).children) 1))
                                                    (cond
                                                        ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                                            (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                                                            (let type = (vec-find (ref struct.fields) matches-key (deref name).value))
                                                            (cond
                                                                ((: u64 (cast type)) (seqn
                                                                    (let t = (ref (deref value).typed))
                                                                    (let assigner = (ref (type-clone (ref (deref type).b))))
                                                                    (replace-generics assigner generics substitutions)
                                                                    (substitute (deref value).loc t assigner substitutions errors)
                                                                    (set (deref value).typed = (deref t))))
                                                                (:else
                                                                    (vec-push errors (type-error (deref name).loc "struct cannot be instantiated with the given field"))))))
                                                        (:else
                                                            (vec-push errors (type-error (deref name).loc "field must be a symbol"))))))
                                                (:else
                                                    (vec-push errors (type-error (deref field).loc "field entry for inst must be an S expression with two values"))))
                                            (set i = (+ i 1))))
                                        (let t = (ref (empty-type (deref errors).A)))
                                        (set (deref t).type = (TYPE_TYPE_STRUCT))
                                        (set (deref t).name = (deref name).value)
                                        (set (deref t).subtypes = (deref final-generics))
                                        (set (deref ast).typed = (deref t))))
                                    (:else
                                        (vec-push errors (type-error (deref name).loc "undefined struct"))))))
                            (:else
                                (vec-push errors (type-error (deref name).loc "inst must take in a valid struct name"))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "inst takes at least one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "sizeof"))
                (cond
                    ((== (deref ast).children.len 2) (seqn
                        (parse-type (vec-get (ref (deref ast).children) 1) errors)
                        (let type = (ref (empty-type (deref errors).A)))
                        (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
                        (set (deref type).type-var-width = (deref substitutions).len)
                        (vec-push substitutions (inst Pair
                            (a (deref type))
                            (b (COERCION_TYPE_INT))))
                        (set (deref ast).typed = (deref type))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "sizeof takes one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "set"))
                (cond
                    ((== (deref ast).children.len 4) (seqn
                        (let value = (vec-get (ref (deref ast).children) 3))
                        (let equal = (vec-get (ref (deref ast).children) 2))
                        (let lvalue = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((and (== (deref equal).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref equal).value "=")) (seqn
                                (check-lvalue lvalue errors substitutions func-map struct-map monomorphisms scopes break-type)
                                (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                                (substitute (deref ast).loc (ref (deref value).typed) (ref (deref lvalue).typed) substitutions errors)
                                (set (deref ast).typed = (type-clone (ref (deref value).typed)))))
                            (:else
                                (vec-push errors (type-error (deref equal).loc "set requires an `=` in its second argument"))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "set takes 3 arguments")))))

            (:else (seqn
                (let i = 0)
                (while (< i (deref ast).children.len) (seqn
                    (let v = (vec-get (ref (deref ast).children) i))
                    (check-ast v errors substitutions func-map struct-map monomorphisms scopes break-type)
                    (set i = (+ i 1))))
                (let func = (vec-get (ref (deref ast).children) 0))
                (cond
                    ((== (deref func).typed.type (TYPE_TYPE_FUNCTION))
                        (cond
                            ((== (deref func).typed.subtypes.len (- i 1)) (seqn
                                (let i = 0)
                                (while (< i (deref func).typed.subtypes.len) (seqn
                                    (let arg = (vec-get (ref (deref ast).children) (+ i 1)))
                                    (let t = (ref (deref arg).typed))
                                    (substitute (deref arg).loc t (vec-get (ref (deref func).typed.subtypes) i) substitutions errors)
                                    (set (deref arg).typed = (deref t))
                                    (set i = (+ i 1))))
                                (set (deref ast).typed = (type-clone (deref func).typed.boxed))))
                            (:else
                                (vec-push errors (type-error (deref ast).loc "function argument count does not match provided argument count")))))
                    (:else
                        (vec-push errors (type-error (deref func).loc "value is not a function"))))))))

    ((== (deref ast).type (AST_NODE_TYPE_INT)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
        (set (deref type).type-var-width = (deref substitutions).len)
        (vec-push substitutions (inst Pair
            (a (deref type))
            (b (COERCION_TYPE_INT))))
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_CHAR)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_INT))
        (set (deref type).type-var-width = 8)
        (set (deref type).signed-mutable = false)
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_BOOL)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_INT))
        (set (deref type).type-var-width = 1)
        (set (deref type).signed-mutable = false)
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_STRING)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_SLICE))
        (set (deref type).signed-mutable = false)
        (set (deref type).boxed = (alloc (deref errors).A))
        (let subtype = (ref (empty-type (deref errors).A)))
        (set (deref subtype).type = (TYPE_TYPE_INT))
        (set (deref subtype).type-var-width = 8)
        (set (deref subtype).signed-mutable = false)
        (set (deref (deref type).boxed) = (deref subtype))
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seqn
        (let i = (deref scopes).len)
        (set (deref ast).typed = (while (!= i 0) (seqn
            (set i = (- i 1))
            (let scope = (vec-get scopes i))
            (let v = (vec-find scope matches-key (deref ast).value))
            (cond
                ((: u64 (cast v))
                    (break (type-clone (ref (deref v).b))))))
        :else (seq
            (let v = (vec-find func-map matches-key (deref ast).value))
            (cond
                ((: u64 (cast v)) (seq
                    (let v = (deref v).b)
                    (let type = (ref (empty-type (deref errors).A)))
                    (set (deref type).type = (TYPE_TYPE_FUNCTION))
                    (set (deref type).boxed = (alloc (deref errors).A))
                    (set (deref (deref type).boxed) = (type-clone (ref v.ret-type)))
                    (let i = 0)
                    (let subtypes = (ref (deref type).subtypes))
                    (while (< i v.arg-types.len) (seqn
                        (vec-push subtypes (type-clone (vec-get (ref v.arg-types) i)))
                        (set i = (+ i 1))))
                    (set (deref type).subtypes = (deref subtypes))
                    (cond
                        ((has-generic type) (seqn
                            (let generics = (ref (new-vec (deref errors).A)))
                            (replace-generics type generics substitutions)
                            (vec-push monomorphisms (inst Pair
                                (a (deref type))
                                (b v.index))))))
                    (deref type)))
                (:else (seq
                    (vec-push errors (type-error (deref ast).loc "undefined symbol"))
                    (empty-type (deref errors).A)))))))))

    ((== (deref ast).type (AST_NODE_TYPE_KEY))
        (vec-push errors (type-error (deref ast).loc "invalid usage of key")))

    ((== (deref ast).type (AST_NODE_TYPE_QUOTE))
        (vec-push errors (type-error (deref ast).loc "invalid usage of quote")))

    ((== (deref ast).type (AST_NODE_TYPE_ATTR)) (seqn
        (let child = (vec-get (ref (deref ast).children) 0))
        (check-ast child errors substitutions func-map struct-map monomorphisms scopes break-type)
        (let i = 1)
        (let type = (ref (type-clone (ref (deref child).typed))))
        (while (< i (deref ast).children.len) (seqn
            (while (== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                (let t = (vec-get substitutions (deref type).type-var-width))
                (cond
                    ((and (== (deref t).a.type (TYPE_TYPE_TYPE_VARIABLE)) (== (deref t).a.type-var-width (deref type).type-var-width))
                        (break)))
                (set (deref type) = (type-clone (ref (deref t).a)))))

            (let attr-ast = (vec-get (ref (deref ast).children) i))
            (let attr = (deref attr-ast).value)
            (cond
                ((== (deref type).type (TYPE_TYPE_POINTER))
                    (cond
                        ((str-equals attr "*") (seqn
                            (set (deref type) = (type-clone (deref type).boxed))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "pointer can only be dereferenced"))
                            (break)))))
                ((== (deref type).type (TYPE_TYPE_SLICE))
                    (cond
                        ((str-equals attr "ptr") (seqn
                            (set (deref type) = (type-clone type))
                            (set (deref type).type = (TYPE_TYPE_POINTER))))
                        ((or (str-equals attr "len") (str-equals attr "cap")) (seqn
                            (set (deref type) = (empty-type (deref errors).A))
                            (set (deref type).type = (TYPE_TYPE_INT))
                            (set (deref type).type-var-width = 64)
                            (set (deref type).signed-mutable = false)))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "invalid attribute of slice"))
                            (break)))))
                ((== (deref type).type (TYPE_TYPE_STRUCT)) (seqn
                    (let struct = (vec-find struct-map matches-key (deref type).name))
                    (let field = (vec-find (ref (deref struct).b.fields) matches-key attr))
                    (cond
                        ((: u64 (cast field)) (seqn
                            (let t = (ref (type-clone (ref (deref field).b))))
                            (let generics = (ref (new-vec (deref errors).A)))
                            (let i = 0)
                            (while (and (< i (deref struct).b.generics.len) (< i (deref type).subtypes.len)) (seqn
                                (vec-push generics (inst Pair
                                    (a (deref (vec-get (ref (deref struct).b.generics) i)))
                                    (b (type-clone (vec-get (ref (deref type).subtypes) i)))))
                                (set i = (+ i 1))))
                            (replace-generics t generics substitutions)
                            (set (deref type) = (deref t))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "struct does not have the given field"))
                            (break)))))))
            (set i = (+ i 1))))
        (set (deref ast).typed = (deref type))))

    (:else (seqn
        (eprint "todo: checking ast type ")
        (eprint-int (deref ast).type)
        (eprint " is currently unimplemented\n")
        (exit 1)))))

(defun check-lvalue
    (lvalue (* mut Ast))
    (errors (* mut (Vec TypeError)))
    (substitutions (* mut (Vec (Pair Type u64))))
    (func-map (* mut (Vec (Pair (@ mut u8) Signature))))
    (struct-map (* mut (Vec (Pair (@ mut u8) Struct))))
    (monomorphisms (* mut (Vec (Pair Type u64))))
    (scopes (* mut (Vec (Vec (Pair (@ mut u8) Type)))))
    (break-type (* mut Type))
(cond
    ((== (deref lvalue).type (AST_NODE_TYPE_SYMBOL)) (seqn
        (let i = (deref scopes).len)
        (set (deref lvalue).typed = (while (!= i 0) (seqn
            (set i = (- i 1))
            (let scope = (vec-get scopes i))
            (let v = (vec-find scope matches-key (deref lvalue).value))
            (cond
                ((: u64 (cast v))
                    (break (type-clone (ref (deref v).b))))))
        :else (seq
            (vec-push errors (type-error (deref lvalue).loc "undefined symbol"))
            (empty-type (deref errors).A))))))
    ((== (deref lvalue).type (AST_NODE_TYPE_ATTR)) (seqn
        (let child = (vec-get (ref (deref lvalue).children) 0))
        (check-lvalue child errors substitutions func-map struct-map monomorphisms scopes break-type)
        (let i = 1)
        (let type = (type-clone (ref (deref child).typed)))
        (while (< i (deref lvalue).children.len) (seqn
            (while (== type.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                (let t = (deref (vec-get substitutions type.type-var-width)).a)
                (cond
                    ((and (== t.type (TYPE_TYPE_TYPE_VARIABLE)) (== t.type-var-width type.type-var-width))
                        (break)))
                (set type = (type-clone (ref t)))))
            (let attr-ast = (vec-get (ref (deref lvalue).children) i))
            (let attr = (deref attr-ast).value)
            (cond
                ((== type.type (TYPE_TYPE_STRUCT)) (seqn
                    (let struct = (vec-find struct-map matches-key type.name))
                    (let field = (vec-find (ref (deref struct).b.fields) matches-key attr))
                    (cond
                        ((: u64 (cast field)) (seqn
                            (let t = (ref (type-clone (ref (deref field).b))))
                            (let generics = (ref (new-vec (deref errors).A)))
                            (let i = 0)
                            (while (and (< i (deref struct).b.generics.len) (< i type.subtypes.len)) (seqn
                                (vec-push generics (inst Pair
                                    (a (deref (vec-get (ref (deref struct).b.generics) i)))
                                    (b (type-clone (vec-get (ref type.subtypes) i)))))
                                (set i = (+ i 1))))
                            (replace-generics t generics substitutions)
                            (set type = (deref t))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "struct does not have the given field"))
                            (break))))))
                ((== type.type (TYPE_TYPE_POINTER))
                    (cond
                        ((str-equals attr "*") (seqn
                            (set type = (deref type.boxed))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "cannot take field of pointer"))
                            (break)))))
                (:else (seqn
                    (vec-push errors (type-error (deref attr-ast).loc "cannot assign to field of type"))
                    (break))))
            (set i = (+ i 1))))
        (set (deref lvalue).typed = type)))
    ((and (== (deref lvalue).type (AST_NODE_TYPE_SEXPR)) (> (deref lvalue).children.len 0)) (seqn
        (let func-name = (vec-get (ref (deref lvalue).children) 0))
        (cond
            ((and (== (deref func-name).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func-name).value "deref"))
                (cond
                    ((== (deref lvalue).children.len 2) (seqn
                        (let child = (vec-get (ref (deref lvalue).children) 1))
                        (check-lvalue child errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (cond
                            ((== (deref child).typed.type (TYPE_TYPE_POINTER)) (seqn
                                (set (deref lvalue).typed = (type-clone (deref child).typed.boxed))))
                            ((== (deref child).typed.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                                (let u = (ref (empty-type (deref child).children.A)))
                                (set (deref u).type = (TYPE_TYPE_TYPE_VARIABLE))
                                (set (deref u).type-var-width = (deref substitutions).len)
                                (vec-push substitutions (inst Pair
                                    (a (deref u))
                                    (b (COERCION_TYPE_NONE))))
                                (let t = (ref (empty-type (deref child).children.A)))
                                (set (deref t).type = (TYPE_TYPE_POINTER))
                                (set (deref t).boxed = (alloc (deref errors).A))
                                (set (deref (deref t).boxed) = (deref u))
                                (let s = (ref (deref child).typed))
                                (substitute (deref child).loc s t substitutions errors)
                                (set (deref child).typed = (deref s))
                                (set (deref lvalue).typed = (deref u))))
                            (:else
                                (vec-push errors (type-error (deref child).loc "derefed value is not a pointer"))))))
                    (:else
                        (vec-push errors (type-error (deref lvalue).loc "deref expects one argument")))))

            ((and (== (deref func-name).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func-name).value "get"))
                (cond
                    ((== (deref lvalue).children.len 3) (seqn
                        (let child = (vec-get (ref (deref lvalue).children) 2))
                        (check-ast child errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (let t = (ref (empty-type (deref errors).A)))
                        (set (deref t).type = (TYPE_TYPE_INT))
                        (set (deref t).type-var-width = 64)
                        (set (deref t).signed-mutable = false)
                        (let u = (ref (deref child).typed))
                        (substitute (deref child).loc u t substitutions errors)
                        (set (deref child).typed = (deref u))
                        (let child = (vec-get (ref (deref lvalue).children) 1))
                        (check-lvalue child errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (cond
                            ((== (deref child).typed.type (TYPE_TYPE_SLICE)) (seqn
                                (set (deref lvalue).typed = (type-clone (deref child).typed.boxed))))
                            ((== (deref child).typed.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                                (let u = (ref (empty-type (deref child).children.A)))
                                (set (deref u).type = (TYPE_TYPE_TYPE_VARIABLE))
                                (set (deref u).type-var-width = (deref substitutions).len)
                                (vec-push substitutions (inst Pair
                                    (a (deref u))
                                    (b (COERCION_TYPE_NONE))))
                                (let t = (ref (empty-type (deref child).children.A)))
                                (set (deref t).type = (TYPE_TYPE_SLICE))
                                (set (deref t).boxed = (alloc (deref errors).A))
                                (set (deref (deref t).boxed) = (deref u))
                                (let s = (ref (deref child).typed))
                                (substitute (deref child).loc s t substitutions errors)
                                (set (deref child).typed = (deref s))
                                (set (deref lvalue).typed = (deref u))))
                            (:else
                                (vec-push errors (type-error (deref child).loc "get value is not a slice"))))))
                    (:else
                        (vec-push errors (type-error (deref lvalue).loc "get expects two arguments")))))
            (:else
                (vec-push errors (type-error (deref func-name).loc "invalid lvalue function"))))))
    (:else
        (vec-push errors (type-error (deref lvalue).loc "invalid lvalue")))))

(defun flatten-substitution
    (type (* mut Type))
    (errors (* mut (Vec TypeError)))
    (loc Location)
    (substitutions (* mut (Vec (Pair Type u64))))
(cond
    ((== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
        (let type2 = (deref (vec-get substitutions (deref type).type-var-width)).a)
        (cond
            ((and (== type2.type (TYPE_TYPE_TYPE_VARIABLE)) (== type2.type-var-width (deref type).type-var-width))
                (vec-push errors (type-error loc "unassigned type variable")))
            (:else (seqn
                (set (deref type) = type2)
                (flatten-substitution type errors loc substitutions))))))
    (:else (seqn
        (cond
            ((: u64 (cast (deref type).boxed))
                (flatten-substitution (deref type).boxed errors loc substitutions)))
        (let i = 0)
        (while (< i (deref type).subtypes.len) (seqn
            (flatten-substitution (vec-get (ref (deref type).subtypes) i) errors loc substitutions)
            (set i = (+ i 1))))))))

(defun apply-substitutions (ast (* mut Ast)) (errors (* mut (Vec TypeError))) (substitutions (* mut (Vec (Pair Type u64)))) (seqn
    (let type = (ref (deref ast).typed))
    (flatten-substitution type errors (deref ast).loc substitutions)
    (set (deref ast).typed = (deref type))
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (apply-substitutions (vec-get (ref (deref ast).children) i) errors substitutions)
        (set i = (+ i 1))))))

(defun check
    (ast (* mut Ast))
    (errors (* mut (Vec TypeError)))
    (func-map (* mut (Vec (Pair (@ mut u8) Signature))))
    (struct-map (* mut (Vec (Pair (@ mut u8) Struct))))
(seqn
    (let skip = 0)
    (let done = (ref (new-vec (deref errors).A)))
    (while (seq
        (let monomorphisms = (ref (new-vec (deref errors).A)))
        (let scopes = (ref (new-vec (deref errors).A)))

        (let substitutions = (ref (new-vec (deref errors).A)))
        (let i = skip)
        (while (< i (deref ast).children.len) (seqn
            (let ast = (vec-get (ref (deref ast).children) i))
            (cond
                ((not (deref ast).children.len)
                    (vec-push errors (type-error (deref ast).loc "invalid top level construct `()`")))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defun"))
                    (cond
                        ((not (has-generic (ref (deref ast).typed))) (seqn
                            (let name = (deref (vec-get (ref (deref ast).children) 1)).value)
                            (let func-type = (deref ast).typed)
                            (let body = (vec-get (ref (deref ast).children) (- (deref ast).children.len 1)))
                            (let v = (ref (new-vec (deref errors).A)))
                            (let i = 0)
                            (while (< i func-type.subtypes.len) (seqn
                                (let arg = (vec-get (ref (deref ast).children) (+ i 2)))
                                (let arg = (vec-get (ref (deref arg).children) 0))
                                (let arg = (deref arg).value)
                                (let type = (vec-get (ref func-type.subtypes) i))
                                (vec-push v (inst Pair
                                    (a arg)
                                    (b (deref type))))
                                (set i = (+ i 1))))
                            (vec-push scopes (deref v))

                            (check-ast body errors substitutions func-map struct-map monomorphisms scopes (null))
                            (vec-pop scopes)
                            (let type = (ref (deref body).typed))
                            (substitute (deref body).loc type func-type.boxed substitutions errors)
                            (set (deref body).typed = (deref type))))))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defstruct")) ())
                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defmacro")) ())

                (:else
                    (vec-push errors (type-error (deref ast).loc "invalid top level construct"))))
            (set i = (+ i 1))))

        (let i = 0)
        (while (< i (deref substitutions).len) (seqn
            (let pair = (vec-get substitutions i))
            (let type = (deref pair).a)
            (let coercion = (deref pair).b)
            (cond
                ((and (== coercion (COERCION_TYPE_INT)) (and (== type.type (TYPE_TYPE_TYPE_VARIABLE)) (== type.type-var-width i))) (seqn
                    (set type = (empty-type (deref errors).A))
                    (set type.type = (TYPE_TYPE_INT))
                    (set type.type-var-width = 32)
                    (set type.signed-mutable = true)))
                ((and (== coercion (COERCION_TYPE_INT)) (== type.type (TYPE_TYPE_INT)))
                    ())

                ((and (== coercion (COERCION_TYPE_FLOAT)) (and (== type.type (TYPE_TYPE_TYPE_VARIABLE)) (== type.type-var-width i))) (seqn
                    (set type = (empty-type (deref errors).A))
                    (set type.type = (TYPE_TYPE_F64))))
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== type.type (TYPE_TYPE_F32)) (== type.type (TYPE_TYPE_F64))))
                    ()))
            (set (deref pair).a = type)
            (set i = (+ i 1))))

        (apply-substitutions ast errors substitutions)

        (set skip = (deref ast).children.len)
        (cond
            ((deref monomorphisms).len (seqn
                (let i = 0)
                (let asts = (ref (deref ast).children))
                (while (< i (deref monomorphisms).len) (seqn
                    (let monomorphism = (vec-get monomorphisms i))
                    (cond
                        ((not (: u64 (cast (vec-find done type-find (deref monomorphism).a)))) (seqn
                            (let ast = (vec-get asts (deref monomorphism).b))
                            (cond
                                ((: u64 (cast ast)) (seqn
                                    (let ast = (ref (ast-clone (deref ast))))
                                    (let typed = (ref (type-clone (ref (deref monomorphism).a))))
                                    (flatten-substitution typed errors (deref ast).loc substitutions)
                                    (set (deref ast).typed = (deref typed))
                                    (vec-push done (deref ast).typed)
                                    (vec-push asts (deref ast))))))))
                    (set i = (+ i 1))))
                (set (deref ast).children = (deref asts)))))
        (and (< skip (deref ast).children.len) (not (deref errors).len))) ())))

(defun type-find (type (* mut Type)) (t2 Type) : u1
    (type-equals (deref type) t2))

(defun print-type-errors (contents (@ mut u8)) (errors (* mut (Vec TypeError))) (seqn
    (let i = 0)
    (while (< i (deref errors).len) (seqn
        (let error = (deref (vec-get errors i)))
        (eprint "error: ")
        (eprint error.message)
        (let line-col = (loc-to-line-col contents error.loc))
        (eprint " (")
        (eprint-int line-col.line-start)
        (eprint ":")
        (eprint-int line-col.col-start)
        (eprint "..")
        (eprint-int line-col.line-end)
        (eprint ":")
        (eprint-int line-col.col-end)
        (eprint ")\n")
        (set i = (+ i 1))))
    (cond
        (i (exit 1)))))

(defun create-default-signatures (A (* mut Allocator)) : (Vec (Pair (@ mut u8) Signature)) (seq
    (let map = (ref (new-vec A)))
    (vec-push map (inst Pair
        (a "+")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "-")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "*")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "/")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "%")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "<<")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a ">>")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "&")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "|")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "^")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "<")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a ">")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "<=")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a ">=")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "==")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "!=")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "ptr-add")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "cast")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "b")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "ptr-sub")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "alloca")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_SLICE))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "ref")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "deref")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "get")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_SLICE))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))

                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "slice")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))

                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_SLICE))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "syscall")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let i = 0)
                (while (< i 7) (seqn
                    (let t = (ref (empty-type A)))
                    (set (deref t).type = (TYPE_TYPE_INT))
                    (set (deref t).type-var-width = 64)
                    (set (deref t).signed-mutable = false)
                    (vec-push v (deref t))
                    (set i = (+ i 1))))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (deref map)))



//
// ==================================================================================================
// LOWERING AST -> IR
// ==================================================================================================
//

(defstruct SsaType
    // 63-60 - alignment (2^n where n is the number encoded)
    // 59    - signed
    // 58-43 - number of fields
    // 42-0  - width
    (data u64))

(defun ssa-type-alignment (type SsaType) : u64
    // TODO: hex
    // 0xf000000000000000
    (>> (& type.data 17293822569102704640) 60))

(defun ssa-type-signed (type SsaType) : u64
    // TODO: hex
    // 1 << 59
    (>> (& type.data 576460752303423488) 59))

(defun ssa-type-field-count (type SsaType) : u64
    // TODO: hex
    // 0xffff << 43
    (>> (& type.data 576451956210401280) 43))

(defun ssa-type-width (type SsaType) : u64
    // TODO: hex
    // (1 << 43) - 1
    (& type.data 8796093022207))

(defstruct SsaValue
    (index u64)
    (type SsaType))

(defmacro SSA_INSTRUCTION_OPCODE_INT                0)
(defmacro SSA_INSTRUCTION_OPCODE_RETURN             1)
(defmacro SSA_INSTRUCTION_OPCODE_JUMP               2)
(defmacro SSA_INSTRUCTION_OPCODE_BRANCH_FALSE       3)
(defmacro SSA_INSTRUCTION_OPCODE_INT_OPERATION      4)
(defmacro SSA_INSTRUCTION_OPCODE_FLOAT_OPERATION    5)

(defmacro SSA_OPERATION_METADATA_MUL                0)
(defmacro SSA_OPERATION_METADATA_DIV                1)
(defmacro SSA_OPERATION_METADATA_MOD                2)
(defmacro SSA_OPERATION_METADATA_ADD                3)
(defmacro SSA_OPERATION_METADATA_SUB                4)
(defmacro SSA_OPERATION_METADATA_BSL                5)
(defmacro SSA_OPERATION_METADATA_BSR                6)
(defmacro SSA_OPERATION_METADATA_BAND               7)
(defmacro SSA_OPERATION_METADATA_BOR                8)
(defmacro SSA_OPERATION_METADATA_BXOR               9)
(defmacro SSA_OPERATION_METADATA_GT                10)
(defmacro SSA_OPERATION_METADATA_GTE               11)
(defmacro SSA_OPERATION_METADATA_LT                12)
(defmacro SSA_OPERATION_METADATA_LTE               13)
(defmacro SSA_OPERATION_METADATA_EQ                14)
(defmacro SSA_OPERATION_METADATA_NE                15)

(defstruct SsaInstruction
    (returned SsaValue)
    (opcode u64)
    (metadata u64)
    (arguments (Vec SsaValue)))

(defstruct SsaBasicBlock
    (parameters (Vec SsaValue))
    (insts (Vec SsaInstruction)))

(defstruct SsaFunction
    (linkage u64)
    (last-value u64)
    (blocks (Vec SsaBasicBlock)))

(defstruct Ssa
    (funcs (Vec (Pair (Vec u8) SsaFunction)))
    (raw-data (Vec u8))
    (current-func u64)
    (current-block u64))

(defun mangle-func-name (A (* mut Allocator)) (name (@ mut u8)) (type (* mut Type)) : (Vec u8) (seq
    (let new-name = (ref (new-vec A)))
    (cond
        ((str-equals name "main") (seqn
            (vec-push new-name 'm')
            (vec-push new-name 'a')
            (vec-push new-name 'i')
            (vec-push new-name 'n')))
        (:else (seqn
            (vec-push new-name '_')
            (vec-push new-name '_')
            (vec-push new-name 'a')
            (vec-push new-name 'm')
            (vec-push new-name 'y')
            (vec-push new-name '_')
            (let i = 0)
            (while (< i name.len) (seqn
                (vec-push new-name (get name i))
                (set i = (+ i 1))))
            (vec-push new-name '_'))))
    (deref new-name)))

// 63-60 - alignment (2^n where n is the number encoded)
// 59    - signed
// 58-43 - number of fields
// 42-0  - width
(defun transform-type (type (* mut Type)) : SsaType (seq
    (cond
        ((== (deref type).type (TYPE_TYPE_INT)) (seq
            (let width = (deref type).type-var-width)
            (let alignment = (cond
                ((<= width  8) 0)
                ((<= width 16) 1)
                ((<= width 32) 2)
                ((<= width 64) 3)
                (:else 0))) // TODO: error handling
            (let signed = (cast (deref type).signed-mutable))
            (let field-count = 1)
            (inst SsaType
                (data (| (<< alignment 60) (| (<< signed 59) (| (<< field-count 43) width)))))))
        ((and (== (deref type).type (TYPE_TYPE_TUPLE)) (== (deref type).subtypes.len 0))
            (inst SsaType
                (data 0)))
        (:else (seq
            (eprint "todo: unsupported type type ")
            (eprint-int (deref type).type)
            (eprint " for lowering\n")
            (inst SsaType
                (data 0)))))))

(defun ssa-push-value
    (ssa (* mut Ssa))
    (type (* mut Type))
    : SsaValue
(seq
    (let func = (vec-get (ref (deref ssa).funcs) (deref ssa).current-func))
    (let value = (inst SsaValue
        (index (deref func).b.last-value)
        (type (transform-type type))))
    (set (deref func).b.last-value = (+ (deref func).b.last-value 1))
    value))

(defun ssa-push-block-param
    (ssa (* mut Ssa))
    (type (* mut Type))
    (block u64)
    : SsaValue
(seq
    (let func = (vec-get (ref (deref ssa).funcs) (deref ssa).current-func))
    (let block = (vec-get (ref (deref func).b.blocks) block))
    (let value = (ssa-push-value ssa type))
    (let block-params = (ref (deref block).parameters))
    (vec-push block-params value)
    (set (deref block).parameters = (deref block-params))
    value))

(defun ssa-push-instruction
    (ssa (* mut Ssa))
    (ret-type (* mut Type))
    (opcode u64)
    (metadata u64)
    (arguments (Vec SsaValue))
    : SsaValue
(seq
    (let func = (vec-get (ref (deref ssa).funcs) (deref ssa).current-func))
    (let block = (vec-get (ref (deref func).b.blocks) (deref ssa).current-block))
    (let insts = (ref (deref block).insts))
    (let value = (ssa-push-value ssa ret-type))
    (let instruction = (inst SsaInstruction
        (returned value)
        (opcode opcode)
        (metadata metadata)
        (arguments arguments)))
    (vec-push insts instruction)
    (set (deref block).insts = (deref insts))
    value))

(defun ssa-push-block
    (ssa (* mut Ssa))
    : u64
(seq
    (let func = (vec-get (ref (deref ssa).funcs) (deref ssa).current-func))
    (let blocks = (ref (deref func).b.blocks))
    (let last = (deref blocks).len)
    (vec-push blocks (inst SsaBasicBlock
        (parameters (new-vec (deref ssa).funcs.A))
        (insts (new-vec (deref ssa).funcs.A))))
    (set (deref func).b.blocks = (deref blocks))
    last))

(defun parse-ssa-int (str (@ mut u8)) : u64 (seq
    (let i = 0)
    (let n = 0)
    (while (< i str.len) (seqn
        (let c = (get str i))
        (cond
            ((and (<= '0' c) (<= c '9')) (seqn
                (set n = (+ (* n 10) (cast (- c '0'))))))
            (:else
                (break 0)))
        (set i = (+ i 1)))
    :else n)))

(defun push-var-map-to-basic-block
    (ssa (* mut Ssa))
    (block u64)
    (var-map (* mut (Vec (Vec (Pair (@ mut u8) (Pair u64 SsaType))))))
(seqn
    (let func = (vec-get (ref (deref ssa).funcs) (deref ssa).current-func))
    (let blocks = (ref (deref func).b.blocks))
    (let block = (vec-get blocks block))
    (let parameters = (ref (deref block).parameters))

    (let i = 0)
    (while (< i (deref var-map).len) (seqn
        (let scope = (vec-get var-map i))
        (let j = 0)
        (while (< j (deref scope).len) (seqn
            (let var = (vec-get scope j))
            (let type = (deref var).b.b)
            (let value = (inst SsaValue
                (index (deref func).b.last-value)
                (type type)))
            (set (deref func).b.last-value = (+ (deref func).b.last-value 1))
            (vec-push parameters value)
            (set j = (+ j 1))))
        (set i = (+ i 1))))

    (set (deref block).parameters = (deref parameters))))

(defun push-var-map-to-instr-args
    (arguments (* mut (Vec SsaValue)))
    (break-scope-count u64)
    (var-map (* mut (Vec (Vec (Pair (@ mut u8) (Pair u64 SsaType))))))
(seqn
    (cond
        ((not break-scope-count) (seqn
            (set break-scope-count = (deref var-map).len))))
    (let i = 0)
    (while (< i break-scope-count) (seqn
        (let scope = (vec-get var-map i))
        (let j = 0)
        (while (< j (deref scope).len) (seqn
            (let var = (vec-get scope j))
            (let index = (deref var).b.a)
            (let type = (deref var).b.b)
            (let value = (inst SsaValue
                (index index)
                (type type)))
            (vec-push arguments value)
            (set j = (+ j 1))))
        (set i = (+ i 1))))))

(defun load-var-map-from-block-params
    (ssa (* mut Ssa))
    (offset u64)
    (var-map (* mut (Vec (Vec (Pair (@ mut u8) (Pair u64 SsaType))))))
(seqn
    (let func = (vec-get (ref (deref ssa).funcs) (deref ssa).current-func))
    (let blocks = (ref (deref func).b.blocks))
    (let block = (vec-get blocks (deref ssa).current-block))
    (let parameters = (ref (deref block).parameters))
    (let i = 0)
    (while (< i (deref var-map).len) (seqn
        (let scope = (vec-get var-map i))
        (let j = 0)
        (while (< j (deref scope).len) (seqn
            (let var = (vec-get scope j))
            (let param = (vec-get parameters offset))
            (set (deref var).b.a = (deref param).index)
            (set j = (+ j 1))
            (set offset = (+ offset 1))))
        (set i = (+ i 1))))))

(defun ast-to-ssa-helper
    (ast (* mut Ast))
    (ssa (* mut Ssa))
    (break-block u64)
    (break-scope-count u64)
    (var-map (* mut (Vec (Vec (Pair (@ mut u8) (Pair u64 SsaType))))))
    : SsaValue
(cond
    ((== (deref ast).type (AST_NODE_TYPE_INT))
        (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT) (parse-ssa-int (deref ast).value) (new-vec (deref ast).children.A)))
    ((== (deref ast).type (AST_NODE_TYPE_CHAR)) (seq
        (let char = (cond
            ((str-equals (deref ast).value "'\\n'")
                '\n')
            ((str-equals (deref ast).value "'\\r'")
                '\r')
            ((str-equals (deref ast).value "'\\t'")
                '\t')
            ((str-equals (deref ast).value "'\\''")
                '\'')
            ((str-equals (deref ast).value "'\\\"'")
                '\"')
            (:else
                (get (deref ast).value 1))))
        (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT) (cast char) (new-vec (deref ast).children.A))))
    ((== (deref ast).type (AST_NODE_TYPE_BOOL))
        (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT) (cast (str-equals (deref ast).value "true")) (new-vec (deref ast).children.A)))
    ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (== (deref ast).children.len 0))
        (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT) 0 (new-vec (deref ast).children.A)))

    ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seq
        (let var = (deref ast).value)
        (let i = (deref var-map).len)
        (while (> i 0) (seqn
            (set i = (- i 1))
            (let scope = (vec-get var-map i))
            (cond
                ((: u64 (cast (let var = (vec-find scope matches-key var))))
                    (break (inst SsaValue
                        (index (deref var).b.a)
                        (type (deref var).b.b))))))
        :else (inst SsaValue
            (index 0)
            (type (inst SsaType
                (data 0)))))))

    ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seq
        (let func = (vec-get (ref (deref ast).children) 0))
        (cond
            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "seq")) (seq
                (vec-push var-map (new-vec (deref var-map).A))

                (let last = (inst SsaValue
                    (index 0)
                    (type (inst SsaType
                        (data 0)))))
                (let i = 1)
                (while (< i (deref ast).children.len) (seqn
                    (set last = (ast-to-ssa-helper (vec-get (ref (deref ast).children) i) ssa break-block break-scope-count var-map))
                    (set i = (+ i 1))))

                (vec-pop var-map)
                last))
            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "seqn")) (seq
                (vec-push var-map (new-vec (deref var-map).A))
                (let i = 1)
                (while (< i (deref ast).children.len) (seqn
                    (ast-to-ssa-helper (vec-get (ref (deref ast).children) i) ssa break-block break-scope-count var-map)
                    (set i = (+ i 1))))
                (vec-pop var-map)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT) 0 (new-vec (deref ast).children.A))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "cond")) (seq
                (let conds = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push conds (ssa-push-block ssa))
                (let thens = (ref (new-vec (deref ssa).funcs.A)))

                (let i = 1)
                (while (< i (deref ast).children.len) (seqn
                    (let pair = (vec-get (ref (deref ast).children) i))
                    (let condy = (vec-get (ref (deref pair).children) 0))
                    (cond
                        ((!= (deref condy).type (AST_NODE_TYPE_KEY)) (seqn
                            (let condy = (ssa-push-block ssa))
                            (push-var-map-to-basic-block ssa condy var-map)
                            (let then = (ssa-push-block ssa))
                            (vec-push conds condy)
                            (vec-push thens then))))
                    (set i = (+ i 1))))

                (let last-block = (ssa-push-block ssa))
                (let cond-value = (ssa-push-block-param ssa (ref (deref ast).typed) last-block))
                (push-var-map-to-basic-block ssa last-block var-map)

                (let i = 1)
                (let nil-type = (ref (empty-type (deref ssa).funcs.A)))
                (set (deref nil-type).type = (TYPE_TYPE_TUPLE))
                (while (< i (deref ast).children.len) (seqn
                    (let pair = (vec-get (ref (deref ast).children) i))
                    (let condy = (vec-get (ref (deref pair).children) 0))
                    (let then = (vec-get (ref (deref pair).children) 1))

                    (vec-push var-map (new-vec (deref var-map).A))
                    (cond
                        ((!= (deref condy).type (AST_NODE_TYPE_KEY)) (seqn
                            (let condy = (ast-to-ssa-helper condy ssa break-block break-scope-count var-map))
                            (let args = (ref (new-vec (deref ssa).funcs.A)))
                            (vec-push args condy)
                            (push-var-map-to-instr-args args (- (deref var-map).len 1) var-map)
                            (let next-cond-block = (deref (vec-get conds i)))
                            (ssa-push-instruction ssa nil-type (SSA_INSTRUCTION_OPCODE_BRANCH_FALSE) next-cond-block (deref args))
                            (let then-block = (deref (vec-get thens (- i 1))))
                            (push-var-map-to-basic-block ssa then-block var-map)
                            (let args = (ref (new-vec (deref args).A)))
                            (push-var-map-to-instr-args args 0 var-map)
                            (ssa-push-instruction ssa nil-type (SSA_INSTRUCTION_OPCODE_JUMP) then-block (deref args))

                            (set (deref ssa).current-block = then-block)
                            (load-var-map-from-block-params ssa 0 var-map)
                            (let then = (ast-to-ssa-helper then ssa break-block break-scope-count var-map))
                            (let args = (ref (new-vec (deref ssa).funcs.A)))
                            (vec-push args then)
                            (vec-pop var-map)
                            (push-var-map-to-instr-args args 0 var-map)
                            (ssa-push-instruction ssa nil-type (SSA_INSTRUCTION_OPCODE_JUMP) last-block (deref args))

                            (set (deref ssa).current-block = next-cond-block)
                            (load-var-map-from-block-params ssa 0 var-map)))
                        (:else (seqn
                            (let else = (ast-to-ssa-helper then ssa break-block break-scope-count var-map))
                            (let args = (ref (new-vec (deref ssa).funcs.A)))
                            (vec-push args else)
                            (push-var-map-to-instr-args args 0 var-map)
                            (ssa-push-instruction ssa nil-type (SSA_INSTRUCTION_OPCODE_JUMP) last-block (deref args))
                            (vec-pop var-map))))
                    (set i = (+ i 1))))

                (set (deref ssa).current-block = last-block)
                (load-var-map-from-block-params ssa 1 var-map)
                cond-value))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "loop")) (seq
                (set break-scope-count = (deref var-map).len)
                (vec-push var-map (new-vec (deref var-map).A))
                (let nil-type = (ref (empty-type (deref ssa).funcs.A)))
                (set (deref nil-type).type = (TYPE_TYPE_TUPLE))

                (let loop-block = (ssa-push-block ssa))
                (push-var-map-to-basic-block ssa loop-block var-map)

                (let last-block = (ssa-push-block ssa))
                (let loop-value = (ssa-push-block-param ssa (ref (deref ast).typed) last-block))
                (push-var-map-to-basic-block ssa last-block var-map)

                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (push-var-map-to-instr-args args 0 var-map)
                (ssa-push-instruction ssa nil-type (SSA_INSTRUCTION_OPCODE_JUMP) loop-block (deref args))

                (set (deref ssa).current-block = loop-block)
                (load-var-map-from-block-params ssa 0 var-map)
                (ast-to-ssa-helper (vec-get (ref (deref ast).children) 1) ssa last-block break-scope-count var-map)

                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (push-var-map-to-instr-args args 0 var-map)
                (ssa-push-instruction ssa nil-type (SSA_INSTRUCTION_OPCODE_JUMP) loop-block (deref args))

                (vec-pop var-map)

                (set (deref ssa).current-block = last-block)
                (load-var-map-from-block-params ssa 1 var-map)

                loop-value))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "break")) (seq
                (let v = (cond
                    ((== (deref ast).children.len 1)
                        (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT) 0 (new-vec (deref ssa).funcs.A)))
                    (:else
                        (ast-to-ssa-helper (vec-get (ref (deref ast).children) 1) ssa break-block break-scope-count var-map))))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args v)
                (push-var-map-to-instr-args args break-scope-count var-map)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_JUMP) break-block (deref args))
                (set (deref ssa).current-block = (ssa-push-block ssa))
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT) 0 (new-vec (deref ssa).funcs.A))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "*")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_MUL) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "/")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_DIV) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "%")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_MOD) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "+")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_ADD) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "-")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_SUB) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "<<")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_BSL) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value ">>")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_BSR) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "&")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_BAND) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "|")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_BOR) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "^")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_BXOR) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value ">")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_GT) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value ">=")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_GTE) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "<")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_LT) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "<=")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_LTE) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "==")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_EQ) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "!=")) (seq
                (let a = (vec-get (ref (deref ast).children) 1))
                (let b = (vec-get (ref (deref ast).children) 2))
                (let a = (ast-to-ssa-helper a ssa break-block break-scope-count var-map))
                (let b = (ast-to-ssa-helper b ssa break-block break-scope-count var-map))
                (let args = (ref (new-vec (deref ssa).funcs.A)))
                (vec-push args a)
                (vec-push args b)
                (ssa-push-instruction ssa (ref (deref ast).typed) (SSA_INSTRUCTION_OPCODE_INT_OPERATION) (SSA_OPERATION_METADATA_NE) (deref args))))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "let")) (seq
                (let body = (vec-get (ref (deref ast).children) (- (deref ast).children.len 1)))
                (let var = (deref (vec-get (ref (deref ast).children) 1)).value)
                (let value = (ast-to-ssa-helper body ssa break-block break-scope-count var-map))
                (let scope = (vec-get var-map (- (deref var-map).len 1)))
                (cond
                    ((: u64 (cast (let var = (vec-find scope matches-key var)))) (seqn
                        (set (deref var).b.a = value.index)
                        (set (deref var).b.b = value.type)))
                    (:else (seqn
                        (let var = (inst Pair
                            (a var)
                            (b (inst Pair
                                (a value.index)
                                (b value.type)))))
                        (vec-push scope var))))
                value))

            ((and (== (deref func).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func).value "set")) (seq
                (let body = (vec-get (ref (deref ast).children) (- (deref ast).children.len 1)))
                (let var = (deref (vec-get (ref (deref ast).children) 1)).value)
                (let value = (ast-to-ssa-helper body ssa break-block break-scope-count var-map))
                (let i = (deref var-map).len)
                (while (> i 0) (seqn
                    (set i = (- i 1))
                    (let scope = (vec-get var-map i))
                    (cond
                        ((: u64 (cast (let var = (vec-find scope matches-key var)))) (seqn
                            (set (deref var).b.a = value.index)
                            (break))))))
                value))

            (:else (seq
                (eprint "todo: unsupported ast for lowering S expression to ssa: ")
                (eprint (deref func).value)
                (eprint "\n")
                (exit 1)
                (inst SsaValue
                    (index 0)
                    (type (inst SsaType
                        (data 0)))))))))

    (:else (seq
        (eprint "todo: unsupported ast node ")
        (eprint-int (deref ast).type)
        (eprint " for lowering to ssa\n")
        (exit 1)
        (inst SsaValue
            (index 0)
            (type (inst SsaType
                (data 0))))))))

(defun ast-to-ssa (ast (* mut Ast)) (struct-map (* mut (Vec (Pair (@ mut u8) Struct)))) : Ssa (seq
    (let ssa = (ref (inst Ssa
        (funcs (new-vec (deref ast).children.A))
        (raw-data (new-vec (deref ast).children.A))
        (current-func 0)
        (current-block 0))))
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (cond
            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defun")) (seqn
                (let name = (deref (vec-get (ref (deref ast).children) 1)).value)
                (let name = (ref (mangle-func-name (deref struct-map).A name (ref (deref ast).typed))))
                (let name-slice = (vec-slice name))

                (let i = 0)
                (while (< i (deref ssa).funcs.len) (seqn
                    (let found-name = (ref (deref (vec-get (ref (deref ssa).funcs) i)).a))
                    (let found-name-slice = (vec-slice found-name))
                    (cond
                        ((str-equals found-name-slice name-slice)
                            (break)))
                    (set i = (+ i 1))))

                (cond
                    ((>= i (deref ssa).funcs.len) (seqn
                        (let funcs = (ref (deref ssa).funcs))
                        (vec-push funcs (inst Pair
                            (a (deref name))
                            (b (inst SsaFunction
                                (linkage 0)
                                (last-value 0)
                                (blocks (new-vec (deref struct-map).A))))))
                        (set (deref ssa).funcs = (deref funcs)))))
                (set (deref ssa).current-func = i)
                (ssa-push-block ssa)
                (set (deref ssa).current-block = 0)

                // TODO: arguments

                (let body = (vec-get (ref (deref ast).children) (- (deref ast).children.len 1)))
                (let var-map = (ref (new-vec (deref ast).children.A)))
                (vec-push var-map (new-vec (deref var-map).A))
                (let ret-value = (ast-to-ssa-helper body ssa 0 0 var-map))
                (let ret-args = (ref (new-vec (deref ssa).funcs.A)))
                (let nil-type = (ref (empty-type (deref ssa).funcs.A)))
                (set (deref nil-type).type = (TYPE_TYPE_TUPLE))
                (vec-push ret-args ret-value)
                (ssa-push-instruction ssa nil-type (SSA_INSTRUCTION_OPCODE_RETURN) 0 (deref ret-args)))))
        (set i = (+ i 1))))
    (deref ssa)))

(defun print-ssa-value (value (* mut SsaValue)) (seqn
    (print "%")
    (print-int (deref value).index)
    (print ":")
    (cond
        ((ssa-type-signed (deref value).type)
            (print "i"))
        (:else
            (print "u")))
    (print-int (ssa-type-width (deref value).type))
    (print "f")
    (print-int (ssa-type-field-count (deref value).type))
    (print "@2^")
    (print-int (ssa-type-alignment (deref value).type))))

(defun print-ssa-instruction (instruction (* mut SsaInstruction)) (seqn
    (print "    ")
    (print-ssa-value (ref (deref instruction).returned))
    (print " = ")
    (cond
        ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT)) (seqn
            (print "int ")
            (print-int (deref instruction).metadata)))

        ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_RETURN))
            (print "return"))

        ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_JUMP)) (seqn
            (print "jump b")
            (print-int (deref instruction).metadata)))

        ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_BRANCH_FALSE)) (seqn
            (print "branch-false b")
            (print-int (deref instruction).metadata)))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_MUL)))
            (print "imul"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_DIV)))
            (print "idiv"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_MOD)))
            (print "mod"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_ADD)))
            (print "iadd"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_SUB)))
            (print "isub"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_BSL)))
            (print "bsl"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_BSR)))
            (print "bsr"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_BAND)))
            (print "band"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_BOR)))
            (print "bor"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_BXOR)))
            (print "bxor"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_GT)))
            (print "igt"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_GTE)))
            (print "igte"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_LT)))
            (print "ilt"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_LTE)))
            (print "ilte"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_EQ)))
            (print "ieq"))

        ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_NE)))
            (print "ineq"))

        (:else (seqn
            (print "UNKNOWN ")
            (print-int (deref instruction).metadata))))
    (let i = 0)
    (while (< i (deref instruction).arguments.len) (seqn
        (print " ")
        (let value = (vec-get (ref (deref instruction).arguments) i))
        (print-ssa-value value)
        (set i = (+ i 1))))
    (print "\n")))

(defun print-ssa (ssa (* mut Ssa)) (seqn
    (let i = 0)
    (while (< i (deref ssa).funcs.len) (seqn
        (let func = (vec-get (ref (deref ssa).funcs) i))
        (print (vec-slice (ref (deref func).a)))
        (print ":\n")
        (let j = 0)
        (while (< j (deref func).b.blocks.len) (seqn
            (print "  ")
            (print-int j)
            (print ":")
            (let block = (vec-get (ref (deref func).b.blocks) j))
            (let k = 0)
            (while (< k (deref block).parameters.len) (seqn
                (print " ")
                (print-ssa-value (vec-get (ref (deref block).parameters) k))
                (set k = (+ k 1))))
            (print "\n")
            (let k = 0)
            (while (< k (deref block).insts.len) (seqn
                (print " ")
                (let instruction = (vec-get (ref (deref block).insts) k))
                (print-ssa-instruction instruction)
                (set k = (+ k 1))))
            (print "\n")
            (set j = (+ j 1))))
        (print "\n")
        (set i = (+ i 1))))))



//
// ==================================================================================================
// REGISTER ALLOCATION
// ==================================================================================================
//

(defstruct RegAllocGraphNode
    (ssa-index u64)
    (edge-count u64)
    (register u64)
    (on-stack u1)
    (first-usage u64)
    (last-usage u64)
    (usage-count u64)
    (temporary-edge-count u64)
    (temporarily-removed u1))

(defstruct RegAllocGraph
    (nodes (Vec RegAllocGraphNode))
    (edges (Vec (Pair u64 u64))))

(defun create-reg-alloc-graph-from-ssa
    (ssa (* mut Ssa))
    : RegAllocGraph
(seq
    (let func = (ref (deref (vec-get (ref (deref ssa).funcs) 0)).b)) // TODO: per function
    (let nodes = (ref (new-vec (deref func).blocks.A)))
    (let edges = (ref (new-vec (deref func).blocks.A)))
    (let i = 0)
    (while (< i (deref func).last-value) (seqn
        (vec-push nodes (inst RegAllocGraphNode
            (ssa-index i)
            (edge-count 0)
            (register (- 0 1))
            (on-stack false)
            (first-usage 0)
            (last-usage 0)
            (usage-count 0)
            (temporary-edge-count 0)
            (temporarily-removed false)))
        (set i = (+ i 1))))

    (let i = 0)
    (let index-counter = 0)
    (while (< i (deref func).blocks.len) (seqn
        (let block = (vec-get (ref (deref func).blocks) i))
        (let j = 0)
        (while (< j (deref block).insts.len) (seqn
            (let instr = (vec-get (ref (deref block).insts) j))
            (let node = (vec-get nodes (deref instr).returned.index))
            (set (deref node).first-usage = index-counter)
            (cond
                ((== (deref node).last-usage 0) (seqn
                    (set (deref node).last-usage = index-counter))))

            (let k = 0)
            (while (< k (deref instr).arguments.len) (seqn
                (cond
                    ((or (== (deref instr).opcode (SSA_INSTRUCTION_OPCODE_JUMP)) (and (>= k 1) (== (deref instr).opcode (SSA_INSTRUCTION_OPCODE_BRANCH_FALSE))))
                        (break)))
                (let arg = (vec-get (ref (deref instr).arguments) k))
                (let index = (deref arg).index)
                (let node = (vec-get nodes index))
                (while (!= (deref node).ssa-index index) (seqn
                    (set index = (deref node).ssa-index)
                    (set node = (vec-get nodes index))))
                (set (deref node).last-usage = index-counter)
                (set k = (+ k 1))))
            (let block = (deref instr).metadata)
            (let block = (vec-get (ref (deref func).blocks) block))
            (let l = 0)
            (while (< k (deref instr).arguments.len) (seqn
                (let arg = (vec-get (ref (deref instr).arguments) k))
                (let block-param = (vec-get (ref (deref block).parameters) l))
                (let node = (vec-get nodes (deref block-param).index))
                (set (deref node).ssa-index = (deref arg).index)
                (set l = (+ l 1))
                (set k = (+ k 1))))

            (set index-counter = (+ index-counter 1))
            (set j = (+ j 1))))
        (set i = (+ i 1))))

    (let i = 0)
    (while (< i (deref func).blocks.len) (seqn
        (let block = (vec-get (ref (deref func).blocks) i))
        (let j = 0)
        (while (< j (deref block).insts.len) (seqn
            (let instr = (vec-get (ref (deref block).insts) j))
            (let k = 0)
            (while (< k (deref instr).arguments.len) (seqn
                (let arg = (vec-get (ref (deref instr).arguments) k))
                (let index = (deref arg).index)
                (let node = (vec-get nodes index))
                (while (!= (deref node).ssa-index index) (seqn
                    (set index = (deref node).ssa-index)
                    (set node = (vec-get nodes index))))
                (set (deref node).usage-count = (+ (deref node).usage-count 1))
                (set k = (+ k 1))))
            (set j = (+ j 1))))
        (set i = (+ i 1))))

    (let i = 0)
    (while (< i (deref nodes).len) (seqn
        (let index = i)
        (let n1 = (vec-get nodes index))
        (while (!= (deref n1).ssa-index index) (seqn
            (set index = (deref n1).ssa-index)
            (set n1 = (vec-get nodes index))))
        (cond
            ((!= (deref n1).first-usage (deref n1).last-usage) (seqn
                (let j = (+ i 1))
                (while (< j (deref nodes).len) (seqn
                    (let index = j)
                    (let n2 = (vec-get nodes index))
                    (while (!= (deref n2).ssa-index index) (seqn
                        (set index = (deref n2).ssa-index)
                        (set n2 = (vec-get nodes index))))
                    (cond
                        ((== (deref n1).ssa-index (deref n2).ssa-index)
                            ())
                        ((or (and (== (deref n1).first-usage (deref n2).last-usage) (> (deref n1).last-usage (deref n2).first-usage)) (and (== (deref n1).last-usage (deref n2).first-usage) (< (deref n1).first-usage (deref n2).last-usage)))
                            ())
                        ((== (deref n2).first-usage (deref n2).last-usage)
                            ())
                        ((and (<= (deref n1).first-usage (deref n2).last-usage) (>= (deref n1).last-usage (deref n2).first-usage)) (seqn
                            (let edge = (inst Pair
                                (a (deref n1).ssa-index)
                                (b (deref n2).ssa-index)))
                            (cond
                                ((not (: u64 (cast (vec-find edges matches-edge edge)))) (seqn
                                    (set (deref n1).edge-count = (+ (deref n1).edge-count 1))
                                    (set (deref n2).edge-count = (+ (deref n2).edge-count 1))
                                    (vec-push edges edge)))))))
                    (set j = (+ j 1)))))))
        (set i = (+ i 1))))

    (inst RegAllocGraph
        (edges (deref edges))
        (nodes (deref nodes)))))

(defun matches-edge
    (edge-1 (* mut (Pair u64 u64)))
    (edge-2 (Pair u64 u64))
    : u1
(seq
    (let edge-1 = (deref edge-1))
    (or (and (== edge-1.a edge-2.a) (== edge-1.b edge-2.b)) (and (== edge-1.a edge-2.b) (== edge-1.b edge-2.a)))))

(defun print-reg-alloc-graph
    (graph (* mut RegAllocGraph))
(seqn
    (let i = 0)
    (while (< i (deref graph).nodes.len) (seqn
        (let node = (vec-get (ref (deref graph).nodes) i))
        (print-int (deref node).ssa-index)
        (print " (")
        (print-int (deref node).usage-count)
        (print "; ")
        (print-int (deref node).first-usage)
        (print " - ")
        (print-int (deref node).last-usage)
        (print ")")
        (print ": ")
        (cond
            ((deref node).on-stack
                (print "STACK="))
            (:else
                (print "REG=")))
        (print-int (deref node).register)
        (print "\n")
        (set i = (+ i 1))))
    (print "\n")
    (let i = 0)
    (print "graph {\n")
    (while (< i (deref graph).edges.len) (seqn
        (let edge = (vec-get (ref (deref graph).edges) i))
        (print "    \"")
        (print-int (deref edge).a)
        (let node = (vec-get (ref (deref graph).nodes) (deref edge).a))
        (print ": ")
        (cond
            ((deref node).on-stack
                (print "STACK="))
            (:else
                (print "REG=")))
        (print-int (deref node).register)
        (print "\" -- \"")
        (print-int (deref edge).b)
        (let node = (vec-get (ref (deref graph).nodes) (deref edge).b))
        (print ": ")
        (cond
            ((deref node).on-stack
                (print "STACK="))
            (:else
                (print "REG=")))
        (print-int (deref node).register)
        (print "\"\n")
        (set i = (+ i 1))))
    (print "}\n")))

(defun reg-alloc
    (graph (* mut RegAllocGraph))
    (reg-count u64)
(seqn
    (let i = 0)
    (while (< i (deref graph).nodes.len) (seqn
        (let node = (vec-get (ref (deref graph).nodes) i))
        (set (deref node).temporary-edge-count = (deref node).edge-count)
        (set i = (+ i 1))))
    (let stack = (ref (new-vec (deref graph).nodes.A)))
    (let i = 0)
    (while (< i (deref graph).nodes.len) (seqn
        (let j = 0)
        (let usage-count = (- 0 1))
        (let index = (- 0 1))
        (while (< j (deref graph).nodes.len) (seqn
            (let node = (vec-get (ref (deref graph).nodes) j))
            (let fewer-neighbours = (< (deref node).temporary-edge-count reg-count))
            (cond
                ((and (not (deref node).temporarily-removed) (or fewer-neighbours (< (deref node).usage-count usage-count))) (seqn
                    (set index = j)
                    (set usage-count = (deref node).usage-count)
                    (cond
                        (fewer-neighbours
                            (break))))))
            (set j = (+ j 1))))
        (let node = (vec-get (ref (deref graph).nodes) index))
        (set (deref node).temporarily-removed = true)
        (vec-push stack index)
        (let j = 0)
        (while (< j (deref graph).edges.len) (seqn
            (let edge = (vec-get (ref (deref graph).edges) j))
            (cond
                ((== (deref edge).a index) (seqn
                    (let node = (vec-get (ref (deref graph).nodes) (deref edge).b))
                    (set (deref node).temporary-edge-count = (- (deref node).temporary-edge-count 1))))
                ((== (deref edge).b index) (seqn
                    (let node = (vec-get (ref (deref graph).nodes) (deref edge).a))
                    (set (deref node).temporary-edge-count = (- (deref node).temporary-edge-count 1)))))
            (set j = (+ j 1))))
        (set i = (+ i 1))))
        (let temp-vec = (ref (new-vec (deref graph).nodes.A)))
        (while (deref stack).len (seqn
            (let index = (deref (vec-get stack (- (deref stack).len 1))))
            (vec-pop stack)
            (let node = (vec-get (ref (deref graph).nodes) index))
            (set (deref node).temporarily-removed = false)
            (set (deref temp-vec).len = 0)
            (let i = 0)
            (while (< i (deref graph).edges.len) (seqn
                (let edge = (vec-get (ref (deref graph).edges) i))
                (cond
                    ((== (deref edge).a index) (seqn
                        (let n = (vec-get (ref (deref graph).nodes) (deref edge).b))
                        (let register = (deref n).register)
                        (cond
                            ((and (not (deref n).on-stack) (not (: u64 (cast (vec-find temp-vec matches-register register)))))
                                (vec-push temp-vec register)))))
                    ((== (deref edge).b index) (seqn
                        (let n = (vec-get (ref (deref graph).nodes) (deref edge).a))
                        (let register = (deref n).register)
                        (cond
                            ((and (not (deref n).on-stack) (not (: u64 (cast (vec-find temp-vec matches-register register)))))
                                (vec-push temp-vec register))))))
                (set i = (+ i 1))))
            (let i = 0)
            (while (< i reg-count) (seqn
                (cond
                    ((not (: u64 (cast (vec-find temp-vec matches-register i)))) (seqn
                        (set (deref node).register = i)
                        (break))))
                (set i = (+ i 1)))
            :else (seqn
                (set (deref node).on-stack = true)
                (set (deref temp-vec).len = 0)
                (let i = 0)
                (while (< i (deref graph).edges.len) (seqn
                    (let edge = (vec-get (ref (deref graph).edges) i))
                    (cond
                        ((== (deref edge).a index) (seqn
                            (let n = (vec-get (ref (deref graph).nodes) (deref edge).b))
                            (let register = (deref n).register)
                            (cond
                                ((and (deref n).on-stack (not (: u64 (cast (vec-find temp-vec matches-register register)))))
                                    (vec-push temp-vec register)))))
                        ((== (deref edge).b index) (seqn
                            (let n = (vec-get (ref (deref graph).nodes) (deref edge).a))
                            (let register = (deref n).register)
                            (cond
                                ((and (deref n).on-stack (not (: u64 (cast (vec-find temp-vec matches-register register)))))
                                    (vec-push temp-vec register))))))
                    (set i = (+ i 1))))
                (let i = 1)
                (while (!= i 0) (seqn
                    (cond
                        ((not (: u64 (cast (vec-find temp-vec matches-register i)))) (seqn
                            (set (deref node).register = i)
                            (break))))
                    (set i = (+ i 1))))))))
    (let i = 0)
    (while (< i (deref graph).nodes.len) (seqn
        (let index = i)
        (let node = (vec-get (ref (deref graph).nodes) index))
        (while (!= (deref node).ssa-index index) (seqn
            (set index = (deref node).ssa-index)
            (set node = (vec-get (ref (deref graph).nodes) index))))
        (let source = (vec-get (ref (deref graph).nodes) i))
        (set (deref source).register = (deref node).register)
        (set (deref source).on-stack = (deref node).on-stack)
        (set i = (+ i 1))))))

(defun matches-register (reg (* mut u64)) (reg-2 u64) : u1
    (== (deref reg) reg-2))



//
// ==================================================================================================
// CODE GENERATION
// ==================================================================================================
//

(defun register-x86
    (file File)
    (on-stack u1)
    (reg-index u64)
(cond
    (on-stack (seqn
        (file-write file "qword [rsp - ")
        (file-write-int file (* reg-index 8))
        (file-write file "]")))
    (:else (cond
        ((== reg-index 0)
            (file-write file "rax"))
        ((== reg-index 1)
            (file-write file "rbx"))
        ((== reg-index 2)
            (file-write file "rcx"))
        ((== reg-index 3)
            (file-write file "rdx"))
        (:else
            (file-write file "UNKNOWN"))))))

(defmacro X86_TEMPORARY_REGISTER "rsi")

(defun emit-assembly-x64
    (ssa (* mut Ssa))
    (filename (@ mut u8))
    (graph (* mut RegAllocGraph))
(seqn
    (let file = (file-open filename (| (FILE_OPEN_FLAG_WRITE_ONLY) (| (FILE_OPEN_FLAG_CREATE) (FILE_OPEN_FLAG_TRUNCATE)))))
    (let i = 0)
    (while (< i (deref ssa).funcs.len) (seqn
        (let func = (vec-get (ref (deref ssa).funcs) i))
        (file-write file "global ")
        (file-write file (vec-slice (ref (deref func).a)))
        (file-write file "\n")
        (file-write file (vec-slice (ref (deref func).a)))
        (file-write file ":\n    push rbp\n    mov rbp, rsp\n")
        (let j = 0)
        (while (< j (deref func).b.blocks.len) (seqn
            (let block = (vec-get (ref (deref func).b.blocks) j))
            (file-write file "\n.L")
            (file-write-int file j)
            (file-write file ":\n")
            (let k = 0)
            (while (< k (deref block).insts.len) (seqn
                (let instruction = (vec-get (ref (deref block).insts) k))
                (cond
                    ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT)) (seqn
                        (let node = (vec-get (ref (deref graph).nodes) (deref instruction).returned.index))
                        (cond
                            ((!= (deref node).first-usage (deref node).last-usage) (seqn
                                (let register = (deref node).register)
                                (file-write file "    mov ")
                                (register-x86 file (deref node).on-stack register)
                                (file-write file ", ")
                                (file-write-int file (deref instruction).metadata)
                                (file-write file "\n"))))))
                    ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_RETURN)) (seqn
                        (file-write file "    mov rax, ")
                        (let arg = (vec-get (ref (deref instruction).arguments) 0))
                        (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                        (let register = (deref node).register)
                        (register-x86 file (deref node).on-stack register)
                        (file-write file "\n    mov rsp, rbp\n    pop rbp\n    ret\n")))
                    ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_BRANCH_FALSE)) (seqn
                        (file-write file "    test ")
                        (let arg = (vec-get (ref (deref instruction).arguments) 0))
                        (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                        (let register = (deref node).register)
                        (register-x86 file (deref node).on-stack register)
                        (file-write file ", ")
                        (register-x86 file (deref node).on-stack register)
                        (file-write file "\n    jz .L")
                        (file-write-int file (deref instruction).metadata)
                        (file-write file "\n")))
                    ((== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_JUMP)) (seqn
                        (let block = (deref instruction).metadata)
                        (let block = (vec-get (ref (deref func).b.blocks) block))
                        (file-write file "    jmp .L")
                        (file-write-int file (deref instruction).metadata)
                        (file-write file "\n")))
                    ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_MUL))) (seqn
                        (let node = (vec-get (ref (deref graph).nodes) (deref instruction).returned.index))
                        (cond
                            ((!= (deref node).first-usage (deref node).last-usage) (seqn
                                (let dest-reg = (deref node).register)
                                (let dest-on-stack = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 0))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-1 = (deref node).register)
                                (let source-on-stack-1 = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 1))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-2 = (deref node).register)
                                (let source-on-stack-2 = (deref node).on-stack)

                                (cond
                                    ((== dest-reg source-reg-1) (seqn
                                        (file-write file "    imul ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-2 source-reg-2)))
                                    ((== dest-reg source-reg-2) (seqn
                                        (file-write file "    imul ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)))
                                    (:else (seqn
                                        (file-write file "    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    imul ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-2 source-reg-2))))
                                (file-write file "\n"))))))
                    ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_ADD))) (seqn
                        (let node = (vec-get (ref (deref graph).nodes) (deref instruction).returned.index))
                        (cond
                            ((!= (deref node).first-usage (deref node).last-usage) (seqn
                                (let dest-reg = (deref node).register)
                                (let dest-on-stack = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 0))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-1 = (deref node).register)
                                (let source-on-stack-1 = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 1))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-2 = (deref node).register)
                                (let source-on-stack-2 = (deref node).on-stack)

                                (cond
                                    ((== dest-reg source-reg-1) (seqn
                                        (file-write file "    add ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-2 source-reg-2)))
                                    ((== dest-reg source-reg-2) (seqn
                                        (file-write file "    add ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)))
                                    (:else (seqn
                                        (file-write file "    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    add ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-2 source-reg-2))))
                                (file-write file "\n"))))))
                    ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_SUB))) (seqn
                        (let node = (vec-get (ref (deref graph).nodes) (deref instruction).returned.index))
                        (cond
                            ((!= (deref node).first-usage (deref node).last-usage) (seqn
                                (let dest-reg = (deref node).register)
                                (let dest-on-stack = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 0))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-1 = (deref node).register)
                                (let source-on-stack-1 = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 1))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-2 = (deref node).register)
                                (let source-on-stack-2 = (deref node).on-stack)

                                (cond
                                    ((== dest-reg source-reg-1) (seqn
                                        (file-write file "    sub ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-2 source-reg-2)))
                                    ((== dest-reg source-reg-2) (seqn
                                        (file-write file "    mov ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    sub ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (file-write file (X86_TEMPORARY_REGISTER))))
                                    (:else (seqn
                                        (file-write file "    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    sub ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-2 source-reg-2))))
                                (file-write file "\n"))))))

                    ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_BSL))) (seqn
                        (let node = (vec-get (ref (deref graph).nodes) (deref instruction).returned.index))
                        (cond
                            ((!= (deref node).first-usage (deref node).last-usage) (seqn
                                (let dest-reg = (deref node).register)
                                (let dest-on-stack = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 0))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-1 = (deref node).register)
                                (let source-on-stack-1 = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 1))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-2 = (deref node).register)
                                (let source-on-stack-2 = (deref node).on-stack)

                                // shl/shr need to use cl for some reason
                                (cond
                                    ((== dest-reg source-reg-1) (seqn
                                        (file-write file "    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    shl ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", cl\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)))
                                    ((== dest-reg source-reg-2) (seqn
                                        (file-write file "    mov ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    shl ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", cl\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (file-write file (X86_TEMPORARY_REGISTER))))
                                    (:else (seqn
                                        (file-write file "    mov ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    shl ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", cl\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (file-write file (X86_TEMPORARY_REGISTER)))))
                                (file-write file "\n"))))))
                    ((and (== (deref instruction).opcode (SSA_INSTRUCTION_OPCODE_INT_OPERATION)) (== (deref instruction).metadata (SSA_OPERATION_METADATA_BSR))) (seqn
                        (let node = (vec-get (ref (deref graph).nodes) (deref instruction).returned.index))
                        (cond
                            ((!= (deref node).first-usage (deref node).last-usage) (seqn
                                (let dest-reg = (deref node).register)
                                (let dest-on-stack = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 0))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-1 = (deref node).register)
                                (let source-on-stack-1 = (deref node).on-stack)
                                (let arg = (vec-get (ref (deref instruction).arguments) 1))
                                (let node = (vec-get (ref (deref graph).nodes) (deref arg).index))
                                (let source-reg-2 = (deref node).register)
                                (let source-on-stack-2 = (deref node).on-stack)

                                // shl/shr need to use cl for some reason
                                (cond
                                    ((== dest-reg source-reg-1) (seqn
                                        (file-write file "    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    shr ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", cl\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)))
                                    ((== dest-reg source-reg-2) (seqn
                                        (file-write file "    mov ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    shr ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", cl\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (file-write file (X86_TEMPORARY_REGISTER))))
                                    (:else (seqn
                                        (file-write file "    mov ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", ")
                                        (register-x86 file source-on-stack-1 source-reg-1)
                                        (file-write file "\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    shr ")
                                        (file-write file (X86_TEMPORARY_REGISTER))
                                        (file-write file ", cl\n    xchg rcx, ")
                                        (register-x86 file source-on-stack-2 source-reg-2)
                                        (file-write file "\n    mov ")
                                        (register-x86 file dest-on-stack dest-reg)
                                        (file-write file ", ")
                                        (file-write file (X86_TEMPORARY_REGISTER)))))
                                (file-write file "\n"))))))

                    (:else (seqn
                        (file-write file "    ; unknown ssa instruction ")
                        (file-write-int file (deref instruction).opcode)
                        (file-write file ":")
                        (file-write-int file (deref instruction).metadata)
                        (file-write file "\n"))))
                (set k = (+ k 1))))
            (set j = (+ j 1))))
        (set i = (+ i 1))))
    (file-close file)))



//
// ==================================================================================================
// MAIN
// ==================================================================================================
//

(defun main (argv (* mut (* mut u8))) (argc u64)
    (seqn
        (let filename = (get-argv argv 1))
        (cond
            ((== filename.ptr (null)) (seqn
                (eprint "please provide a file to compile\n")
                (exit 1))))
        (let file = (file-open filename (FILE_OPEN_FLAG_READ_ONLY)))
        (cond
            ((not (file-is-valid file)) (seqn
                (eprint "error: failed to open file ")
                (eprint filename)
                (eprint "\n")
                (exit 1))))
        (let A = (ref (new-alloc)))
        (let contents = (file-read-all file A))
        (let contents-ref = (vec-slice (ref contents)))
        (file-close file)
        (let lexer = (ref (new-lexer A contents-ref)))
        (let result = (parse lexer))
        (cond (result.success (seq
            (let ast = (ref result.ast))
            (let macros = (ref (new-vec A)))
            (extract-macros macros ast)
            (replace-macros macros ast)
            (let func-map = (ref (create-default-signatures A)))
            (let struct-map = (ref (new-vec A)))
            (let errors = (ref (new-vec A)))
            (extract-structs ast struct-map errors)
            (print-type-errors contents-ref errors)
            (extract-functions ast func-map errors)
            (print-type-errors contents-ref errors)
            (check ast errors func-map struct-map)
            (print-type-errors contents-ref errors)
            (let ssa = (ref (ast-to-ssa ast struct-map)))
            (print-ssa ssa)
            (let graph = (ref (create-reg-alloc-graph-from-ssa ssa)))
            (reg-alloc graph 4)
            (print-reg-alloc-graph graph)
            (emit-assembly-x64 ssa "a.s" graph)
            (ast-drop ast)
            (vec-drop macros empty-dealloc)))
        (:else (seqn
            (print-parse-error contents-ref (ref result.fail))
            (exit 1))))
        (lexer-drop lexer)
        (vec-drop (ref contents) empty-dealloc)))

