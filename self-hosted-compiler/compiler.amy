//
// ==================================================================================================
// STANDARD LIBRARY STUFFS
// ==================================================================================================
//

(defext syscall
    (call u64)
    (a u64)
    (b u64)
    (c u64)
    (d u64)
    (e u64)
    (f u64)
    : u64
    "syscall_")

// Loops while a condition is true.
(defmacro
    while condy
        stat
    &key else
    (loop
        (cond
            (condy stat)
            (:else (break else)))))

// Performs a short circuiting logical and.
(defmacro
    and x y
    (cond
        (x y)
        (:else 0)))

// Performs a short circuiting logical or.
(defmacro
    or x y
    (cond
        (x 1)
        (:else y)))

// Performs a logical not
(defmacro
    not x
    (cond
        (x 0)
        (:else 1)))

// Prints out a string onto stdout.
(defun print (str (@ u8))
    (seqn
        (syscall 1 1 (cast str.ptr) str.len 0 0 0)))

// Helper function for printing out an integer
(defun print-int-helper (i u64) (printer (fn ((@ u8))))
    (cond
        ((== i 0) (printer "0"))
        (:else (seqn
            (let p = (alloca 20))
            (let start = 19)
            (while (!= i 0) (seqn
                (let c = (+ '0' (cast (% i 10))))
                (set start = (- start 1))
                (set (get p start) = c)
                (set i = (/ i 10))))
            (printer (subslice p start (- p.len 1)))))))

// Prints out a number onto stdout.
(defun print-int (i u64)
    (print-int-helper i print))

// Prints out a number onto stderr.
(defun eprint-int (i u64)
    (print-int-helper i eprint))

// Prints out a string onto stderr.
(defun eprint (str (@ u8))
    (seqn
        (syscall 1 2 (cast str.ptr) str.len 0 0 0)))

// Exits the program
(defun exit (code i32)
    (seqn
        (syscall 60 (cast code) 0 0 0 0 0)))

// Creates a subslice from a given slice and range.
(defun subslice (s (@ 'a)) (start u64) (end u64) : (@ 'a)
    (slice (- end start) (ptr-add s.ptr start)))

// Defines a file (wrapper around a file descriptor).
(defstruct File
    (descriptor i32))

(defun file-is-valid (file File) : u1
    (> file.descriptor 0))

(defmacro FILE_OPEN_FLAG_READ_ONLY   0)
(defmacro FILE_OPEN_FLAG_WRITE_ONLY  1)
(defmacro FILE_OPEN_FLAG_CREATE     64)
(defmacro FILE_OPEN_FLAG_TRUNCATE  512)

// Opens a file.
(defun file-open (path (@ u8)) (flags u64) : File
    (seq
        (let null-term = (alloca (+ path.len 1)))
        (let i = 0)
        (while (< i path.len)
            (seqn
                (set (get null-term i) = (get path i))
                (set i = (+ i 1))))
        (set (get null-term i) = '\0')
        (inst File
            (descriptor
                (cast (syscall 2 (cast null-term.ptr) flags 438 0 0 0))))))

// Reads a file into a vec of u8s.
(defun file-read-all (file File) (A (* Allocator)) : (Vec u8) (seq
    (let vec = (ref (new-vec A)))
    (let slice = (alloca 64))
    (while (let len = (syscall 0 (cast file.descriptor) (cast slice.ptr) slice.len 0 0 0)) (seqn
        (let i = 0)
        (while (< i len) (seqn
            (vec-push vec (get slice i))
            (set i = (+ i 1))))))
    (deref vec)))

(defun file-write (file File) (str (@ u8)) (seqn
    (syscall 1 (cast file.descriptor) (cast str.ptr) (cast str.len) 0 0 0)))

(defun file-write-int (file File) (i u64)
    (cond
        ((== i 0) (file-write file "0"))
        (:else (seqn
            (let p = (alloca 20))
            (let start = 19)
            (while (!= i 0) (seqn
                (let c = (+ '0' (cast (% i 10))))
                (set start = (- start 1))
                (set (get p start) = c)
                (set i = (/ i 10))))
            (file-write file (subslice p start (- p.len 1)))))))

// Closes a previously opened file.
(defun file-close (file File)
    (seqn
        (syscall 3 (cast file.descriptor) 0 0 0 0 0)))

// Maps memory for the program.
(defun mmap (len u64) : (* 'a)
    (cast (syscall 9 0 len 3 34 (- 0 1) 0)))

// Unmaps memory previously mapped by mmap.
(defun munmap (addr (* 'a)) (len u64)
    (seqn
        (syscall 11 (cast addr) len 0 0 0 0)))

// Creates a null constant.
(defun null : (* 'a)
    (cast (: u64 0)))

// Defines a free bucket linked list node for the memory allocator.
(defstruct FreeBucket
    (next (* FreeBucket)))

// Defines an allocator.
(defstruct Allocator
    (free16    (* FreeBucket))
    (free64    (* FreeBucket))
    (free256   (* FreeBucket))
    (free1024  (* FreeBucket))
    (free4096  (* FreeBucket))
    (free16384 (* FreeBucket))
    (free65536 (* FreeBucket)))

// Helper function for allocation to create size buckets.
(defun create-buckets (bucket-size u64) : (* FreeBucket)
    (seq
        (let p = (: (* u8) (mmap 65536)))
        (let i = (- bucket-size (sizeof FreeBucket)))
        (let q = (cast (ptr-add p i)))
        (while (< i 65536) (seqn
            (let q = (: (* FreeBucket) (cast (ptr-add p i))))
            (set i = (+ i bucket-size))
            (cond
                ((< i 65536) (seqn
                    (set (deref q).next = (cast (ptr-add p i)))))
                (:else (seqn
                    (set (deref q).next = (null)))))))
        q))

// Helper function for allocation.
(defun alloc-helper (A (* Allocator)) (size u64) : (* 'a)
    (cond
        ((== size 0) (null))
        ((<= size 8) (seq
            (cond
                ((== (deref A).free16 (null)) (seqn
                    (set (deref A).free16 = (create-buckets 16)))))
            (let ptr = (deref A).free16)
            (set (deref A).free16 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 8))))

        ((<= size 56) (seq
            (cond
                ((== (deref A).free64 (null)) (seqn
                    (set (deref A).free64 = (create-buckets 64)))))
            (let ptr = (deref A).free64)
            (set (deref A).free64 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 56))))

        ((<= size 248) (seq
            (cond
                ((== (deref A).free256 (null)) (seqn
                    (set (deref A).free256 = (create-buckets 256)))))
            (let ptr = (deref A).free256)
            (set (deref A).free256 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 248))))

        ((<= size 1016) (seq
            (cond
                ((== (deref A).free1024 (null)) (seqn
                    (set (deref A).free1024 = (create-buckets 1024)))))
            (let ptr = (deref A).free1024)
            (set (deref A).free1024 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 1016))))

        ((<= size 4088) (seq
            (cond
                ((== (deref A).free4096 (null)) (seqn
                    (set (deref A).free4096 = (create-buckets 4096)))))
            (let ptr = (deref A).free4096)
            (set (deref A).free4096 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 4088))))

        ((<= size 16376) (seq
            (cond
                ((== (deref A).free16384 (null)) (seqn
                    (set (deref A).free16384 = (create-buckets 16384)))))
            (let ptr = (deref A).free16384)
            (set (deref A).free16384 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 16376))))

        ((<= size 65528) (seq
            (cond
                ((== (deref A).free65536 (null)) (seqn
                    (set (deref A).free65536 = (create-buckets 65536)))))
            (let ptr = (deref A).free65536)
            (set (deref A).free65536 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 65528))))

        (:else
            (mmap size))))

// Helper function for deallocation.
(defun dealloc-helper (A (* Allocator)) (ptr (* 'a)) (size u64)
    (cond
        ((or (== size 0) (== ptr (null))) ())
        ((<= size 8) (seqn
            (let p = (ptr-add (: (* u8) (cast ptr)) 8))
            (let bucket = (: (* FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16)
            (set (deref A).free16 = bucket)))

        ((<= size 56) (seqn
            (let p = (ptr-add (: (* u8) (cast ptr)) 56))
            (let bucket = (: (* FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free64)
            (set (deref A).free64 = bucket)))

        ((<= size 248) (seqn
            (let p = (ptr-add (: (* u8) (cast ptr)) 248))
            (let bucket = (: (* FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free256)
            (set (deref A).free256 = bucket)))

        ((<= size 1016) (seqn
            (let p = (ptr-add (: (* u8) (cast ptr)) 1016))
            (let bucket = (: (* FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free1024)
            (set (deref A).free1024 = bucket)))

        ((<= size 4088) (seqn
            (let p = (ptr-add (: (* u8) (cast ptr)) 4088))
            (let bucket = (: (* FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free4096)
            (set (deref A).free4096 = bucket)))

        ((<= size 16376) (seqn
            (let p = (ptr-add (: (* u8) (cast ptr)) 16376))
            (let bucket = (: (* FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16384)
            (set (deref A).free16384 = bucket)))

        ((<= size 65528) (seqn
            (let p = (ptr-add (: (* u8) (cast ptr)) 65528))
            (let bucket = (: (* FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free65536)
            (set (deref A).free65536 = bucket)))

        (:else
            (munmap ptr size))))

// Allocates a pointer to some data.
(defun alloc (A (* Allocator)) : (* 'a)
    (alloc-helper A (sizeof 'a)))

// Deallocates a pointer.
(defun dealloc (A (* Allocator)) (ptr (* 'a))
    (dealloc-helper A ptr (sizeof 'a)))

// Allocates an array of data.
(defun alloc-array (A (* Allocator)) (len u64) : (@ 'a)
    (slice len (alloc-helper A (* len (sizeof 'a)))))

// Deallocates an array of data.
(defun dealloc-array (A (* Allocator)) (s (@ 'a)) 
    (dealloc-helper A s.ptr (* s.len (sizeof 'a))))

// Creates a new empty allocator.
(defun new-alloc : Allocator
    (inst Allocator
        (free16    (null))
        (free64    (null))
        (free256   (null))
        (free1024  (null))
        (free4096  (null))
        (free16384 (null))
        (free65536 (null))))

// Defines a vector (ie a list).
(defstruct Vec
    (vals (@ 'a))
    (len u64)
    (A (* Allocator)))

// Creates a new empty vector.
(defun new-vec (A (* Allocator)) : (Vec 'a)
    (inst Vec
        (vals (slice 0 (null)))
        (len 0)
        (A A)))

// Gets the ith element of a vector.
(defun vec-get (v (* (Vec 'a))) (i u64) : (* 'a)
    (cond
        ((< i (deref v).len) (ptr-add (deref v).vals.ptr i))
        (:else (null))))

// Pushes a value onto a vector.
(defun vec-push (vec (* (Vec 'a))) (v 'a) (seqn
    (cond
        ((<= (deref vec).vals.cap (deref vec).len) (seqn
            (let new-cap = (cond
                ((== (deref vec).vals.cap 0) 8)
                (:else (* (deref vec).vals.cap 2))))
            (let new-vals = (alloc-array (deref vec).A new-cap))
            (let i = 0)
            (while (< i (deref vec).len) (seqn
                (set (get new-vals i) = (get (deref vec).vals i))
                (set i = (+ i 1))))
            (dealloc-array (deref vec).A (deref vec).vals)
            (set (deref vec).vals = new-vals))))
    (set (get (deref vec).vals (deref vec).len) = v)
    (set (deref vec).len = (+ (deref vec).len 1))))

// Inserts a value onto a vector at the given index.
(defun vec-insert (vec (* (Vec 'a))) (v 'a) (i u64) (seqn
    (cond
        ((<= (deref vec).vals.cap (deref vec).len) (seqn
            (let new-cap = (cond
                ((== (deref vec).vals.cap 0) 8)
                (:else (* (deref vec).vals.cap 2))))
            (let new-vals = (alloc-array (deref vec).A new-cap))
            (let i = 0)
            (while (< i (deref vec).len) (seqn
                (set (get new-vals i) = (get (deref vec).vals i))
                (set i = (+ i 1))))
            (dealloc-array (deref vec).A (deref vec).vals)
            (set (deref vec).vals = new-vals))))
    (cond
        ((<= i (deref vec).len) (seqn
            (let j = (deref vec).len)
            (while (< i j) (seqn
                (set (get (deref vec).vals j) = (get (deref vec).vals (- j 1)))
                (set j = (- j 1))))
            (set (get (deref vec).vals i) = v)
            (set (deref vec).len = (+ (deref vec).len 1)))))))

// Pops a value from a vector
// TODO: this leaks memory
(defun vec-pop (vec (* (Vec 'a))) (seqn
    (cond
        ((> (deref vec).len 0) (seqn
            (set (deref vec).len = (- (deref vec).len 1)))))))

// Creates a slice from a vector.
(defun vec-slice (vec (* (Vec 'a))) : (@ 'a)
    (subslice (deref vec).vals 0 (deref vec).len))

(defun vec-find (vec (* (Vec 'a))) (pred (fn ((* 'a) 'b) : u1)) (data 'b) : (* 'a) (seq
    (let i = 0)
    (while (< i (deref vec).len) (seqn
        (let item = (vec-get vec i))
        (cond
            ((pred item data)
                (break item)))
        (set i = (+ i 1)))
    :else (null))))

// Empty deallocator
(defun empty-dealloc (v (* 'a)) ())

// Drops a vector
(defun vec-drop (vec (* (Vec 'a))) (callback (fn ((* 'a)))) (seqn
    (let i = 0)
    (while (< i (deref vec).len) (seqn
        (callback (ptr-add (deref vec).vals.ptr i))
        (set i = (+ i 1))))
    (dealloc-array (deref vec).A (deref vec).vals)))

// Checks if a string slice contains a character.
(defun str-contains (str (@ u8)) (c u8) : u1 (seq
    (let i = 0)
    (while (< i str.len) (seqn
        (cond
            ((== c (get str i))
                (break true)))
        (set i = (+ i 1)))
    :else false)))

(defun str-equals (a (@ u8)) (b (@ u8)) : u1
    (cond
        ((!= a.len b.len) false)
        (:else (seq
            (let i = 0)
            (while (< i a.len) (seqn
                (cond
                    ((!= (get a i) (get b i))
                        (break false)))
                (set i = (+ i 1)))
            :else true)))))

(defun get-argv (argv (* (* u8))) (i u64) : (@ u8) (seq
    (let j = 0)
    (while (<= j i) (seqn
        (cond
            ((== (deref (ptr-add argv j)) (null))
                (break (slice 0 (null)))))
        (set j = (+ j 1)))
    :else (seq
        (let p = (deref (ptr-add argv i)))
        (let len = 0)
        (while (deref (ptr-add p len)) (seqn
            (set len = (+ len 1))))
        (slice len p)))))

(defstruct Pair
    (a 'a)
    (b 'b))

(defun matches-key (pair (* (Pair (@ u8) 'a))) (str (@ u8)) : u1
    (str-equals (deref pair).a str))



//
// ==================================================================================================
// LEXING
// ==================================================================================================
//

// Defines a location in source code.
(defstruct Location
    (start u64)
    (end u64))

// Defines a token.
(defstruct Token
    (loc Location)
    (type u64)
    (value (@ u8)))

(defmacro TOKEN_TYPE_EOF     0)
(defmacro TOKEN_TYPE_INVALID 1)
(defmacro TOKEN_TYPE_LPAREN  2)
(defmacro TOKEN_TYPE_RPAREN  3)
(defmacro TOKEN_TYPE_INT     4)
(defmacro TOKEN_TYPE_SYMBOL  5)
(defmacro TOKEN_TYPE_KEY     6)
(defmacro TOKEN_TYPE_DOT     7)
(defmacro TOKEN_TYPE_QUOTE   8)
(defmacro TOKEN_TYPE_STRING  9)
(defmacro TOKEN_TYPE_CHAR   10)
(defmacro TOKEN_TYPE_BOOL   11)

// Defines a lexer.
(defstruct Lexer
    (str (@ u8))
    (pos u64)
    (tokens (Vec Token))
    (token-pos u64))

// Creates a new lexer.
(defun new-lexer (A (* Allocator)) (str (@ u8)) : Lexer
    (inst Lexer
        (str str)
        (pos 0)
        (tokens (new-vec A))
        (token-pos 0)))

// Lexes a string.
(defun lex-next (lexer (* Lexer)) : Token
    (cond
        ((< (deref lexer).token-pos (deref lexer).tokens.len) (seq
            (let v = (vec-get (ref (deref lexer).tokens) (deref lexer).token-pos))
            (set (deref lexer).token-pos = (+ (deref lexer).token-pos 1))
            (deref v)))
        (:else (seq
            (let i = (deref lexer).pos)
            (let state = 0)
            (let comment-mode = 0)
            (let type = (TOKEN_TYPE_INVALID))
            (while (< i (deref lexer).str.len) (seqn
                (let c = (get (deref lexer).str i))
                (set i = (+ i 1))
                (let next = (cond
                    ((< i (deref lexer).str.len) (get (deref lexer).str i))
                    (:else 0)))
                (cond
                    // Line comments
                    ((and (== comment-mode 1) (== c '\n')) (seqn
                        (set comment-mode = 0)
                        (set (deref lexer).pos = i)))
                    ((== comment-mode 1) ())

                    // Block comments
                    ((and (== comment-mode 2) (and (== c '*') (== next '/'))) (seqn
                        (set comment-mode = 0)
                        (set i = (+ i 1))
                        (set (deref lexer).pos = i)))
                    ((== comment-mode 2) ())

                    // Initial state
                    ((== state 0) (cond
                        // Line comments
                        ((and (== c '/') (== next '/')) (seqn
                            (set comment-mode = 1)))

                        // Block comments
                        ((and (== c '/') (== next '*')) (seqn
                            (set comment-mode = 2)))

                        // Whitespace
                        ((str-contains " \n\t\r" c) (seqn
                            (set (deref lexer).pos = i)))

                        // Left parenthesis
                        ((== c 40) (seqn
                            (set type = (TOKEN_TYPE_LPAREN))
                            (break)))

                        // Right parenthesis
                        ((== c 41) (seqn
                            (set type = (TOKEN_TYPE_RPAREN))
                            (break)))

                        // Dot
                        ((== c '.') (seqn
                            (set type = (TOKEN_TYPE_DOT))
                            (break)))

                        // Quote
                        ((== c '\'') (seqn
                            (set type = (TOKEN_TYPE_CHAR))
                            (set state = 1)))

                        // Integers
                        ((and (<= '0' c) (<= c '9')) (seqn
                            (set type = (TOKEN_TYPE_INT))
                            (set state = 1)))

                        // Colon symbol
                        ((and (== c ':') (not (str-contains "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" next))) (seqn
                            (set type = (TOKEN_TYPE_SYMBOL))
                            (break)))

                        // Symbols
                        ((str-contains "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c) (seqn
                            (set type = (TOKEN_TYPE_SYMBOL))
                            (set state = 1)))

                        // Keys
                        ((== c ':') (seqn
                            (set type = (TOKEN_TYPE_KEY))
                            (set state = 1)))

                        ((== c '"') (seqn
                            (set type = (TOKEN_TYPE_STRING))
                            (set state = 1)))

                        // Everything else is invalid
                        (:else (break))))

                    // Integers
                    ((== type (TOKEN_TYPE_INT))
                        (cond
                            ((or (> '0' c) (> c '9')) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // Symbols
                    ((== type (TOKEN_TYPE_SYMBOL))
                        (cond
                            ((or (not (str-contains "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c)) (and (== c '/') (== next '*'))) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // Keys
                    ((== type (TOKEN_TYPE_KEY))
                        (cond
                            ((or (not (str-contains "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c)) (and (== c '/') (== next '*'))) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // String unescaped character
                    ((and (== type (TOKEN_TYPE_STRING)) (== state 1))
                        (cond
                            ((== c '\\') (seqn
                                (set state = 2)))
                            ((== c '"')
                                (break))))

                    // String escaped character
                    ((and (== type (TOKEN_TYPE_STRING)) (== state 2)) (seqn
                        (set state = 1)))

                    // Beginning of a character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 1))
                        (cond
                            ((== c '\\') (seqn
                                (set state = 2)))
                            ((!= next '\'') (seqn
                                (set i = (- i 1))
                                (set type = (TOKEN_TYPE_QUOTE))
                                (break)))
                            (:else (seqn
                                (set state = 3)))))

                    // Escaped character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 2))
                        (cond
                            ((str-contains "nrt0\\'\"" c) (seqn
                                (set state = 3)))
                            (:else (seqn
                                (set type = (TOKEN_TYPE_INVALID))
                                (break)))))

                    // End of character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 3))
                        (cond
                            ((== c '\'')
                                (break))
                            (:else (seqn
                                (set type = (TOKEN_TYPE_INVALID))
                                (break))))))))

            (let start = (deref lexer).pos)
            (cond ((== start i) (seqn
                (set type = (TOKEN_TYPE_EOF)))))
            (set (deref lexer).pos = i)
            (let value = (subslice (deref lexer).str start i))
            (cond
                ((or (str-equals value "true") (str-equals value "false")) (seqn
                    (set type = (TOKEN_TYPE_BOOL)))))
            (let token = (inst Token
                (loc (inst Location
                    (start start)
                    (end i)))
                (type type)
                (value value)))
            (let token-vec = (ref (deref lexer).tokens))
            (vec-push token-vec token)
            (set (deref lexer).tokens = (deref token-vec))
            (set (deref lexer).token-pos = (+ (deref lexer).token-pos 1))
            token))))

// Peeks into the lexer and returns the next token without consuming it.
(defun lex-peek (lexer (* Lexer)) : Token (seq
    (let token = (lex-next lexer))
    (set (deref lexer).token-pos = (- (deref lexer).token-pos 1))
    token))

// Drops a lexer.
(defun lexer-drop (lexer (* Lexer))
    (vec-drop (ref (deref lexer).tokens) empty-dealloc))

// Prints out a token.
(defstruct LexerResult
    (token Token)
    (fail ParseFailure)
    (success u1))

// Expects a type of token and fails if the token is not next.
(defun lexer-expect (lexer (* Lexer)) (type u64) : LexerResult
    (cond
        ((== type (lex-peek lexer).type)
            (inst LexerResult
                (token (lex-next lexer))
                (fail (inst ParseFailure
                    (loc (inst Location
                        (start 0)
                        (end 0)))
                    (expected 0)
                    (received 0)))
                (success true)))
        (:else
            (inst LexerResult
                (token (inst Token
                    (loc (inst Location
                        (start 0)
                        (end 0)))
                    (type 0)
                    (value "")))
                (fail (inst ParseFailure
                    (loc (lex-peek lexer).loc)
                    (expected type)
                    (received (lex-peek lexer).type)))
                (success false)))))



//
// ==================================================================================================
// PARSER
// ==================================================================================================
//

(defmacro AST_NODE_TYPE_INVALID  0)
(defmacro AST_NODE_TYPE_ROOT     1)
(defmacro AST_NODE_TYPE_SEXPR    2)
(defmacro AST_NODE_TYPE_INT      3)
(defmacro AST_NODE_TYPE_SYMBOL   4)
(defmacro AST_NODE_TYPE_KEY      5)
(defmacro AST_NODE_TYPE_ATTR     6)
(defmacro AST_NODE_TYPE_QUOTE    7)
(defmacro AST_NODE_TYPE_STRING   8)
(defmacro AST_NODE_TYPE_CHAR     9)
(defmacro AST_NODE_TYPE_BOOL    10)

(defmacro ERROR_TYPE_VALUE (- 0 1))

(defstruct Ast
    (type u64)
    (loc Location)
    (typed Type)
    (value (@ u8))
    (children (Vec Ast)))

(defun ast-clone (ast Ast) : Ast
    (seq
        (let children = (ref (new-vec ast.children.A)))
        (let i = 0)
        (while (< i ast.children.len) (seqn
            (vec-push children (ast-clone (deref (vec-get (ref ast.children) i))))
            (set i = (+ i 1))))
        (inst Ast
            (type ast.type)
            (loc ast.loc)
            (typed (empty-type ast.children.A))
            (value ast.value)
            (children (deref children)))))

(defun ast-drop (ast (* Ast))
    // TODO: dropping types
    (vec-drop (ref (deref ast).children) ast-drop))

(defun print-ast-helper (ast (* Ast)) (level u64) (seqn
    (let i = 0)
    (while (< i level) (seqn
        (print "    ")
        (set i = (+ i 1))))
    (print-int (deref ast).loc.start)
    (print "..")
    (print-int (deref ast).loc.end)
    (print " ")
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_INVALID))
            (print "INVALID"))
        ((== (deref ast).type (AST_NODE_TYPE_ROOT))
            (print "ROOT"))
        ((== (deref ast).type (AST_NODE_TYPE_SEXPR))
            (print "SEXPR"))
        ((== (deref ast).type (AST_NODE_TYPE_INT))
            (print "INT"))
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL))
            (print "SYMBOL"))
        ((== (deref ast).type (AST_NODE_TYPE_KEY))
            (print "KEY"))
        ((== (deref ast).type (AST_NODE_TYPE_ATTR))
            (print "ATTRIBUTE"))
        ((== (deref ast).type (AST_NODE_TYPE_QUOTE))
            (print "QUOTE"))
        ((== (deref ast).type (AST_NODE_TYPE_STRING))
            (print "STRING"))
        ((== (deref ast).type (AST_NODE_TYPE_CHAR))
            (print "CHAR"))
        ((== (deref ast).type (AST_NODE_TYPE_BOOL))
            (print "BOOL"))
        (:else
            (print "UNKNOWN")))
    (print " ")
    (print (deref ast).value)
    (print " : ")
    (print-type (ref (deref ast).typed))
    (print "\n")
    (let i = 0)
    (while (!= (let child = (vec-get (ref (deref ast).children) i)) (null)) (seqn
        (print-ast-helper child (+ level 1))
        (set i = (+ i 1))))))

(defun print-ast (ast (* Ast))
    (print-ast-helper ast 0))

(defstruct LineColumn
    (line-start u64)
    (col-start u64)
    (line-end u64)
    (col-end u64))

(defun loc-to-line-col (contents (@ u8)) (loc Location) : LineColumn (seq
    (let i = 0)
    (let line-start = 1)
    (let col-start = 0)
    (while (< i loc.start) (seqn
        (cond
            ((== (get contents i) '\n') (seqn
                (set line-start = (+ line-start 1))
                (set col-start = 0)))
            (:else (seqn
                (set col-start = (+ col-start 1)))))
        (set i = (+ i 1))))
    (let line-end = line-start)
    (let col-end = col-start)
    (while (< i loc.end) (seqn
        (cond
            ((== (get contents i) '\n') (seqn
                (set line-end = (+ line-end 1))
                (set col-end = 0)))
            (:else (seqn
                (set col-end = (+ col-end 1)))))
        (set i = (+ i 1))))
    (inst LineColumn
        (line-start line-start)
        (col-start col-start)
        (line-end line-end)
        (col-end col-end))))

(defun print-parse-error-helper (type u64)
    (cond
        ((== type (ERROR_TYPE_VALUE))
            (eprint "VALUE"))
        ((== type (TOKEN_TYPE_EOF))
            (eprint "EOF"))
        ((== type (TOKEN_TYPE_INVALID))
            (eprint "INVALID"))
        ((== type (TOKEN_TYPE_LPAREN))
            (eprint "LPAREN"))
        ((== type (TOKEN_TYPE_RPAREN))
            (eprint "RPAREN"))
        ((== type (TOKEN_TYPE_INT))
            (eprint "INT"))
        ((== type (TOKEN_TYPE_SYMBOL))
            (eprint "SYMBOL"))
        ((== type (TOKEN_TYPE_KEY))
            (eprint "KEY"))
        ((== type (TOKEN_TYPE_DOT))
            (eprint "DOT"))
        ((== type (TOKEN_TYPE_QUOTE))
            (eprint "QUOTE"))
        ((== type (TOKEN_TYPE_STRING))
            (eprint "STRING"))
        ((== type (TOKEN_TYPE_CHAR))
            (eprint "CHAR"))
        ((== type (TOKEN_TYPE_BOOL))
            (eprint "BOOL"))
        (:else
            (eprint "UNKNOWN"))))

(defun print-parse-error (contents (@ u8)) (fail (* ParseFailure)) (seqn
    (eprint "error: expected ")
    (print-parse-error-helper (deref fail).expected)
    (eprint ", got ")
    (print-parse-error-helper (deref fail).received)
    (let line-col = (loc-to-line-col contents (deref fail).loc))
    (eprint " (")
    (eprint-int line-col.line-start)
    (eprint ":")
    (eprint-int line-col.col-start)
    (eprint "..")
    (eprint-int line-col.line-end)
    (eprint ":")
    (eprint-int line-col.col-end)
    (eprint ")\n")))

(defstruct ParseFailure
    (loc Location)
    (expected u64)
    (received u64))

(defstruct ParseResult
    (ast Ast)
    (fail ParseFailure)
    (success u1))

(defun parse-fail (fail ParseFailure) : ParseResult
    (inst ParseResult
        (ast (inst Ast
            (type 0)
            (loc (inst Location
                (start 0)
                (end 0)))
            (typed (empty-type (null)))
            (value (slice 0 (null)))
            (children (new-vec (null)))))
        (fail fail)
        (success false)))

(defun parse-success (ast Ast) : ParseResult
    (inst ParseResult
        (ast ast)
        (fail (inst ParseFailure
            (loc (inst Location
                (start 0)
                (end 0)))
            (expected 0)
            (received 0)))
        (success true)))

(defmacro
    pguard var = value
        stats
    &key else
    (seq
        (let var = value)
        (cond
            (var.success (seq
                (let var = var.ast)
                stats))
            (:else (seq
                else
                var)))))

(defmacro
    lguard var = value
        stats
    &key else
    (seq
        (let var = value)
        (cond
            (var.success (seq
                (let var = var.token)
                stats))
            (:else (seq
                else
                (parse-fail var.fail))))))

(defun parse-value (lexer (* Lexer)) : ParseResult
    (seq
        (let token = (lex-peek lexer))
        (cond
            ((== token.type (TOKEN_TYPE_LPAREN))
                (parse-sexpr lexer))

            ((== token.type (TOKEN_TYPE_SYMBOL)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_SYMBOL))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_INT)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_INT))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_KEY)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_KEY))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_QUOTE)) (seq
                (lex-next lexer)
                (pguard quoted = (parse-value lexer) (seq
                    (let children = (ref (new-vec (deref lexer).tokens.A)))
                    (vec-push children quoted)
                    (parse-success (inst Ast
                        (type (AST_NODE_TYPE_QUOTE))
                        (loc token.loc)
                        (typed (empty-type (deref lexer).tokens.A))
                        (value "")
                        (children (deref children))))))))

            ((== token.type (TOKEN_TYPE_STRING)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_STRING))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_CHAR)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_CHAR))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_BOOL)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_BOOL))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            (:else (parse-fail (inst ParseFailure
                (loc token.loc)
                (expected (ERROR_TYPE_VALUE))
                (received token.type)))))))

(defun parse-attr-item (lexer (* Lexer)) : ParseResult (seq
    (let token = (lex-peek lexer))
    (cond
        ((== token.type (TOKEN_TYPE_SYMBOL)) (seq
            (lex-next lexer)
            (parse-success (inst Ast
                (type (AST_NODE_TYPE_SYMBOL))
                (loc token.loc)
                (typed (empty-type (deref lexer).tokens.A))
                (value token.value)
                (children (new-vec (deref lexer).tokens.A))))))

        (:else (parse-fail (inst ParseFailure
                (loc token.loc)
                (expected (ERROR_TYPE_VALUE))
                (received token.type)))))))

(defun parse-attribute (lexer (* Lexer)) : ParseResult
    (pguard top = (parse-value lexer)
        (while (== (lex-peek lexer).type (TOKEN_TYPE_DOT))
            (seqn
                (lex-next lexer)
                (let attr = (parse-attr-item lexer))
                (cond
                    (attr.success (seqn
                        (let children = (ref (new-vec (deref lexer).tokens.A)))
                        (vec-push children top)
                        (vec-push children attr.ast)
                        (set top = (inst Ast
                            (type (AST_NODE_TYPE_ATTR))
                            (loc (inst Location
                                (start top.loc.start)
                                (end attr.ast.loc.end)))
                            (typed (empty-type (deref lexer).tokens.A))
                            (value "")
                            (children (deref children))))))
                    (:else
                        (break attr))))
        :else (parse-success top))))

(defun parse-sexpr (lexer (* Lexer)) : ParseResult
    (lguard left = (lexer-expect lexer (TOKEN_TYPE_LPAREN)) (seq
        (let v = (ref (new-vec (deref lexer).tokens.A)))
        (while (let var = (parse-attribute lexer)).success (seqn
            (vec-push v var.ast)))
        (lguard right = (lexer-expect lexer (TOKEN_TYPE_RPAREN))
            (parse-success (inst Ast
                (type (AST_NODE_TYPE_SEXPR))
                (loc (inst Location
                    (start left.loc.start)
                    (end right.loc.end)))
                (typed (empty-type (deref lexer).tokens.A))
                (value "")
                (children (deref v))))
        :else (vec-drop v ast-drop)))))

(defun parse (lexer (* Lexer)) : ParseResult (seq
    (let asts = (ref (new-vec (deref lexer).tokens.A)))
    (let end = 0)
    (while (!= (lex-peek lexer).type (TOKEN_TYPE_EOF)) (seqn
        (let sexpr = (parse-sexpr lexer))
        (cond
            ((not sexpr.success) (seqn
                (vec-drop asts ast-drop)
                (break sexpr))))
        (set end = sexpr.ast.loc.end)
        (vec-push asts sexpr.ast))
    :else (parse-success
        (inst Ast
            (type (AST_NODE_TYPE_ROOT))
            (loc (inst Location
                (start 0)
                (end end)))
            (typed (empty-type (deref lexer).tokens.A))
            (value (slice 0 (null)))
            (children (deref asts)))))))



//
// ==================================================================================================
// MACROS
// ==================================================================================================
//

(defmacro MACRO_ARG_TYPE_ORDERED  0)
(defmacro MACRO_ARG_TYPE_ATOM     1)
(defmacro MACRO_ARG_TYPE_KEY      2)
(defmacro MACRO_ARG_TYPE_REST     3)

(defstruct MacroArg
    (name (@ u8))
    (type u64)
    (value Ast))

(defstruct Macro
    (args (Vec MacroArg))
    (body Ast))

(defun extract-macros (map (* (Vec (Pair (@ u8) Macro)))) (root (* Ast)) (seqn
    (let i = 0)
    (while (< i (deref root).children.len) (seqn
        (let ast = (vec-get (ref (deref root).children) i))
        (let contents = (ref (deref ast).children))
        (cond
            ((and (>= (deref contents).len 2) (== (deref ast).type (AST_NODE_TYPE_SEXPR))) (seqn
                (let name = (vec-get contents 0))
                (cond
                    ((and (== (deref name).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref name).value "defmacro"))
                        (seqn
                            (let name = (vec-get contents 1))
                            (cond
                                ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                    (let name = (deref name).value)
                                    (let args = (ref (new-vec (deref contents).A)))
                                    (let type = (MACRO_ARG_TYPE_ORDERED))
                                    (let i = 2)
                                    (while (< i (- (deref contents).len 1)) (seqn
                                        (let arg = (vec-get contents i))
                                        (cond
                                            ((and (== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref arg).value "&key")) (seqn
                                                (set type = (MACRO_ARG_TYPE_KEY))))
                                            ((and (== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref arg).value "&rest")) (seqn
                                                (set type = (MACRO_ARG_TYPE_REST))))

                                            ((== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                                (vec-push args (inst MacroArg
                                                    (name (deref arg).value)
                                                    (type type)
                                                    (value (inst Ast
                                                        (type 0)
                                                        (loc (inst Location
                                                            (start 0)
                                                            (end 0)))
                                                        (typed (empty-type (deref args).A))
                                                        (value "")
                                                        (children (new-vec (deref args).A))))))))

                                            ((and (== (deref arg).type (AST_NODE_TYPE_SEXPR)) (== (deref arg).children.len 2)) (seqn
                                                (let ast = (deref (vec-get (ref (deref arg).children) 1)))
                                                (let name = (deref (vec-get (ref (deref arg).children) 0)))
                                                (cond
                                                    ((== name.type (AST_NODE_TYPE_SYMBOL))
                                                        (vec-push args (inst MacroArg
                                                            (name name.value)
                                                            (type type)
                                                            (value ast)))))))

                                            ((and (== (deref arg).type (AST_NODE_TYPE_QUOTE)) (== (deref (vec-get (ref (deref arg).children) 0)).type (AST_NODE_TYPE_SYMBOL)))
                                                (vec-push args (inst MacroArg
                                                    (name (deref (vec-get (ref (deref arg).children) 0)).value)
                                                    (type (MACRO_ARG_TYPE_ATOM))
                                                    (value (inst Ast
                                                        (type 0)
                                                        (loc (inst Location
                                                            (start 0)
                                                            (end 0)))
                                                        (typed (empty-type (deref args).A))
                                                        (value "")
                                                        (children (new-vec (deref args).A))))))))

                                        (set i = (+ i 1))))

                                    (let ast = (cond
                                        ((> (deref contents).len 2)
                                            (deref (vec-get contents (- (deref contents).len 1))))
                                        (:else (inst Ast
                                            (type 0)
                                            (loc (inst Location
                                                (start 0)
                                                (end 0)))
                                            (typed (empty-type (deref args).A))
                                            (value "")
                                            (children (new-vec (deref args).A))))))
                                    (vec-push map (inst Pair
                                        (a name)
                                        (b (inst Macro
                                            (args (deref args))
                                            (body ast))))))))))))))
        (set i = (+ i 1))))))

(defun print-macros (map (* (Vec (Pair (@ u8) Macro)))) (seqn
    (let i = 0)
    (while (< i (deref map).len) (seqn
        (let macro = (deref (vec-get map i)))
        (print "Macro ")
        (print macro.a)
        (let macro = macro.b)
        (print ":\n    Args:\n")
        (let j = 0)
        (while (< j macro.args.len) (seqn
            (print "        ")
            (let arg = (deref (vec-get (ref macro.args) j)))
            (print arg.name)
            (print " ")
            (cond
                ((== arg.type (MACRO_ARG_TYPE_ORDERED))
                    (print "ORDERED"))
                ((== arg.type (MACRO_ARG_TYPE_ATOM))
                    (print "ATOM"))
                ((== arg.type (MACRO_ARG_TYPE_KEY))
                    (print "KEY"))
                ((== arg.type (MACRO_ARG_TYPE_REST))
                    (print "REST"))
                (:else
                    (print "UNKNOWN")))
            (print "\n")
            (print-ast-helper (ref arg.value) 3)
            (set j = (+ j 1))))
        (print "    Body:\n")
        (print-ast-helper (ref macro.body) 2)
        (set i = (+ i 1))))))

(defmacro CAPTURED_MACRO_ARG_NONE   0)
(defmacro CAPTURED_MACRO_ARG_SINGLE 1)
(defmacro CAPTURED_MACRO_ARG_REST   2)

(defstruct CapturedMacroArg
    (type u64)
    (start u64))

(defun macro-bind (args (@ Ast)) (macro (* Macro)) (arg-bindings (* (Vec (Pair (@ u8) CapturedMacroArg)))) : u1 (seq
    (let i = 0)
    (while (< i (deref macro).args.len) (seqn
        (let arg = (deref (vec-get (ref (deref macro).args) i)))
        (cond
            ((!= arg.type (MACRO_ARG_TYPE_ATOM))
                (vec-push arg-bindings (inst Pair
                    (a arg.name)
                    (b (inst CapturedMacroArg
                        (type (CAPTURED_MACRO_ARG_NONE))
                        (start 0)))))))
        (set i = (+ i 1))))

    (let ordered-arg = 0)
    (let last-key = "")
    (let i = 0)
    (while (< i args.len) (seqn
        (let arg = (get args i))
        (cond
            ((== arg.type (AST_NODE_TYPE_KEY))
                (cond
                    (last-key.len
                        (break false))
                    ((: u64 (cast (vec-find arg-bindings matches-key (let key = (subslice arg.value 1 arg.value.len))))) (seqn
                        (set last-key = key)))
                    (:else
                        (break false))))
            ((> last-key.len 0) (seqn
                (let arg = (get args (- i 1)))
                (let binding = (vec-find arg-bindings matches-key (let key = (subslice arg.value 1 arg.value.len))))
                (set (deref binding).b = (inst CapturedMacroArg
                    (type (CAPTURED_MACRO_ARG_SINGLE))
                    (start i)))
                (set last-key = "")))
            ((: u64 (cast (let arg = (vec-get (ref (deref macro).args) ordered-arg)))) (seqn
                (let arg = (deref arg))
                (cond
                    ((== arg.type (MACRO_ARG_TYPE_ORDERED)) (seqn
                        (let binding = (vec-find arg-bindings matches-key arg.name))
                        (set (deref binding).b = (inst CapturedMacroArg
                            (type (CAPTURED_MACRO_ARG_SINGLE))
                            (start i)))))
                    ((== arg.type (MACRO_ARG_TYPE_ATOM)) (seqn
                        (let arg-actual = (get args i))
                        (cond
                            ((or (!= arg-actual.type (AST_NODE_TYPE_SYMBOL)) (not (str-equals arg-actual.value arg.name)))
                                (break false)))))
                    ((== arg.type (MACRO_ARG_TYPE_REST)) (seqn
                        (let j = (+ i 1))
                        (cond
                            ((while (< j args.len) (seqn
                                (let arg = (get args j))
                                (cond
                                    ((== arg.type (MACRO_ARG_TYPE_KEY))
                                        (break true)))
                                (set j = (+ j 1)))
                            :else false)
                                (break false)))
                        (let binding = (vec-find arg-bindings matches-key arg.name))
                        (set (deref binding).b = (inst CapturedMacroArg
                            (type (CAPTURED_MACRO_ARG_REST))
                            (start i))))))

                (set ordered-arg = (+ ordered-arg 1))
                (while (and (: u64 (cast (let v = (vec-get (ref (deref macro).args) ordered-arg)))) (== (deref v).type (MACRO_ARG_TYPE_KEY))) (seqn
                    (set ordered-arg = (+ ordered-arg 1))))))

            (:else
                (break false)))
        (set i = (+ i 1)))
    :else (not (and (: u64 (cast (let arg = (vec-get (ref (deref macro).args) ordered-arg)))) (== (deref arg).type (MACRO_ARG_TYPE_ORDERED)))))))

(defun bind-macro-args (ast (* Ast)) (arg-bindings (* (Vec (Pair (@ u8) CapturedMacroArg)))) (old (* Ast))
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seqn
            (let bound = (vec-find arg-bindings matches-key (deref ast).value))
            (cond
                ((: u64 (cast bound)) (seqn
                    (let bound = (deref bound).b)
                    (cond
                        ((== bound.type (CAPTURED_MACRO_ARG_NONE)) (seqn
                            (set (deref ast) = (inst Ast
                                (type (AST_NODE_TYPE_SEXPR))
                                (loc (inst Location
                                    (start 0)
                                    (end 0)))
                                (typed (empty-type (deref arg-bindings).A))
                                (value "")
                                (children (new-vec (deref arg-bindings).A))))))
                        ((== bound.type (CAPTURED_MACRO_ARG_SINGLE)) (seqn
                            (set (deref ast) = (ast-clone (deref (vec-get (ref (deref old).children) (+ bound.start 1)))))))

                        ((== bound.type (CAPTURED_MACRO_ARG_REST)) (seqn
                            (eprint "&rest for macros is not implemented yet\n")
                            (exit 1)))))))))
        (:else (seqn
            (let i = 0)
            (while (< i (deref ast).children.len) (seqn
                (bind-macro-args (vec-get (ref (deref ast).children) i) arg-bindings old)
                (set i = (+ i 1))))))))

(defun replace-macros (map (* (Vec (Pair (@ u8) Macro)))) (ast (* Ast)) (seqn
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seqn
            (let sym = (vec-get (ref (deref ast).children) 0))
            (cond
                ((and (: u64 (cast sym)) (== (deref sym).type (AST_NODE_TYPE_SYMBOL)))
                    (cond
                        ((: u64 (cast (let macro = (vec-find map matches-key (deref sym).value)))) (seqn
                            (let macro = (ref (deref macro).b))
                            (let arg-bindings = (ref (new-vec (deref map).A)))

                            (cond
                                ((macro-bind (subslice (vec-slice (ref (deref ast).children)) 1 (deref ast).children.len) macro arg-bindings) (seqn
                                    (let old = (deref ast))
                                    (set (deref ast) = (ast-clone (deref macro).body))
                                    (bind-macro-args ast arg-bindings (ref old))
                                    (ast-drop (ref old)))))))))))))

    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let child = (vec-get (ref (deref ast).children) i))
        (replace-macros map child)
        (set i = (+ i 1))))))



//
// ==================================================================================================
// TYPE CHECKING
// ==================================================================================================
//

(defmacro TYPE_TYPE_UNKNOWN        0)
(defmacro TYPE_TYPE_INT            1)
(defmacro TYPE_TYPE_F32            2)
(defmacro TYPE_TYPE_F64            3)
(defmacro TYPE_TYPE_TUPLE          4)
(defmacro TYPE_TYPE_POINTER        5)
(defmacro TYPE_TYPE_SLICE          6)
(defmacro TYPE_TYPE_STRUCT         7)
(defmacro TYPE_TYPE_GENERIC        8)
(defmacro TYPE_TYPE_FUNCTION       9)
(defmacro TYPE_TYPE_TYPE_VARIABLE 10)

// Defines a type
(defstruct Type
    (type u64)
    (signed-mutable u1)
    (subtypes (Vec Type))
    (boxed (* Type))
    (name (@ u8))
    (type-var-width u64))

(defun empty-type (A (* Allocator)) : Type
    (inst Type
        (type (TYPE_TYPE_UNKNOWN))
        (signed-mutable false)
        (subtypes (new-vec A))
        (boxed (null))
        (name "")
        (type-var-width 0)))

(defstruct Signature
    (arg-types (Vec Type))
    (ret-type Type)
    (index u64))

(defstruct Struct
    (generics (Vec (@ u8)))
    (fields (Vec (Pair (@ u8) Type))))

(defstruct TypeError
    (loc Location)
    (message (@ u8)))

(defun type-error (loc Location) (message (@ u8)) : TypeError
    (inst TypeError
        (loc loc)
        (message message)))

(defun parse-type-int (loc Location) (str (@ u8)) (errors (* (Vec TypeError))) : u64 (seq
    (let i = 0)
    (let n = 0)
    (while (< i str.len) (seqn
        (let c = (get str i))
        (cond
            ((and (<= '0' c) (<= c '9')) (seqn
                (set n = (+ (* n 10) (cast (- c '0'))))))
            (:else (seqn
                (vec-push errors (type-error loc "could not parse int type"))
                (break 0))))
        (set i = (+ i 1)))
    :else n)))

(defun parse-type (ast (* Ast)) (errors (* (Vec TypeError))) : Type (seq
    (let type = (ref (empty-type (deref errors).A)))
    (cond
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref ast).value "f32")) (seq
            (set (deref type).type = (TYPE_TYPE_F32))
            (deref type)))
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref ast).value "f64")) (seq
            (set (deref type).type = (TYPE_TYPE_F64))
            (deref type)))
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (or (== (get (deref ast).value 0) 'i') (== (get (deref ast).value 0) 'u'))) (seq
            (set (deref type).type = (TYPE_TYPE_INT))
            (set (deref type).type-var-width = (parse-type-int (deref ast).loc (subslice (deref ast).value 1 (deref ast).value.len) errors))
            (set (deref type).signed-mutable = (== (get (deref ast).value 0) 'i'))
            (deref type)))
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seq
            (set (deref type).type = (TYPE_TYPE_STRUCT))
            (set (deref type).name = (deref ast).value)
            (deref type)))
        ((== (deref ast).type (AST_NODE_TYPE_QUOTE)) (seq
            (let child = (vec-get (ref (deref ast).children) 0))
            (cond
                ((== (deref child).type (AST_NODE_TYPE_SYMBOL)) (seqn
                    (set (deref type).type = (TYPE_TYPE_GENERIC))
                    (set (deref type).name = (deref child).value)))
                ((== (deref child).type (AST_NODE_TYPE_SEXPR)) (seqn
                    (set (deref type).type = (TYPE_TYPE_TUPLE))
                    (let i = 0)
                    (let v = (ref (deref type).subtypes))
                    (while (< i (deref child).children.len) (seqn
                        (vec-push v (parse-type (vec-get (ref (deref child).children) i) errors))
                        (set i = (+ i 1))))
                    (set (deref type).subtypes = (deref v))))
                (:else
                    (vec-push errors (type-error (deref child).loc "could not parse quoted type"))))
            (deref type)))

        ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (== (deref ast).children.len 0)) (seq
            (set (deref type).type = (TYPE_TYPE_TUPLE))
            (deref type)))

        ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seq
            (let first = (vec-get (ref (deref ast).children) 0))

            (cond
                ((== (deref first).type (AST_NODE_TYPE_SYMBOL))
                    (cond
                        ((str-equals (deref first).value "*")
                            (cond
                                ((and (== (deref ast).children.len 3) (and (== (let v = (deref (vec-get (ref (deref ast).children) 1))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "mut"))) (seqn
                                    (set (deref type).type = (TYPE_TYPE_POINTER))
                                    (set (deref type).signed-mutable = true)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                ((== (deref ast).children.len 2) (seqn
                                    (set (deref type).type = (TYPE_TYPE_POINTER))
                                    (set (deref type).signed-mutable = false)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 1) errors))))

                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse pointer type")))))

                        ((str-equals (deref first).value "@")
                            (cond
                                ((and (== (deref ast).children.len 3) (and (== (let v = (deref (vec-get (ref (deref ast).children) 1))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "mut"))) (seqn
                                    (set (deref type).type = (TYPE_TYPE_SLICE))
                                    (set (deref type).signed-mutable = true)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                ((== (deref ast).children.len 2) (seqn
                                    (set (deref type).type = (TYPE_TYPE_SLICE))
                                    (set (deref type).signed-mutable = false)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 1) errors))))

                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse slice type")))))

                        ((str-equals (deref first).value "fn")
                            (cond
                                ((>= (deref ast).children.len 2) (seqn
                                    (let arg-types = (ref (new-vec (deref ast).children.A)))
                                    (let args = (vec-get (ref (deref ast).children) 1))
                                    (cond
                                        ((== (deref args).type (AST_NODE_TYPE_SEXPR)) (seqn
                                            (let i = 0)
                                            (while (< i (deref args).children.len) (seqn
                                                (vec-push arg-types (parse-type (vec-get (ref (deref args).children) i) errors))
                                                (set i = (+ i 1))))))
                                        (:else
                                            (vec-push errors (type-error (deref ast).loc "could not parse function arg types"))))

                                    (let ret-type = (ref (empty-type (deref args).children.A)))
                                    (cond
                                        ((and (== (deref ast).children.len 4) (and (== (deref (let v = (vec-get (ref (deref ast).children) 2))).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref v).value ":"))) (seqn
                                            (set (deref ret-type) = (parse-type (vec-get (ref (deref ast).children) 3) errors))))
                                        ((== (deref ast).children.len 2) (seqn
                                            (set (deref ret-type).type = (TYPE_TYPE_TUPLE))))
                                        (:else
                                            (vec-push errors (type-error (deref ast).loc "could not parse function return type"))))
                                    (set (deref type).type = (TYPE_TYPE_FUNCTION))
                                    (set (deref type).subtypes = (deref arg-types))
                                    (set (deref type).boxed = (alloc (deref args).children.A))
                                    (set (deref (deref type).boxed) = (deref ret-type))))
                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse function type")))))

                        (:else (seqn
                            (set (deref type).type = (TYPE_TYPE_STRUCT))
                            (set (deref type).name = (deref first).value)
                            (let i = 1)
                            (let subtypes-ref = (ref (deref type).subtypes))
                            (while (< i (deref ast).children.len) (seqn
                                (vec-push subtypes-ref (parse-type (vec-get (ref (deref ast).children) i) errors))
                                (set i = (+ i 1))))
                            (set (deref type).subtypes = (deref subtypes-ref))))))

                (:else
                    (vec-push errors (type-error (deref ast).loc "could not parse parenthesised type type"))))
            (deref type)))

        (:else (seq
            (vec-push errors (type-error (deref ast).loc "could not parse type"))
            (deref type))))))

(defun extract-structs (ast (* Ast)) (result (* (Vec (Pair (@ u8) Struct)))) (errors (* (Vec TypeError))) (seqn
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (cond
            ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (>= (deref ast).children.len 2)) (seqn
                (let defstruct = (vec-get (ref (deref ast).children) 0))
                (cond
                    ((and (== (deref defstruct).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref defstruct).value "defstruct")) (seqn
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                (let name = (deref name).value)
                                (let generics = (ref (new-vec (deref ast).children.A)))
                                (let fields = (ref (new-vec (deref ast).children.A)))
                                (let i = 2)
                                (while (< i (deref ast).children.len) (seqn
                                    (let field = (vec-get (ref (deref ast).children) i))
                                    (cond
                                        ((and (== (deref field).type (AST_NODE_TYPE_SEXPR)) (== (deref field).children.len 2)) (seqn
                                            (let name = (vec-get (ref (deref field).children) 0))
                                            (let type-ast = (vec-get (ref (deref field).children) 1))
                                            (let type = (parse-type type-ast errors))
                                            (set (deref type-ast).typed = type)
                                            (cond
                                                ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                                    (vec-push fields (inst Pair
                                                        (a (deref name).value)
                                                        (b type)))
                                                    (find-generics (ref type) generics))))))
                                        (:else
                                            (vec-push errors (type-error (deref field).loc "invalid struct field"))))
                                    (set i = (+ i 1))))
                                (cond
                                    ((: u64 (cast (vec-find result matches-key name)))
                                        (vec-push errors (type-error (deref ast).loc "structure defined twice")))
                                    (:else
                                        (vec-push result (inst Pair
                                            (a name)
                                            (b (inst Struct
                                                (generics (deref generics))
                                                (fields (deref fields)))))))))))))))))
        (set i = (+ i 1))))))

(defun print-structs (struct-map (* (Vec (Pair (@ u8) Struct)))) (seqn
    (let i = 0)
    (while (< i (deref struct-map).len) (seqn
        (let struct = (vec-get struct-map i))
        (print (deref struct).a)
        (let j = 0)
        (while (< j (deref struct).b.generics.len) (seqn
            (print " '")
            (print (deref (vec-get (ref (deref struct).b.generics) j)))
            (set j = (+ j 1))))
        (print ":\n")
        (let j = 0)
        (while (< j (deref struct).b.fields.len) (seqn
            (let field = (vec-get (ref (deref struct).b.fields) j))
            (print "    ")
            (print (deref field).a)
            (print ": ")
            (print-type (ref (deref field).b))
            (print "\n")
            (set j = (+ j 1))))
        (set i = (+ i 1))))))

(defun extract-functions
    (ast (* Ast))
    (result (* (Vec (Pair (@ u8) Signature))))
    (errors (* (Vec TypeError)))
(seqn
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (cond
            ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (>= (deref ast).children.len 3)) (seqn
                (let defun = (vec-get (ref (deref ast).children) 0))
                (cond
                    ((and (== (deref defun).type (AST_NODE_TYPE_SYMBOL)) (or (str-equals (deref defun).value "defun") (str-equals (deref defun).value "defext"))) (seqn
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                (let name = (deref name).value)
                                (let colon? = (vec-get (ref (deref ast).children) (- (deref ast).children.len 3)))
                                (let has-ret-type = (and (== (deref colon?).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref colon?).value ":")))

                                (let ret-type = (cond
                                    (has-ret-type (seq
                                        (let type-ast = (vec-get (ref (deref ast).children) (- (deref ast).children.len 2)))
                                        (parse-type type-ast errors)))
                                    (:else (seq
                                        (let type = (ref (empty-type (deref ast).children.A)))
                                        (set (deref type).type = (TYPE_TYPE_TUPLE))
                                        (deref type)))))

                                (let j = 2)
                                (let args = (ref (new-vec (deref ast).children.A)))
                                (let last = (- (deref ast).children.len (cond
                                    (has-ret-type 3)
                                    (:else 1))))
                                (while (< j last) (seqn
                                    (let child = (vec-get (ref (deref ast).children) j))
                                    (cond
                                        ((and (== (deref child).type (AST_NODE_TYPE_SEXPR)) (== (deref child).children.len 2)) (seqn
                                            (let arg = (vec-get (ref (deref child).children) 0))
                                            (cond
                                                ((!= (deref arg).type (AST_NODE_TYPE_SYMBOL))
                                                    (vec-push errors (type-error (deref arg).loc "invalid function argument"))))
                                            (let type = (vec-get (ref (deref child).children) 1))
                                            (vec-push args (parse-type type errors))))
                                        (:else
                                            (vec-push errors (type-error (deref child).loc "invalid function argument"))))
                                    (set j = (+ j 1))))
                                (let func-type = (ref (empty-type (deref errors).A)))
                                (set (deref func-type).type = (TYPE_TYPE_FUNCTION))
                                (set (deref func-type).subtypes = (deref args))
                                (set (deref func-type).boxed = (alloc (deref errors).A))
                                (set (deref (deref func-type).boxed) = ret-type)
                                (set (deref ast).typed = (deref func-type))
                                (cond
                                    ((: u64 (cast (vec-find result matches-key name)))
                                        (vec-push errors (type-error (deref ast).loc "function defined twice")))
                                    (:else
                                        (vec-push result (inst Pair
                                            (a name)
                                            (b (inst Signature
                                                (arg-types (deref args))
                                                (ret-type ret-type)
                                                (index i))))))))))))))))
        (set i = (+ i 1))))))

(defun has-generic (type (* Type)) : u1
    (cond
        ((== (deref type).type (TYPE_TYPE_GENERIC))
            true)
        (:else
            (or (and (: u64 (cast (deref type).boxed)) (has-generic (deref type).boxed)) (seq
                (let i = 0)
                (while (< i (deref type).subtypes.len) (seqn
                    (cond
                        ((has-generic (vec-get (ref (deref type).subtypes) i))
                            (break true)))
                    (set i = (+ i 1)))
                :else false))))))

(defun contains-generic (name (* (@ u8))) (generic (@ u8)) : u1
    (str-equals (deref name) generic))

(defun find-generics (type (* Type)) (generics (* (Vec (@ u8))))
    (cond
        ((== (deref type).type (TYPE_TYPE_GENERIC))
            (cond
                ((not (: u64 (cast (vec-find generics contains-generic (deref type).name))))
                    (vec-push generics (deref type).name))))
        (:else (seqn
            (cond
                ((: u64 (cast (deref type).boxed))
                    (find-generics (deref type).boxed generics)))
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (find-generics (vec-get (ref (deref type).subtypes) i) generics)
                (set i = (+ i 1))))))))

(defun replace-generics (type (* Type)) (generics (* (Vec (Pair (@ u8) Type)))) (substitutions (* (Vec (Pair Type u64))))
    (cond
        ((== (deref type).type (TYPE_TYPE_GENERIC)) (seqn
            (let new = (vec-find generics matches-key (deref type).name))
            (cond
                ((: u64 (cast new)) (seqn
                    (set (deref type) = (type-clone (ref (deref new).b)))))
                (:else (seqn
                    (let new = (ref (empty-type (deref generics).A)))
                    (set (deref new).type = (TYPE_TYPE_TYPE_VARIABLE))
                    (set (deref new).type-var-width = (deref substitutions).len)
                    (vec-push substitutions (inst Pair
                        (a (deref new))
                        (b (COERCION_TYPE_NONE))))
                    (vec-push generics (inst Pair
                        (a (deref type).name)
                        (b (deref new))))
                    (set (deref type) = (deref new)))))))
        (:else (seqn
            (cond
                ((: u64 (cast (deref type).boxed))
                    (replace-generics (deref type).boxed generics substitutions)))
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (replace-generics (vec-get (ref (deref type).subtypes) i) generics substitutions)
                (set i = (+ i 1))))))))

(defun find-generic-matches
    (monomorphised (* Type))
    (genericed (* Type))
    (matches (* (Vec (Pair (@ u8) Type))))
(cond
    ((and (== (deref genericed).type (TYPE_TYPE_GENERIC)) (not (: u64 (cast (vec-find matches matches-key (deref genericed).name)))))
        (vec-push matches (inst Pair
            (a (deref genericed).name)
            (b (deref monomorphised)))))
    ((== (deref monomorphised).type (deref genericed).type) (seqn
        (cond
            ((: u64 (cast (deref monomorphised).boxed))
                (find-generic-matches (deref monomorphised).boxed (deref genericed).boxed matches)))
        (let i = 0)
        (while (< i (deref monomorphised).subtypes.len) (seqn
            (find-generic-matches (vec-get (ref (deref monomorphised).subtypes) i) (vec-get (ref (deref monomorphised).subtypes) i) matches)
            (set i = (+ i 1))))))))

(defun print-type (type (* Type))
    (cond
        ((== (deref type).type (TYPE_TYPE_UNKNOWN))
            (print "<unknown>"))
        ((== (deref type).type (TYPE_TYPE_INT)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "i"))
                (:else
                    (print "u")))
            (print-int (deref type).type-var-width)))
        ((== (deref type).type (TYPE_TYPE_F32))
            (print "f32"))
        ((== (deref type).type (TYPE_TYPE_F64))
            (print "f64"))
        ((== (deref type).type (TYPE_TYPE_TUPLE)) (seqn
            (print "'(")
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (cond
                    ((!= i 0)
                        (print " ")))
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_POINTER)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "(*mut "))
                (:else
                    (print "(* ")))
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_SLICE)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "(@mut "))
                (:else
                    (print "(@ ")))
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_STRUCT)) (seqn
            (cond
                ((deref type).subtypes.len
                    (print "(")))
            (print (deref type).name)
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (print " ")
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (cond
                ((deref type).subtypes.len
                    (print ")")))))
        ((== (deref type).type (TYPE_TYPE_GENERIC)) (seqn
            (print "'")
            (print (deref type).name)))
        ((== (deref type).type (TYPE_TYPE_FUNCTION)) (seqn
            (print "(fn (")
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (cond
                    ((!= i 0)
                        (print " ")))
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (print ") : ")
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (print "$")
            (print-int (deref type).type-var-width)))
        (:else (seqn
            (print "(UNKNOWN: ")
            (print-int (deref type).type)
            (print " ")
            (cond
                ((deref type).signed-mutable
                    (print "true"))
                (:else
                    (print "false")))
            (print " ")
            (print-int (deref type).type-var-width)
            (print ")")))))

(defun print-signatures (func-map (* (Vec (Pair (@ u8) Signature)))) (seqn
    (let i = 0)
    (while (< i (deref func-map).len) (seqn
        (let func = (vec-get func-map i))
        (print (deref func).a)
        (print ": (")
        (let j = 0)
        (while (< j (deref func).b.arg-types.len) (seqn
            (cond
                ((!= j 0)
                    (print " ")))
            (print-type (vec-get (ref (deref func).b.arg-types) j))
            (set j = (+ j 1))))
        (print ") : ")
        (print-type (ref (deref func).b.ret-type))
        (print "\n")
        (set i = (+ i 1))))))

(defmacro COERCION_TYPE_NONE   0)
(defmacro COERCION_TYPE_INT    1)
(defmacro COERCION_TYPE_FLOAT  2)

(defun type-clone (type (* Type)) : Type (seq
    (let new = (ref (empty-type (deref type).subtypes.A)))
    (set (deref new).type = (deref type).type)
    (set (deref new).signed-mutable = (deref type).signed-mutable)
    (let i = 0)
    (let subtypes = (ref (deref new).subtypes))
    (while (< i (deref type).subtypes.len) (seqn
        (vec-push subtypes (type-clone (vec-get (ref (deref type).subtypes) i)))
        (set i = (+ i 1))))
    (set (deref new).subtypes = (deref subtypes))
    (cond
        ((: u64 (cast (deref type).boxed)) (seqn
            (set (deref new).boxed = (alloc (deref type).subtypes.A))
            (set (deref (deref new).boxed) = (type-clone (deref type).boxed)))))
    (set (deref new).name = (deref type).name)
    (set (deref new).type-var-width = (deref type).type-var-width)
    (deref new)))

(defun type-equals (a Type) (b Type) : u1
    (cond
        ((== a.type b.type)
            (cond
                ((== a.type (TYPE_TYPE_INT))
                    (and (== a.signed-mutable b.signed-mutable) (== a.type-var-width b.type-var-width)))
                ((== a.type (TYPE_TYPE_TUPLE))
                    (and (== a.subtypes.len b.subtypes.len) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((or (== a.type (TYPE_TYPE_POINTER)) (== a.type (TYPE_TYPE_SLICE)))
                    (type-equals (deref a.boxed) (deref b.boxed)))
                ((== a.type (TYPE_TYPE_STRUCT))
                    (and (and (str-equals a.name b.name) (== a.subtypes.len b.subtypes.len)) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((== a.type (TYPE_TYPE_GENERIC))
                    (str-equals a.name b.name))
                ((== a.type (TYPE_TYPE_FUNCTION))
                    (and (and (type-equals (deref a.boxed) (deref b.boxed)) (== a.subtypes.len b.subtypes.len)) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((== a.type (TYPE_TYPE_TYPE_VARIABLE))
                    (== a.type-var-width b.type-var-width))
                (:else true)))
        (:else false)))

(defun get-type-leaf (type (* Type)) (substitutions (* (Vec (Pair Type u64)))) (seqn
    (while (== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
        (let new = (deref (vec-get substitutions (deref type).type-var-width)).a)
        (cond
            ((and (== new.type (TYPE_TYPE_TYPE_VARIABLE)) (== new.type-var-width (deref type).type-var-width))
                (break)))
        (set (deref type) = new)))))

(defun substitute (loc Location) (assignee (* Type)) (assigner (* Type)) (substitutions (* (Vec (Pair Type u64)))) (errors (* (Vec TypeError))) (seqn
    (get-type-leaf assignee substitutions)
    (get-type-leaf assigner substitutions)
    (cond
        ((type-equals (deref assignee) (deref assigner))
            ())

        ((== (deref assignee).type (TYPE_TYPE_UNKNOWN)) (seqn
            (set (deref assignee) = (type-clone assigner))))

        ((== (deref assignee).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (let coercion = (deref (vec-get substitutions (deref assignee).type-var-width)).b)
            (let assign = (cond
                ((and (== coercion (COERCION_TYPE_INT)) (== (deref assigner).type (TYPE_TYPE_INT)))
                    true)
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== (deref assigner).type (TYPE_TYPE_F32)) (== (deref assigner).type (TYPE_TYPE_F32))))
                    true)
                ((== coercion (COERCION_TYPE_NONE))
                    true)
                ((== (deref assigner).type (TYPE_TYPE_TYPE_VARIABLE)) (seq
                    (let pair = (vec-get substitutions (deref assigner).type-var-width))
                    (cond
                        ((== (deref pair).b (COERCION_TYPE_NONE)) (seq
                            (set (deref pair).b = coercion)
                            true))
                        ((== (deref pair).b coercion)
                            true)
                        (:else (seq
                            (vec-push errors (type-error loc "type cannot be coerced"))
                            false)))))
                (:else (seq
                    (vec-push errors (type-error loc "type cannot be coerced"))
                    false))))
            (cond
                (assign (seqn
                    (let v = (vec-get substitutions (deref assignee).type-var-width))
                    (set (deref v).a = (type-clone assigner))
                    (set (deref assignee) = (type-clone assigner)))))))

        ((== (deref assigner).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (let coercion = (deref (vec-get substitutions (deref assigner).type-var-width)).b)
            (let assign = (cond
                ((and (== coercion (COERCION_TYPE_INT)) (== (deref assignee).type (TYPE_TYPE_INT)))
                    true)
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== (deref assignee).type (TYPE_TYPE_F32)) (== (deref assignee).type (TYPE_TYPE_F32))))
                    true)
                ((== coercion (COERCION_TYPE_NONE))
                    true)
                ((== (deref assignee).type (TYPE_TYPE_TYPE_VARIABLE)) (seq
                    (let pair = (vec-get substitutions (deref assignee).type-var-width))
                    (cond
                        ((== (deref pair).b (COERCION_TYPE_NONE)) (seq
                            (set (deref pair).b = coercion)
                            true))
                        ((== (deref pair).b coercion)
                            true)
                        (:else (seq
                            (vec-push errors (type-error loc "type cannot be coerced"))
                            false)))))
                (:else (seq
                    (vec-push errors (type-error loc "type cannot be coerced"))
                    false))))
            (cond
                (assign (seqn
                    (let v = (vec-get substitutions (deref assigner).type-var-width))
                    (set (deref v).a = (type-clone assignee)))))))

        ((type-equals (deref assignee) (deref assigner))
            ())

        ((== (deref assignee).type (deref assigner).type)
            (cond
                ((== (deref assignee).type (TYPE_TYPE_TUPLE))
                    (cond
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "tuple types have incompatible lengths")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))))))

                ((or (== (deref assignee).type (TYPE_TYPE_POINTER)) (== (deref assignee).type (TYPE_TYPE_SLICE)))
                    (substitute loc (deref assignee).boxed (ref (deref (deref assigner).boxed)) substitutions errors))

                ((== (deref assignee).type (TYPE_TYPE_STRUCT))
                    (cond
                        ((not (str-equals (deref assignee).name (deref assigner).name))
                            (vec-push errors (type-error loc "incompatible struct types")))
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "struct types have incompatible number of type parameters")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))))))

                ((== (deref assignee).type (TYPE_TYPE_FUNCTION))
                    (cond
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "function types have incompatible arg numbers")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))
                            (substitute loc (deref assignee).boxed (ref (deref (deref assigner).boxed)) substitutions errors)))))
                (:else (seqn
                    (vec-push errors (type-error loc "the given types cannot be unified"))))))

        (:else (seqn
            (vec-push errors (type-error loc "the given types cannot be unified")))))))

(defun check-ast
    (ast (* Ast))
    (errors (* (Vec TypeError)))
    (substitutions (* (Vec (Pair Type u64))))
    (func-map (* (Vec (Pair (@ u8) Signature))))
    (struct-map (* (Vec (Pair (@ u8) Struct))))
    (monomorphisms (* (Vec (Pair Type u64))))
    (scopes (* (Vec (Vec (Pair (@ u8) Type)))))
    (break-type (* Type))
(cond
    ((== (deref ast).type (AST_NODE_TYPE_SEXPR))
        (cond
            ((not (deref ast).children.len) (seqn
                (set (deref ast).typed = (empty-type (deref errors).A))
                (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "seqn"))
                (cond
                    ((> (deref ast).children.len 1) (seqn
                        (vec-push scopes (new-vec (deref errors).A))
                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (check-ast (vec-get (ref (deref ast).children) i) errors substitutions func-map struct-map monomorphisms scopes break-type)
                            (set i = (+ i 1))))
                        (set (deref ast).typed = (empty-type (deref errors).A))
                        (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))
                        (vec-pop scopes)))
                    (:else (seqn
                        (vec-push errors (type-error (deref ast).loc "seqn must have one or more arguments"))))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "seq"))
                (cond
                    ((> (deref ast).children.len 1) (seqn
                        (vec-push scopes (new-vec (deref errors).A))
                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (check-ast (vec-get (ref (deref ast).children) i) errors substitutions func-map struct-map monomorphisms scopes break-type)
                            (set i = (+ i 1))))
                        (set (deref ast).typed = (deref (vec-get (ref (deref ast).children) (- i 1))).typed)
                        (vec-pop scopes)))
                    (:else (seqn
                        (vec-push errors (type-error (deref ast).loc "seq must have one or more arguments"))))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "loop"))
                (cond
                    ((== (deref ast).children.len 2) (seqn
                        (vec-push scopes (new-vec (deref errors).A))
                        (let break-type = (ref (empty-type (deref errors).A)))
                        (check-ast (vec-get (ref (deref ast).children) 1) errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (cond
                            ((== (deref break-type).type (TYPE_TYPE_UNKNOWN)) (seqn
                                (set (deref break-type).type = (TYPE_TYPE_TUPLE)))))
                        (set (deref ast).typed = (deref break-type))
                        (vec-pop scopes)))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "loop must have only one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "break")) (seqn
                (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))
                (let type = (cond
                    ((== (deref ast).children.len 2) (seq
                        (let value = (vec-get (ref (deref ast).children) 1))
                        (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (deref value).typed))
                    ((== (deref ast).children.len 1) (seq
                        (let t = (ref (empty-type (deref errors).A)))
                        (set (deref t).type = (TYPE_TYPE_TUPLE))
                        (deref t)))
                    (:else (seq
                        (vec-push errors (type-error (deref ast).loc "break type does not match previous break type"))
                        (empty-type (deref errors).A)))))
                (cond
                    ((: u64 (cast break-type))
                        (substitute (deref ast).loc break-type (ref type) substitutions errors))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "break found outside of loop"))))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "cond"))
                (cond
                    ((> (deref ast).children.len 1) (seqn
                        (let has-else = false)
                        (let type = (ref (empty-type (deref errors).A)))
                        (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
                        (set (deref type).type-var-width = (deref substitutions).len)
                        (vec-push substitutions (inst Pair
                            (a (type-clone type))
                            (b (COERCION_TYPE_NONE))))
                        (set (deref ast).typed = (deref type))
                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (let child = (vec-get (ref (deref ast).children) i))
                            (cond
                                ((and (== (deref child).type (AST_NODE_TYPE_SEXPR)) (== (deref child).children.len 2)) (seqn
                                    (vec-push scopes (new-vec (deref errors).A))
                                    (let condy = (vec-get (ref (deref child).children) 0))
                                    (cond
                                        ((and (== i (- (deref ast).children.len 1)) (and (== (deref condy).type (AST_NODE_TYPE_KEY)) (str-equals (deref condy).value ":else"))) (seqn
                                            (set has-else = true)))
                                        (:else (seqn
                                            (check-ast condy errors substitutions func-map struct-map monomorphisms scopes break-type)
                                            (cond
                                                ((== (deref condy).typed.type (TYPE_TYPE_INT))
                                                    ())
                                                ((== (deref condy).typed.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                                                    (let pair = (deref (vec-get substitutions (deref condy).typed.type-var-width)))
                                                    (cond
                                                        ((== pair.a.type (TYPE_TYPE_INT))
                                                            ())
                                                        ((== pair.b (COERCION_TYPE_INT))
                                                            ())
                                                        (:else
                                                            (vec-push errors (type-error (deref condy).loc "condition must have integer type"))))))
                                                (:else
                                                    (vec-push errors (type-error (deref condy).loc "condition must have an integer type")))))))

                                    (let then = (vec-get (ref (deref child).children) 1))
                                    (check-ast then errors substitutions func-map struct-map monomorphisms scopes break-type)
                                    (let t = (ref (deref ast).typed))
                                    (substitute (deref then).loc t (ref (deref then).typed) substitutions errors)
                                    (set (deref ast).typed = (deref t))
                                    (vec-pop scopes)))
                                (:else
                                    (vec-push errors (type-error (deref child).loc "cond must have S expression as branch"))))
                            (set i = (+ i 1))))
                        (cond
                            ((not has-else) (seqn
                                (let t = (ref (deref ast).typed))
                                (let nil-type = (ref (empty-type (deref errors).A)))
                                (set (deref nil-type).type = (TYPE_TYPE_TUPLE))
                                (substitute (deref ast).loc t nil-type substitutions errors)
                                (set (deref ast).typed = (deref t)))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "cond must have at least one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value ":"))
                (cond
                    ((== (deref ast).children.len 3) (seqn
                        (let type-ast = (vec-get (ref (deref ast).children) 1))
                        (let asserted-type = (parse-type type-ast errors))
                        (set (deref ast).typed = (type-clone (ref asserted-type)))
                        (let v = (vec-get (ref (deref ast).children) 2))
                        (check-ast v errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (let t = (ref (deref v).typed))
                        (substitute (deref ast).loc t (ref asserted-type) substitutions errors)
                        (set (deref v).typed = (deref t))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc ": takes two arguments")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "let"))
                (cond
                    ((== (deref ast).children.len 4) (seqn
                        (let var-name = (vec-get (ref (deref ast).children) 1))
                        (let equals = (vec-get (ref (deref ast).children) 2))
                        (let value = (vec-get (ref (deref ast).children) 3))
                        (cond
                            ((!= (deref var-name).type (AST_NODE_TYPE_SYMBOL))
                                (vec-push errors (type-error (deref var-name).loc "let expects a variable name after it")))
                            ((or (!= (deref equals).type (AST_NODE_TYPE_SYMBOL)) (not (str-equals (deref equals).value "=")))
                                (vec-push errors (type-error (deref equals).loc "let expects an `=` after the variable name")))
                            (:else (seqn
                                (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                                (cond
                                    ((== (deref scopes).len 0)
                                        (vec-push errors (type-error (deref ast).loc "let must occur within a scope")))
                                    (:else (seqn
                                        (let scope = (vec-get scopes (- (deref scopes).len 1)))
                                        (let v = (vec-find scope matches-key (deref var-name).value))
                                        (cond
                                            ((: u64 (cast v)) (seqn
                                                (set (deref v).b = (deref value).typed)))
                                            (:else
                                                (vec-push scope (inst Pair
                                                    (a (deref var-name).value)
                                                    (b (deref value).typed)))))
                                        (set (deref ast).typed = (type-clone (ref (deref value).typed)))))))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "let expects 3 arguments")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "inst"))
                (cond
                    ((>= (deref ast).children.len 2) (seqn
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                (let struct = (vec-find struct-map matches-key (deref name).value))
                                (cond
                                    ((: u64 (cast struct)) (seqn
                                        (let struct = (deref struct).b)
                                        (let generics = (ref (new-vec (deref ast).children.A)))
                                        (let final-generics = (ref (new-vec (deref errors).A)))
                                        (let i = 0)
                                        (while (< i struct.generics.len) (seqn
                                            (let g = (deref (vec-get (ref struct.generics) i)))
                                            (let type = (ref (empty-type (deref errors).A)))
                                            (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
                                            (set (deref type).type-var-width = (deref substitutions).len)
                                            (vec-push substitutions (inst Pair
                                                (a (deref type))
                                                (b (COERCION_TYPE_NONE))))
                                            (vec-push generics (inst Pair
                                                (a g)
                                                (b (deref type))))
                                            (vec-push final-generics (deref type))
                                            (set i = (+ i 1))))
                                        (let i = 2)
                                        (while (< i (deref ast).children.len) (seqn
                                            (let field = (vec-get (ref (deref ast).children) i))
                                            (cond
                                                ((and (== (deref field).type (AST_NODE_TYPE_SEXPR)) (== (deref field).children.len 2)) (seqn
                                                    (let name = (vec-get (ref (deref field).children) 0))
                                                    (let value = (vec-get (ref (deref field).children) 1))
                                                    (cond
                                                        ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                                            (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                                                            (let type = (vec-find (ref struct.fields) matches-key (deref name).value))
                                                            (cond
                                                                ((: u64 (cast type)) (seqn
                                                                    (let t = (ref (deref value).typed))
                                                                    (let assigner = (ref (type-clone (ref (deref type).b))))
                                                                    (replace-generics assigner generics substitutions)
                                                                    (substitute (deref value).loc t assigner substitutions errors)
                                                                    (set (deref value).typed = (deref t))))
                                                                (:else
                                                                    (vec-push errors (type-error (deref name).loc "struct cannot be instantiated with the given field"))))))
                                                        (:else
                                                            (vec-push errors (type-error (deref name).loc "field must be a symbol"))))))
                                                (:else
                                                    (vec-push errors (type-error (deref field).loc "field entry for inst must be an S expression with two values"))))
                                            (set i = (+ i 1))))
                                        (let t = (ref (empty-type (deref errors).A)))
                                        (set (deref t).type = (TYPE_TYPE_STRUCT))
                                        (set (deref t).name = (deref name).value)
                                        (set (deref t).subtypes = (deref final-generics))
                                        (set (deref ast).typed = (deref t))))
                                    (:else
                                        (vec-push errors (type-error (deref name).loc "undefined struct"))))))
                            (:else
                                (vec-push errors (type-error (deref name).loc "inst must take in a valid struct name"))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "inst takes at least one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "sizeof"))
                (cond
                    ((== (deref ast).children.len 2) (seqn
                        (let type-ast = (vec-get (ref (deref ast).children) 1))
                        (let type = (cond
                            ((!= (deref type-ast).typed.type (TYPE_TYPE_UNKNOWN))
                                (ref (deref type-ast).typed))
                            (:else
                                (ref (parse-type type-ast errors)))))
                        (set (deref type-ast).typed = (deref type))
                        (let int-type = (ref (empty-type (deref errors).A)))
                        (set (deref int-type).type = (TYPE_TYPE_TYPE_VARIABLE))
                        (set (deref int-type).type-var-width = (deref substitutions).len)
                        (vec-push substitutions (inst Pair
                            (a (deref int-type))
                            (b (COERCION_TYPE_INT))))
                        (set (deref ast).typed = (deref int-type))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "sizeof takes one argument")))))

            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "set"))
                (cond
                    ((== (deref ast).children.len 4) (seqn
                        (let value = (vec-get (ref (deref ast).children) 3))
                        (let equal = (vec-get (ref (deref ast).children) 2))
                        (let lvalue = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((and (== (deref equal).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref equal).value "=")) (seqn
                                (check-lvalue lvalue errors substitutions func-map struct-map monomorphisms scopes break-type)
                                (check-ast value errors substitutions func-map struct-map monomorphisms scopes break-type)
                                (substitute (deref ast).loc (ref (deref value).typed) (ref (deref lvalue).typed) substitutions errors)
                                (set (deref ast).typed = (type-clone (ref (deref value).typed)))))
                            (:else
                                (vec-push errors (type-error (deref equal).loc "set requires an `=` in its second argument"))))))
                    (:else
                        (vec-push errors (type-error (deref ast).loc "set takes 3 arguments")))))

            (:else (seqn
                (let i = 0)
                (while (< i (deref ast).children.len) (seqn
                    (let v = (vec-get (ref (deref ast).children) i))
                    (check-ast v errors substitutions func-map struct-map monomorphisms scopes break-type)
                    (set i = (+ i 1))))
                (let func = (vec-get (ref (deref ast).children) 0))
                (cond
                    ((== (deref func).typed.type (TYPE_TYPE_FUNCTION))
                        (cond
                            ((== (deref func).typed.subtypes.len (- i 1)) (seqn
                                (let i = 0)
                                (while (< i (deref func).typed.subtypes.len) (seqn
                                    (let arg = (vec-get (ref (deref ast).children) (+ i 1)))
                                    (let t = (ref (deref arg).typed))
                                    (substitute (deref arg).loc t (vec-get (ref (deref func).typed.subtypes) i) substitutions errors)
                                    (set (deref arg).typed = (deref t))
                                    (set i = (+ i 1))))
                                (set (deref ast).typed = (type-clone (deref func).typed.boxed))))
                            (:else
                                (vec-push errors (type-error (deref ast).loc "function argument count does not match provided argument count")))))
                    (:else
                        (vec-push errors (type-error (deref func).loc "value is not a function"))))))))

    ((== (deref ast).type (AST_NODE_TYPE_INT)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
        (set (deref type).type-var-width = (deref substitutions).len)
        (vec-push substitutions (inst Pair
            (a (deref type))
            (b (COERCION_TYPE_INT))))
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_CHAR)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_INT))
        (set (deref type).type-var-width = 8)
        (set (deref type).signed-mutable = false)
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_BOOL)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_INT))
        (set (deref type).type-var-width = 1)
        (set (deref type).signed-mutable = false)
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_STRING)) (seqn
        (let type = (ref (empty-type (deref errors).A)))
        (set (deref type).type = (TYPE_TYPE_SLICE))
        (set (deref type).signed-mutable = false)
        (set (deref type).boxed = (alloc (deref errors).A))
        (let subtype = (ref (empty-type (deref errors).A)))
        (set (deref subtype).type = (TYPE_TYPE_INT))
        (set (deref subtype).type-var-width = 8)
        (set (deref subtype).signed-mutable = false)
        (set (deref (deref type).boxed) = (deref subtype))
        (set (deref ast).typed = (deref type))))

    ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seqn
        (let i = (deref scopes).len)
        (set (deref ast).typed = (while (!= i 0) (seqn
            (set i = (- i 1))
            (let scope = (vec-get scopes i))
            (let v = (vec-find scope matches-key (deref ast).value))
            (cond
                ((: u64 (cast v))
                    (break (type-clone (ref (deref v).b))))))
        :else (seq
            (let v = (vec-find func-map matches-key (deref ast).value))
            (cond
                ((: u64 (cast v)) (seq
                    (let v = (deref v).b)
                    (let type = (ref (empty-type (deref errors).A)))
                    (set (deref type).type = (TYPE_TYPE_FUNCTION))
                    (set (deref type).boxed = (alloc (deref errors).A))
                    (set (deref (deref type).boxed) = (type-clone (ref v.ret-type)))
                    (let i = 0)
                    (let subtypes = (ref (deref type).subtypes))
                    (while (< i v.arg-types.len) (seqn
                        (vec-push subtypes (type-clone (vec-get (ref v.arg-types) i)))
                        (set i = (+ i 1))))
                    (set (deref type).subtypes = (deref subtypes))
                    (cond
                        ((has-generic type) (seqn
                            (let generics = (ref (new-vec (deref errors).A)))
                            (replace-generics type generics substitutions)
                            (vec-push monomorphisms (inst Pair
                                (a (deref type))
                                (b v.index))))))
                    (deref type)))
                (:else (seq
                    (vec-push errors (type-error (deref ast).loc "undefined symbol"))
                    (empty-type (deref errors).A)))))))))

    ((== (deref ast).type (AST_NODE_TYPE_KEY))
        (vec-push errors (type-error (deref ast).loc "invalid usage of key")))

    ((== (deref ast).type (AST_NODE_TYPE_QUOTE))
        (vec-push errors (type-error (deref ast).loc "invalid usage of quote")))

    ((== (deref ast).type (AST_NODE_TYPE_ATTR)) (seqn
        (let child = (vec-get (ref (deref ast).children) 0))
        (check-ast child errors substitutions func-map struct-map monomorphisms scopes break-type)
        (let i = 1)
        (let type = (ref (type-clone (ref (deref child).typed))))
        (while (< i (deref ast).children.len) (seqn
            (while (== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                (let t = (vec-get substitutions (deref type).type-var-width))
                (cond
                    ((and (== (deref t).a.type (TYPE_TYPE_TYPE_VARIABLE)) (== (deref t).a.type-var-width (deref type).type-var-width))
                        (break)))
                (set (deref type) = (type-clone (ref (deref t).a)))))

            (let attr-ast = (vec-get (ref (deref ast).children) i))
            (let attr = (deref attr-ast).value)
            (cond
                ((== (deref type).type (TYPE_TYPE_POINTER))
                    (cond
                        ((str-equals attr "*") (seqn
                            (set (deref type) = (type-clone (deref type).boxed))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "pointer can only be dereferenced"))
                            (break)))))
                ((== (deref type).type (TYPE_TYPE_SLICE))
                    (cond
                        ((str-equals attr "ptr") (seqn
                            (set (deref type) = (type-clone type))
                            (set (deref type).type = (TYPE_TYPE_POINTER))))
                        ((or (str-equals attr "len") (str-equals attr "cap")) (seqn
                            (set (deref type) = (empty-type (deref errors).A))
                            (set (deref type).type = (TYPE_TYPE_INT))
                            (set (deref type).type-var-width = 64)
                            (set (deref type).signed-mutable = false)))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "invalid attribute of slice"))
                            (break)))))
                ((== (deref type).type (TYPE_TYPE_STRUCT)) (seqn
                    (let struct = (vec-find struct-map matches-key (deref type).name))
                    (let field = (vec-find (ref (deref struct).b.fields) matches-key attr))
                    (cond
                        ((: u64 (cast field)) (seqn
                            (let t = (ref (type-clone (ref (deref field).b))))
                            (let generics = (ref (new-vec (deref errors).A)))
                            (let i = 0)
                            (while (and (< i (deref struct).b.generics.len) (< i (deref type).subtypes.len)) (seqn
                                (vec-push generics (inst Pair
                                    (a (deref (vec-get (ref (deref struct).b.generics) i)))
                                    (b (type-clone (vec-get (ref (deref type).subtypes) i)))))
                                (set i = (+ i 1))))
                            (replace-generics t generics substitutions)
                            (set (deref type) = (deref t))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "struct does not have the given field"))
                            (break)))))))
            (set i = (+ i 1))))
        (set (deref ast).typed = (deref type))))

    (:else (seqn
        (eprint "todo: checking ast type ")
        (eprint-int (deref ast).type)
        (eprint " is currently unimplemented\n")
        (exit 1)))))

(defun check-lvalue
    (lvalue (* Ast))
    (errors (* (Vec TypeError)))
    (substitutions (* (Vec (Pair Type u64))))
    (func-map (* (Vec (Pair (@ u8) Signature))))
    (struct-map (* (Vec (Pair (@ u8) Struct))))
    (monomorphisms (* (Vec (Pair Type u64))))
    (scopes (* (Vec (Vec (Pair (@ u8) Type)))))
    (break-type (* Type))
(cond
    ((== (deref lvalue).type (AST_NODE_TYPE_SYMBOL)) (seqn
        (let i = (deref scopes).len)
        (set (deref lvalue).typed = (while (!= i 0) (seqn
            (set i = (- i 1))
            (let scope = (vec-get scopes i))
            (let v = (vec-find scope matches-key (deref lvalue).value))
            (cond
                ((: u64 (cast v))
                    (break (type-clone (ref (deref v).b))))))
        :else (seq
            (vec-push errors (type-error (deref lvalue).loc "undefined symbol"))
            (empty-type (deref errors).A))))))
    ((== (deref lvalue).type (AST_NODE_TYPE_ATTR)) (seqn
        (let child = (vec-get (ref (deref lvalue).children) 0))
        (check-lvalue child errors substitutions func-map struct-map monomorphisms scopes break-type)
        (let i = 1)
        (let type = (type-clone (ref (deref child).typed)))
        (while (< i (deref lvalue).children.len) (seqn
            (while (== type.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                (let t = (deref (vec-get substitutions type.type-var-width)).a)
                (cond
                    ((and (== t.type (TYPE_TYPE_TYPE_VARIABLE)) (== t.type-var-width type.type-var-width))
                        (break)))
                (set type = (type-clone (ref t)))))
            (let attr-ast = (vec-get (ref (deref lvalue).children) i))
            (let attr = (deref attr-ast).value)
            (cond
                ((== type.type (TYPE_TYPE_STRUCT)) (seqn
                    (let struct = (vec-find struct-map matches-key type.name))
                    (let field = (vec-find (ref (deref struct).b.fields) matches-key attr))
                    (cond
                        ((: u64 (cast field)) (seqn
                            (let t = (ref (type-clone (ref (deref field).b))))
                            (let generics = (ref (new-vec (deref errors).A)))
                            (let i = 0)
                            (while (and (< i (deref struct).b.generics.len) (< i type.subtypes.len)) (seqn
                                (vec-push generics (inst Pair
                                    (a (deref (vec-get (ref (deref struct).b.generics) i)))
                                    (b (type-clone (vec-get (ref type.subtypes) i)))))
                                (set i = (+ i 1))))
                            (replace-generics t generics substitutions)
                            (set type = (deref t))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "struct does not have the given field"))
                            (break))))))
                ((== type.type (TYPE_TYPE_POINTER))
                    (cond
                        ((str-equals attr "*") (seqn
                            (set type = (deref type.boxed))))
                        (:else (seqn
                            (vec-push errors (type-error (deref attr-ast).loc "cannot take field of pointer"))
                            (break)))))
                (:else (seqn
                    (vec-push errors (type-error (deref attr-ast).loc "cannot assign to field of type"))
                    (break))))
            (set i = (+ i 1))))
        (set (deref lvalue).typed = type)))
    ((and (== (deref lvalue).type (AST_NODE_TYPE_SEXPR)) (> (deref lvalue).children.len 0)) (seqn
        (let func-name = (vec-get (ref (deref lvalue).children) 0))
        (cond
            ((and (== (deref func-name).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func-name).value "deref"))
                (cond
                    ((== (deref lvalue).children.len 2) (seqn
                        (let child = (vec-get (ref (deref lvalue).children) 1))
                        (check-lvalue child errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (cond
                            ((== (deref child).typed.type (TYPE_TYPE_POINTER)) (seqn
                                (set (deref lvalue).typed = (type-clone (deref child).typed.boxed))))
                            ((== (deref child).typed.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                                (let u = (ref (empty-type (deref child).children.A)))
                                (set (deref u).type = (TYPE_TYPE_TYPE_VARIABLE))
                                (set (deref u).type-var-width = (deref substitutions).len)
                                (vec-push substitutions (inst Pair
                                    (a (deref u))
                                    (b (COERCION_TYPE_NONE))))
                                (let t = (ref (empty-type (deref child).children.A)))
                                (set (deref t).type = (TYPE_TYPE_POINTER))
                                (set (deref t).boxed = (alloc (deref errors).A))
                                (set (deref (deref t).boxed) = (deref u))
                                (let s = (ref (deref child).typed))
                                (substitute (deref child).loc s t substitutions errors)
                                (set (deref child).typed = (deref s))
                                (set (deref lvalue).typed = (deref u))))
                            (:else
                                (vec-push errors (type-error (deref child).loc "derefed value is not a pointer"))))))
                    (:else
                        (vec-push errors (type-error (deref lvalue).loc "deref expects one argument")))))

            ((and (== (deref func-name).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref func-name).value "get"))
                (cond
                    ((== (deref lvalue).children.len 3) (seqn
                        (let child = (vec-get (ref (deref lvalue).children) 2))
                        (check-ast child errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (let t = (ref (empty-type (deref errors).A)))
                        (set (deref t).type = (TYPE_TYPE_INT))
                        (set (deref t).type-var-width = 64)
                        (set (deref t).signed-mutable = false)
                        (let u = (ref (deref child).typed))
                        (substitute (deref child).loc u t substitutions errors)
                        (set (deref child).typed = (deref u))
                        (let child = (vec-get (ref (deref lvalue).children) 1))
                        (check-lvalue child errors substitutions func-map struct-map monomorphisms scopes break-type)
                        (cond
                            ((== (deref child).typed.type (TYPE_TYPE_SLICE)) (seqn
                                (set (deref lvalue).typed = (type-clone (deref child).typed.boxed))))
                            ((== (deref child).typed.type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
                                (let u = (ref (empty-type (deref child).children.A)))
                                (set (deref u).type = (TYPE_TYPE_TYPE_VARIABLE))
                                (set (deref u).type-var-width = (deref substitutions).len)
                                (vec-push substitutions (inst Pair
                                    (a (deref u))
                                    (b (COERCION_TYPE_NONE))))
                                (let t = (ref (empty-type (deref child).children.A)))
                                (set (deref t).type = (TYPE_TYPE_SLICE))
                                (set (deref t).boxed = (alloc (deref errors).A))
                                (set (deref (deref t).boxed) = (deref u))
                                (let s = (ref (deref child).typed))
                                (substitute (deref child).loc s t substitutions errors)
                                (set (deref child).typed = (deref s))
                                (set (deref lvalue).typed = (deref u))))
                            (:else
                                (vec-push errors (type-error (deref child).loc "get value is not a slice"))))))
                    (:else
                        (vec-push errors (type-error (deref lvalue).loc "get expects two arguments")))))
            (:else
                (vec-push errors (type-error (deref func-name).loc "invalid lvalue function"))))))
    (:else
        (vec-push errors (type-error (deref lvalue).loc "invalid lvalue")))))

(defun flatten-substitution
    (type (* Type))
    (errors (* (Vec TypeError)))
    (loc Location)
    (substitutions (* (Vec (Pair Type u64))))
(cond
    ((== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
        (let type2 = (deref (vec-get substitutions (deref type).type-var-width)).a)
        (cond
            ((and (== type2.type (TYPE_TYPE_TYPE_VARIABLE)) (== type2.type-var-width (deref type).type-var-width))
                (vec-push errors (type-error loc "unassigned type variable")))
            (:else (seqn
                (set (deref type) = type2)
                (flatten-substitution type errors loc substitutions))))))
    (:else (seqn
        (cond
            ((: u64 (cast (deref type).boxed))
                (flatten-substitution (deref type).boxed errors loc substitutions)))
        (let i = 0)
        (while (< i (deref type).subtypes.len) (seqn
            (flatten-substitution (vec-get (ref (deref type).subtypes) i) errors loc substitutions)
            (set i = (+ i 1))))))))

(defun apply-substitutions (ast (* Ast)) (errors (* (Vec TypeError))) (substitutions (* (Vec (Pair Type u64)))) (seqn
    (let type = (ref (deref ast).typed))
    (flatten-substitution type errors (deref ast).loc substitutions)
    (set (deref ast).typed = (deref type))
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (apply-substitutions (vec-get (ref (deref ast).children) i) errors substitutions)
        (set i = (+ i 1))))))

(defun replace-sizeof-generics
    (ast (* Ast))
    (generics (* (Vec (Pair (@ u8) Type))))
(cond
    ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (and (== (deref ast).children.len 2) (str-equals (deref (vec-get (ref (deref ast).children) 0)).value "sizeof"))) (seqn
        (let type-ast = (vec-get (ref (deref ast).children) 1))
        (let type = (ref (parse-type type-ast (ref (new-vec (deref ast).children.A)))))
        (replace-generics type generics (ref (new-vec (deref ast).children.A)))
        (set (deref type-ast).typed = (deref type))))
    (:else (seqn
        (let i = 0)
        (while (< i (deref ast).children.len) (seqn
            (let ast = (vec-get (ref (deref ast).children) i))
            (replace-sizeof-generics ast generics)
            (set i = (+ i 1))))))))

(defun check
    (ast (* Ast))
    (errors (* (Vec TypeError)))
    (func-map (* (Vec (Pair (@ u8) Signature))))
    (struct-map (* (Vec (Pair (@ u8) Struct))))
(seqn
    (let skip = 0)
    (let done = (ref (new-vec (deref errors).A)))
    (while (seq
        (let monomorphisms = (ref (new-vec (deref errors).A)))
        (let scopes = (ref (new-vec (deref errors).A)))

        (let substitutions = (ref (new-vec (deref errors).A)))
        (let i = skip)
        (while (< i (deref ast).children.len) (seqn
            (let ast = (vec-get (ref (deref ast).children) i))
            (cond
                ((not (deref ast).children.len)
                    (vec-push errors (type-error (deref ast).loc "invalid top level construct `()`")))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defun"))
                    (cond
                        ((not (has-generic (ref (deref ast).typed))) (seqn
                            (let name = (deref (vec-get (ref (deref ast).children) 1)).value)
                            (let func-type = (deref ast).typed)
                            (let body = (vec-get (ref (deref ast).children) (- (deref ast).children.len 1)))
                            (let v = (ref (new-vec (deref errors).A)))
                            (let i = 0)
                            (while (< i func-type.subtypes.len) (seqn
                                (let arg = (vec-get (ref (deref ast).children) (+ i 2)))
                                (let arg = (vec-get (ref (deref arg).children) 0))
                                (let arg = (deref arg).value)
                                (let type = (vec-get (ref func-type.subtypes) i))
                                (vec-push v (inst Pair
                                    (a arg)
                                    (b (deref type))))
                                (set i = (+ i 1))))
                            (vec-push scopes (deref v))

                            (check-ast body errors substitutions func-map struct-map monomorphisms scopes (null))
                            (vec-pop scopes)
                            (let type = (ref (deref body).typed))
                            (substitute (deref body).loc type func-type.boxed substitutions errors)
                            (set (deref body).typed = (deref type))))))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defext")) ())
                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defstruct")) ())
                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defmacro")) ())

                (:else
                    (vec-push errors (type-error (deref ast).loc "invalid top level construct"))))
            (set i = (+ i 1))))

        (let i = 0)
        (while (< i (deref substitutions).len) (seqn
            (let pair = (vec-get substitutions i))
            (let type = (deref pair).a)
            (let coercion = (deref pair).b)
            (cond
                ((and (== coercion (COERCION_TYPE_INT)) (and (== type.type (TYPE_TYPE_TYPE_VARIABLE)) (== type.type-var-width i))) (seqn
                    (set type = (empty-type (deref errors).A))
                    (set type.type = (TYPE_TYPE_INT))
                    (set type.type-var-width = 32)
                    (set type.signed-mutable = true)))
                ((and (== coercion (COERCION_TYPE_INT)) (== type.type (TYPE_TYPE_INT)))
                    ())

                ((and (== coercion (COERCION_TYPE_FLOAT)) (and (== type.type (TYPE_TYPE_TYPE_VARIABLE)) (== type.type-var-width i))) (seqn
                    (set type = (empty-type (deref errors).A))
                    (set type.type = (TYPE_TYPE_F64))))
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== type.type (TYPE_TYPE_F32)) (== type.type (TYPE_TYPE_F64))))
                    ()))
            (set (deref pair).a = type)
            (set i = (+ i 1))))

        (apply-substitutions ast errors substitutions)

        (set skip = (deref ast).children.len)
        (cond
            ((deref monomorphisms).len (seqn
                (let i = 0)
                (let asts = (ref (deref ast).children))
                (while (< i (deref monomorphisms).len) (seqn
                    (let monomorphism = (vec-get monomorphisms i))
                    (cond
                        ((not (: u64 (cast (vec-find done type-find (deref monomorphism).a)))) (seqn
                            (let ast = (vec-get asts (deref monomorphism).b))
                            (cond
                                ((: u64 (cast ast)) (seqn
                                    (let genericed = (ref (deref ast).typed))
                                    (let ast = (ref (ast-clone (deref ast))))
                                    (let typed = (ref (type-clone (ref (deref monomorphism).a))))
                                    (flatten-substitution typed errors (deref ast).loc substitutions)
                                    (let generics = (ref (new-vec (deref ast).children.A)))
                                    (find-generic-matches typed genericed generics)
                                    (replace-sizeof-generics ast generics)
                                    (set (deref ast).typed = (deref typed))
                                    (vec-push done (deref ast).typed)
                                    (vec-push asts (deref ast))))))))
                    (set i = (+ i 1))))
                (set (deref ast).children = (deref asts)))))
        (and (< skip (deref ast).children.len) (not (deref errors).len))) ())))

(defun type-find (type (* Type)) (t2 Type) : u1
    (type-equals (deref type) t2))

(defun print-type-errors (contents (@ u8)) (errors (* (Vec TypeError))) (seqn
    (let i = 0)
    (while (< i (deref errors).len) (seqn
        (let error = (deref (vec-get errors i)))
        (eprint "error: ")
        (eprint error.message)
        (let line-col = (loc-to-line-col contents error.loc))
        (eprint " (")
        (eprint-int line-col.line-start)
        (eprint ":")
        (eprint-int line-col.col-start)
        (eprint "..")
        (eprint-int line-col.line-end)
        (eprint ":")
        (eprint-int line-col.col-end)
        (eprint ")\n")
        (set i = (+ i 1))))
    (cond
        (i (exit 1)))))

(defun create-default-signatures (A (* Allocator)) : (Vec (Pair (@ u8) Signature)) (seq
    (let map = (ref (new-vec A)))
    (vec-push map (inst Pair
        (a "+")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "-")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "*")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "/")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "%")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "<<")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a ">>")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "&")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "|")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "^")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "<")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a ">")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "<=")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a ">=")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "==")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "!=")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 1)
                (set (deref t).signed-mutable = false)
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "ptr-add")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "cast")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "b")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "ptr-sub")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "alloca")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_SLICE))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "ref")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "deref")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "get")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_SLICE))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))

                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_GENERIC))
                (set (deref t).name = "a")
                (deref t)))
            (index (- 0 1))))))
    (vec-push map (inst Pair
        (a "slice")
        (b (inst Signature
            (arg-types (seq
                (let v = (ref (new-vec A)))
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_INT))
                (set (deref t).type-var-width = 64)
                (set (deref t).signed-mutable = false)
                (vec-push v (deref t))

                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_POINTER))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (vec-push v (deref t))
                (deref v)))
            (ret-type (seq
                (let u = (ref (empty-type A)))
                (set (deref u).type = (TYPE_TYPE_GENERIC))
                (set (deref u).name = "a")
                (let t = (ref (empty-type A)))
                (set (deref t).type = (TYPE_TYPE_SLICE))
                (set (deref t).boxed = (alloc A))
                (set (deref (deref t).boxed) = (deref u))
                (deref t)))
            (index (- 0 1))))))
    (deref map)))



//
// ==================================================================================================
// LLVM EXTERNALS
// ==================================================================================================
//

(defstruct LlvmContext)

(defext llvm-context-create
    : (* LlvmContext)
    "LLVMContextCreate")

(defstruct LlvmModule)

(defext llvm-module-create-with-name-in-context-raw
    (name (* u8))
    (context (* LlvmContext))
    : (* LlvmModule)
    "LLVMModuleCreateWithNameInContext")
(defun llvm-module-create-with-name-in-context
    (name (@ u8))
    (context (* LlvmContext))
    : (* LlvmModule)
(seq
    (let null-term = (alloca (+ name.len 1)))
    (let i = 0)
    (while (< i name.len)
        (seqn
            (set (get null-term i) = (get name i))
            (set i = (+ i 1))))
    (set (get null-term i) = '\0')
    (llvm-module-create-with-name-in-context-raw null-term.ptr context)))

(defstruct LlvmBuilder)

(defext llvm-create-builder-in-context
    (context (* LlvmContext))
    : (* LlvmBuilder)
    "LLVMCreateBuilderInContextWrapper")

(defext llvm-dump-module
    (module (* LlvmModule))
    "LLVMDumpModuleWrapper")

(defstruct LlvmType)
(defstruct LlvmValue)

(defext llvm-add-function-raw
    (module (* LlvmModule))
    (name (* u8))
    (type (* LlvmType))
    : (* LlvmValue)
    "LLVMAddFunctionWrapper")
(defun llvm-add-function
    (module (* LlvmModule))
    (name (@ u8))
    (type (* LlvmType))
    : (* LlvmValue)
(seq
    (let null-term = (alloca (+ name.len 1)))
    (let i = 0)
    (while (< i name.len)
        (seqn
            (set (get null-term i) = (get name i))
            (set i = (+ i 1))))
    (set (get null-term i) = '\0')
    (llvm-add-function-raw module null-term.ptr type)))

(defext llvm-function-type-raw
    (return-type (* LlvmType))
    (param-types (* (* LlvmType)))
    (param-count u64)
    (variadic u1)
    : (* LlvmType)
    "LLVMFunctionTypeWrapper")
(defun llvm-function-type
    (return-type (* LlvmType))
    (param-types (@ (* LlvmType)))
    (variadic u1)
    : (* LlvmType)
    (llvm-function-type-raw return-type param-types.ptr param-types.len variadic))

(defext llvm-int-type-in-context
    (context (* LlvmContext))
    (bitwidth u64)
    : (* LlvmType)
    "LLVMIntTypeInContext")

(defstruct LlvmBasicBlock)

(defext llvm-append-basic-block-in-context-raw
    (context (* LlvmContext))
    (function (* LlvmValue))
    (name (* u8))
    : (* LlvmBasicBlock)
    "LLVMAppendBasicBlockInContextWrapper")
(defun llvm-append-basic-block-in-context
    (context (* LlvmContext))
    (function (* LlvmValue))
    (name (@ u8))
    : (* LlvmBasicBlock)
(seq
    (let null-term = (alloca (+ name.len 1)))
    (let i = 0)
    (while (< i name.len)
        (seqn
            (set (get null-term i) = (get name i))
            (set i = (+ i 1))))
    (set (get null-term i) = '\0')
    (llvm-append-basic-block-in-context-raw context function null-term.ptr)))

(defext llvm-position-builder-at-end
    (builder (* LlvmBuilder))
    (block (* LlvmBasicBlock))
    "LLVMPositionBuilderAtEnd")

(defext llvm-build-ret
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    : (* LlvmValue)
    "LLVMBuildRet")

(defext llvm-const-int
    (type (* LlvmType))
    (v u64)
    (sign-extend u1)
    : (* LlvmValue)
    "LLVMConstIntWrapper")

(defext llvm-initialize-all-target-infos
    "LLVMInitializeX86TargetInfo")
(defext llvm-initialize-all-targets
    "LLVMInitializeX86Target")
(defext llvm-initialize-all-target-mcs
    "LLVMInitializeX86TargetMCWrapper")
(defext llvm-initialize-all-asm-parsers
    "LLVMInitializeX86AsmParser")
(defext llvm-initialize-all-asm-printers
    "LLVMInitializeX86AsmPrinter")

(defext llvm-get-default-target-triple
    : (* u8)
    "LLVMGetDefaultTargetTriple")

(defstruct LlvmTarget)

(defext llvm-get-target-from-triple
    (triple (* u8))
    (target (* (* LlvmTarget)))
    (error-msg (* (* u8)))
    : u1
    "LLVMGetTargetFromTriple")

(defstruct LlvmTargetMachine)

(defext llvm-create-target-machine
    (target (* LlvmTarget))
    (triple (* u8))
    (cpu (* u8))
    (features (* u8))
    (opt-level u64)
    (reloc-mode u64)
    (code-model u64)
    : (* LlvmTargetMachine)
    "LLVMCreateTargetMachineWrapper")

(defext llvm-target-machine-emit-to-file
    (target (* LlvmTargetMachine))
    (module (* LlvmModule))
    (filename (* u8))
    (emit-object u1)
    (error-msg (* (* u8)))
    : u1
    "LLVMTargetMachineEmitToFileWrapper")

(defext llvm-build-mul
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildMulWrapper")

(defext llvm-build-udiv
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildUDivWrapper")

(defext llvm-build-sdiv
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildSDivWrapper")

(defext llvm-build-urem
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildURemWrapper")

(defext llvm-build-srem
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildSRemWrapper")

(defext llvm-build-add
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildAddWrapper")

(defext llvm-build-sub
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildSubWrapper")

(defext llvm-build-shl
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildShlWrapper")

(defext llvm-build-lshr
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildLShrWrapper")

(defext llvm-build-and
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildAndWrapper")

(defext llvm-build-or
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildOrWrapper")

(defext llvm-build-xor
    (builder (* LlvmBuilder))
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildXorWrapper")

(defmacro LLVM_INT_PREDICATE_EQ  32)
(defmacro LLVM_INT_PREDICATE_NE  33)
(defmacro LLVM_INT_PREDICATE_UGT 34)
(defmacro LLVM_INT_PREDICATE_UGE 35)
(defmacro LLVM_INT_PREDICATE_ULT 36)
(defmacro LLVM_INT_PREDICATE_ULE 37)
(defmacro LLVM_INT_PREDICATE_SGT 38)
(defmacro LLVM_INT_PREDICATE_SGE 39)
(defmacro LLVM_INT_PREDICATE_SLT 40)
(defmacro LLVM_INT_PREDICATE_SLE 41)
(defext llvm-build-icmp
    (builder (* LlvmBuilder))
    (op u64)
    (a (* LlvmValue))
    (b (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildICmpWrapper")

(defext llvm-build-br
    (builder (* LlvmBuilder))
    (dest (* LlvmBasicBlock))
    : (* LlvmValue)
    "LLVMBuildBr")

(defext llvm-build-cond-br
    (builder (* LlvmBuilder))
    (if (* LlvmValue))
    (then (* LlvmBasicBlock))
    (else (* LlvmBasicBlock))
    : (* LlvmValue)
    "LLVMBuildCondBr")

(defext llvm-build-phi
    (builder (* LlvmBuilder))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildPhi")

(defext llvm-add-incoming
    (phi (* LlvmValue))
    (values (* (* LlvmValue)))
    (blocks (* (* LlvmBasicBlock)))
    (count u64)
    "LLVMAddIncoming")

(defext llvm-get-insert-block
    (builder (* LlvmBuilder))
    : (* LlvmBasicBlock)
    "LLVMGetInsertBlock")

(defext llvm-type-of
    (value (* LlvmValue))
    : (* LlvmType)
    "LLVMTypeOf")

(defext llvm-build-call
    (builder (* LlvmBuilder))
    (func-type (* LlvmType))
    (func (* LlvmValue))
    (args (* (* LlvmValue)))
    (arg-count u64)
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildCall2")

(defext llvm-get-return-type
    (type (* LlvmType))
    : (* LlvmType)
    "LLVMGetReturnType")

(defext llvm-void-type-in-context
    (context (* LlvmContext))
    : (* LlvmType)
    "LLVMVoidTypeInContext")

(defext llvm-get-param
    (func (* LlvmValue))
    (i u64)
    : (* LlvmValue)
    "LLVMGetParam")

(defext llvm-pointer-type
    (subtype (* LlvmType))
    (address-space u64)
    : (* LlvmType)
    "LLVMPointerType")

(defext llvm-build-alloca
    (builder (* LlvmBuilder))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildAllocaWrapper")

(defext llvm-build-load
    (builder (* LlvmBuilder))
    (type (* LlvmType))
    (pointer (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildLoad2")

(defext llvm-build-store
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (pointer (* LlvmValue))
    : (* LlvmValue)
    "LLVMBuildStore")

(defext llvm-get-first-basic-block
    (function (* LlvmValue))
    : (* LlvmBasicBlock)
    "LLVMGetFirstBasicBlock")

(defext llvm-position-builder-before
    (builder (* LlvmBuilder))
    (instruction (* LlvmValue))
    "LLVMPositionBuilderBefore")

(defext llvm-get-basic-block-terminator
    (block (* LlvmBasicBlock))
    : (* LlvmValue)
    "LLVMGetBasicBlockTerminator")

(defext llvm-build-trunc
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildTruncWrapper")

(defext llvm-build-zext
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildZExtWrapper")

(defext llvm-build-sext
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildSExtWrapper")

(defext llvm-build-ptr-to-int
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildPtrToIntWrapper")

(defext llvm-build-int-to-ptr
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildIntToPtr")

(defext llvm-build-bitcast
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (type (* LlvmType))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildBitCast")

(defext llvm-build-gep
    (builder (* LlvmBuilder))
    (type (* LlvmType))
    (pointer (* LlvmValue))
    (indexes (* (* LlvmValue)))
    (index-count u64)
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildGEP2Wrapper")

(defext llvm-const-null
    (type (* LlvmType))
    : (* LlvmValue)
    "LLVMConstNull")

(defext llvm-build-neg
    (builder (* LlvmBuilder))
    (value (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildNeg")

(defext llvm-struct-type-in-context
    (context (* LlvmContext))
    (element-types (* (* LlvmType)))
    (element-count u64)
    (packed u1)
    : (* LlvmType)
    "LLVMStructTypeInContextWrapper")

(defext llvm-build-global-string-ptr
    (builder (* LlvmBuilder))
    (string (* u8))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildGlobalStringPtrWrapper")

(defext llvm-const-struct-in-context
    (context (* LlvmContext))
    (fields (* (* LlvmValue)))
    (field-count u64)
    (packed u1)
    : (* LlvmValue)
    "LLVMConstStructInContextWrapper")

(defext llvm-build-array-alloca
    (builder (* LlvmBuilder))
    (type (* LlvmType))
    (length (* LlvmValue))
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildArrayAlloca")

(defext llvm-get-undef
    (type (* LlvmType))
    : (* LlvmValue)
    "LLVMGetUndef")

(defext llvm-build-insert-value
    (builder (* LlvmBuilder))
    (aggregate (* LlvmValue))
    (field (* LlvmValue))
    (index u64)
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildInsertValueWrapper")

(defext llvm-build-extract-value
    (builder (* LlvmBuilder))
    (aggregate (* LlvmValue))
    (index u64)
    (name (* u8))
    : (* LlvmValue)
    "LLVMBuildExtractValue")

(defext llvm-struct-create-named
    (context (* LlvmContext))
    (name (* u8))
    : (* LlvmType)
    "LLVMStructCreateNamed")

(defext llvm-struct-set-body
    (struct (* LlvmType))
    (elements (* (* LlvmType)))
    (element-count u64)
    (packed u1)
    "LLVMStructSetBody")

(defext llvm-verify-module
    (module (* LlvmModule))
    (action u64)
    (msg (* (* u8)))
    : u1
    "LLVMVerifyModuleWrapper")



//
// ==================================================================================================
// CODE GENERATION
// ==================================================================================================
//

(defstruct StructBack
    (fields (Vec (Pair (@ u8) Type)))
    (monomorphisms (Vec (Pair (Vec Type) (* LlvmType)))))

(defun instantiate-struct-monomorphism
    (context (* LlvmContext))
    (struct-map (* (Vec (Pair (@ u8) StructBack))))
    (type (* Type))
    : (* (Pair (Vec Type) (* LlvmType)))
(cond
    ((== (deref type).type (TYPE_TYPE_STRUCT)) (seq
        (let struct-name = (deref type).name)
        (let struct-generics = (deref type).subtypes)
        (let struct-pair = (vec-find struct-map matches-key struct-name))
        (let struct = (deref struct-pair).b)
        (let found = (vec-find (ref struct.monomorphisms) matches-types struct-generics))
        (cond
            ((: u64 (cast found))
                found)
            (:else (seq
                (let struct-llvm = (llvm-struct-create-named context "\0".ptr))
                (let fields = (ref (new-vec (deref struct-map).A)))
                (let monomorphisms = (ref struct.monomorphisms))
                (vec-push monomorphisms (inst Pair
                    (a struct-generics)
                    (b struct-llvm)))
                (set (deref struct-pair).b.monomorphisms = (deref monomorphisms))
                (let i = 0)
                (let j = 0)
                (let generics-subs = (ref (new-vec (deref struct-map).A)))
                (let generics = (ref (new-vec (deref struct-map).A)))
                (while (< i struct.fields.len) (seqn
                    (let field = (vec-get (ref struct.fields) i))
                    (let name = (deref field).a)
                    (let type = (ref (type-clone (ref (deref field).b))))
                    (find-generics type generics)
                    (while (< j (deref generics).len) (seqn
                        (let name = (deref (vec-get generics j)))
                        (let type = (deref (vec-get (ref struct-generics) j)))
                        (vec-push generics-subs (inst Pair
                            (a name)
                            (b type)))
                        (set j = (+ j 1))))
                    (let subs = (ref (new-vec (deref struct-map).A)))
                    (replace-generics type generics-subs subs)
                    (vec-push fields (ast-type-to-llvm-type context type struct-map))
                    (set i = (+ i 1))))
                (llvm-struct-set-body struct-llvm (vec-slice fields).ptr (deref fields).len false)
                (let monomorphism = (vec-find (ref (deref struct-pair).b.monomorphisms) matches-types struct-generics))
                monomorphism)))))
    (:else
        (null))))

(defun ast-type-to-llvm-type
    (context (* LlvmContext))
    (type (* Type))
    (struct-map (* (Vec (Pair (@ u8) StructBack))))
    : (* LlvmType)
(cond
    ((== (deref type).type (TYPE_TYPE_INT))
        (llvm-int-type-in-context context (deref type).type-var-width))
    ((== (deref type).type (TYPE_TYPE_FUNCTION)) (seq
        (let return-type = (ast-type-to-llvm-type context (deref type).boxed struct-map))
        (let params = (ref (new-vec (deref type).subtypes.A)))
        (let i = 0)
        (while (< i (deref type).subtypes.len) (seqn
            (let arg = (vec-get (ref (deref type).subtypes) i))
            (let arg = (ast-type-to-llvm-type context arg struct-map))
            (vec-push params arg)
            (set i = (+ i 1))))
        (llvm-pointer-type (llvm-function-type return-type (vec-slice params) false) 0)))
    ((== (deref type).type (TYPE_TYPE_POINTER))
        (llvm-pointer-type (ast-type-to-llvm-type context (deref type).boxed struct-map) 0))
    ((== (deref type).type (TYPE_TYPE_SLICE)) (seq
        (let pointer = (llvm-pointer-type (ast-type-to-llvm-type context (deref type).boxed struct-map) 0))
        (let size = (llvm-int-type-in-context context 64))
        (let slice = (alloca 2))
        (set (get slice 0) = pointer)
        (set (get slice 1) = size)
        (llvm-struct-type-in-context context slice.ptr slice.len false)))
    ((and (== (deref type).type (TYPE_TYPE_TUPLE)) (== (deref type).subtypes.len 0))
        (llvm-void-type-in-context context))
    ((== (deref type).type (TYPE_TYPE_STRUCT)) (seq
        (let struct = (instantiate-struct-monomorphism context struct-map type))
        (deref struct).b))
    (:else
        (null))))

(defun parse-int
    (str (@ u8))
    : u64
(cond
    ((str-equals str "true")
        1)
    ((str-equals str "false")
        0)
    (:else (seq
        (let i = 0)
        (let n = 0)
        (while (< i str.len) (seqn
            (let c = (get str i))
            (cond
                ((and (<= '0' c) (<= c '9')) (seqn
                    (set n = (+ (* n 10) (cast (- c '0'))))))
                (:else (break 0)))
            (set i = (+ i 1)))
        :else n)))))

(defun matches-type (pair (* (Pair Type 'a))) (type Type) : u1
    (type-equals (deref pair).a type))

(defun matches-types
    (pair (* (Pair (Vec Type) 'a)))
    (types (Vec Type))
    : u1
(cond
    ((== (deref pair).a.len types.len) (seq
        (let i = 0)
        (while (< i types.len) (seqn
            (let a = (vec-get (ref (deref pair).a) i))
            (let b = (vec-get (ref types) i))
            (cond
                ((type-equals (deref a) (deref b))
                    ())
                (:else
                    (break false)))
            (set i = (+ i 1)))
        :else true)))
    (:else
        false)))

(defun compile-helper
    (ast (* Ast))
    (context (* LlvmContext))
    (module (* LlvmModule))
    (builder (* LlvmBuilder))
    (function (* LlvmValue))
    (break-block (* LlvmBasicBlock))
    (break-phi (Pair (* (Vec (* LlvmValue))) (* (Vec (* LlvmBasicBlock)))))
    (func-map (* (Vec (Pair (@ u8) (Vec (Pair Type (* LlvmValue)))))))
    (var-map (* (Vec (Vec (Pair (@ u8) (Pair (* LlvmType) (* LlvmValue)))))))
    (struct-map (* (Vec (Pair (@ u8) StructBack))))
    : (* LlvmValue)
(cond
    ((or (== (deref ast).type (AST_NODE_TYPE_INT)) (== (deref ast).type (AST_NODE_TYPE_BOOL))) (seq
        (let type = (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map))
        (llvm-const-int type (parse-int (deref ast).value) (deref ast).typed.signed-mutable)))
    ((== (deref ast).type (AST_NODE_TYPE_CHAR)) (cond
        ((== (deref ast).value.len 3)
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast (get (deref ast).value 1)) false))
        ((== (get (deref ast).value 2) 'n')
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast '\n') false))
        ((== (get (deref ast).value 2) 'r')
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast '\r') false))
        ((== (get (deref ast).value 2) 't')
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast '\t') false))
        ((== (get (deref ast).value 2) '0')
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast '\0') false))
        ((== (get (deref ast).value 2) '\\')
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast '\\') false))
        ((== (get (deref ast).value 2) '\'')
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast '\'') false))
        ((== (get (deref ast).value 2) '"')
            (llvm-const-int (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) (cast '\"') false))
        (:else
            (null))))

    ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seq
        (let i = (deref var-map).len)
        (while (> i 0) (seqn
            (set i = (- i 1))
            (let scope = (vec-get var-map i))
            (let value = (vec-find scope matches-key (deref ast).value))
            (cond
                ((: u64 (cast value))
                    (break (llvm-build-load builder (deref value).b.a (deref value).b.b "\0".ptr)))))
        :else (cond
            ((: u64 (cast (let func = (vec-find func-map matches-key (deref ast).value)))) (seq
                (let func = (vec-find (ref (deref func).b) matches-type (deref ast).typed))
                (deref func).b))
            (:else
                (null))))))

    ((== (deref ast).type (AST_NODE_TYPE_STRING)) (seq
        (let value = (ref (new-vec (deref ast).children.A)))
        (let i = 1)
        (while (< i (- (deref ast).value.len 1)) (seqn
            (let c = (get (deref ast).value i))
            (cond
                ((== c '\\') (seqn
                    (set i = (+ i 1))
                    (let c = (get (deref ast).value i))
                    (cond
                        ((== c 'n')
                            (vec-push value '\n'))
                        ((== c 'r')
                            (vec-push value '\r'))
                        ((== c 't')
                            (vec-push value '\t'))
                        ((== c '0')
                            (vec-push value '\0'))
                        ((== c '\\')
                            (vec-push value '\\'))
                        ((== c '\'')
                            (vec-push value '\''))
                        ((== c '\"')
                            (vec-push value '\"')))))
                (:else
                    (vec-push value c)))
            (set i = (+ i 1))))
        (vec-push value 0)
        (let string-ptr = (llvm-build-global-string-ptr builder (vec-slice value).ptr "\0".ptr))
        (let length = (llvm-const-int (llvm-int-type-in-context context 64) (- (deref value).len 1) false))
        (let fields = (alloca 2))
        (set (get fields 0) = string-ptr)
        (set (get fields 1) = length)
        (llvm-const-struct-in-context context fields.ptr fields.len false)))

    ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (== (deref ast).children.len 0))
        (null))
    ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seq
        (let func-ast = (vec-get (ref (deref ast).children) 0))
        (cond
            ((== (deref func-ast).type (AST_NODE_TYPE_SYMBOL)) (seq
                (let symbol = (deref func-ast).value)
                (cond
                    ((: u64 (cast (let func = (compile-helper func-ast context module builder function break-block break-phi func-map var-map struct-map)))) (seq
                        (let args = (ref (new-vec (deref ast).children.A)))
                        (let j = 1)
                        (while (< j (deref ast).children.len) (seqn
                            (let arg = (vec-get (ref (deref ast).children) j))
                            (let arg = (compile-helper arg context module builder function break-block break-phi func-map var-map struct-map))
                            (vec-push args arg)
                            (set j = (+ j 1))))
                        (let call = (llvm-build-call
                            builder
                            (llvm-get-return-type (llvm-type-of func))
                            func
                            (vec-slice args).ptr
                            (deref args).len
                            "\0".ptr))
                        (cond
                            ((and (== (deref ast).typed.type (TYPE_TYPE_TUPLE)) (== (deref ast).typed.subtypes.len 0))
                                (null))
                            (:else
                                call))))

                    ((str-equals symbol ":")
                        (compile-helper (vec-get (ref (deref ast).children) 2) context module builder function break-block break-phi func-map var-map struct-map))

                    ((str-equals symbol "cast") (seq
                        (let value = (vec-get (ref (deref ast).children) 1))
                        (let from = (deref value).typed)
                        (let value = (compile-helper value context module builder function break-block break-phi func-map var-map struct-map))
                        (let into = (deref ast).typed)

                        (cond
                            ((and (== from.type (TYPE_TYPE_INT)) (== into.type (TYPE_TYPE_INT)))
                                (cond
                                    ((and (< from.type-var-width into.type-var-width) into.signed-mutable)
                                        (llvm-build-sext builder value (ast-type-to-llvm-type context (ref into) struct-map) "\0".ptr))
                                    ((< from.type-var-width into.type-var-width)
                                        (llvm-build-zext builder value (ast-type-to-llvm-type context (ref into) struct-map) "\0".ptr))
                                    ((== from.type-var-width into.type-var-width)
                                        value)
                                    (:else
                                        (llvm-build-trunc builder value (ast-type-to-llvm-type context (ref into) struct-map) "\0".ptr))))
                            ((and (== from.type (TYPE_TYPE_POINTER)) (== into.type (TYPE_TYPE_POINTER)))
                                (llvm-build-bitcast builder value (ast-type-to-llvm-type context (ref into) struct-map) "\0".ptr))
                            ((and (== from.type (TYPE_TYPE_POINTER)) (== into.type (TYPE_TYPE_INT)))
                                (llvm-build-ptr-to-int builder value (ast-type-to-llvm-type context (ref into) struct-map) "\0".ptr))
                            ((and (== from.type (TYPE_TYPE_INT)) (== into.type (TYPE_TYPE_POINTER)))
                                (llvm-build-int-to-ptr builder value (ast-type-to-llvm-type context (ref into) struct-map) "\0".ptr))
                            (:else
                                (null)))))

                    ((str-equals symbol "sizeof") (seq
                        (let int-type = (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map))
                        (let type = (ref (deref (vec-get (ref (deref ast).children) 1)).typed))
                        (let type = (ast-type-to-llvm-type context type struct-map))
                        (let nully = (llvm-const-null (llvm-pointer-type type 0)))
                        (let index = (llvm-const-int (llvm-int-type-in-context context 64) 1 true))
                        (let gep = (llvm-build-gep builder type nully (ref index) 1 "\0".ptr))
                        (llvm-build-ptr-to-int builder gep int-type "\0".ptr)))

                    ((str-equals symbol "alloca") (seq
                        (let length = (compile-helper (vec-get (ref (deref ast).children) 1) context module builder function break-block break-phi func-map var-map struct-map))
                        (let ptr = (llvm-build-array-alloca builder (ast-type-to-llvm-type context (deref ast).typed.boxed struct-map) length "\0".ptr))
                        (let slice = (llvm-get-undef (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map)))
                        (let slice = (llvm-build-insert-value builder slice ptr 0 "\0".ptr))
                        (llvm-build-insert-value builder slice length 1 "\0".ptr)))

                    ((str-equals symbol "ref") (seq
                        (let value = (vec-get (ref (deref ast).children) 1))
                        (let type = (ast-type-to-llvm-type context (ref (deref value).typed) struct-map))
                        (let value = (compile-helper value context module builder function break-block break-phi func-map var-map struct-map))
                        (let alloc = (llvm-build-alloca builder type "\0".ptr))
                        (llvm-build-store builder value alloc)
                        alloc))

                    ((str-equals symbol "deref") (seq
                        (let value = (compile-helper (vec-get (ref (deref ast).children) 1) context module builder function break-block break-phi func-map var-map struct-map))
                        (let type = (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map))
                        (llvm-build-load builder type value "\0".ptr)))

                    ((str-equals symbol "get") (seq
                        (let slice = (compile-helper (vec-get (ref (deref ast).children) 1) context module builder function break-block break-phi func-map var-map struct-map))
                        (let index = (compile-helper (vec-get (ref (deref ast).children) 2) context module builder function break-block break-phi func-map var-map struct-map))
                        (let ptr = (llvm-build-extract-value builder slice 0 "\0".ptr))
                        (let indexes = (alloca 1))
                        (set (get indexes 0) = index)
                        (let type = (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map))
                        (let ptr = (llvm-build-gep builder type ptr indexes.ptr indexes.len "\0".ptr))
                        (llvm-build-load builder type ptr "\0".ptr)))

                    ((str-equals symbol "ptr-add") (seq
                        (let pointer = (compile-helper (vec-get (ref (deref ast).children) 1) context module builder function break-block break-phi func-map var-map struct-map))
                        (let index = (compile-helper (vec-get (ref (deref ast).children) 2) context module builder function break-block break-phi func-map var-map struct-map))
                        (let type = (deref ast).typed.boxed)
                        (let type = (ast-type-to-llvm-type context type struct-map))
                        (llvm-build-gep builder type pointer (ref index) 1 "\0".ptr)))

                    ((str-equals symbol "ptr-sub") (seq
                        (let pointer = (compile-helper (vec-get (ref (deref ast).children) 1) context module builder function break-block break-phi func-map var-map struct-map))
                        (let index = (compile-helper (vec-get (ref (deref ast).children) 2) context module builder function break-block break-phi func-map var-map struct-map))
                        (let index = (llvm-build-neg builder index "\0".ptr))
                        (let type = (deref ast).typed.boxed)
                        (let type = (ast-type-to-llvm-type context type struct-map))
                        (llvm-build-gep builder type pointer (ref index) 1 "\0".ptr)))

                    ((str-equals symbol "slice") (seq
                        (let length = (compile-helper (vec-get (ref (deref ast).children) 1) context module builder function break-block break-phi func-map var-map struct-map))
                        (let ptr = (compile-helper (vec-get (ref (deref ast).children) 2) context module builder function break-block break-phi func-map var-map struct-map))
                        (let slice = (llvm-get-undef (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map)))
                        (let slice = (llvm-build-insert-value builder slice ptr 0 "\0".ptr))
                        (llvm-build-insert-value builder slice length 1 "\0".ptr)))

                    ((str-equals symbol "*") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-mul
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "/") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (cond
                            ((deref ast).typed.signed-mutable
                                (llvm-build-sdiv
                                    builder
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr))
                            (:else
                                (llvm-build-udiv
                                    builder
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr)))))
                    ((str-equals symbol "%") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (cond
                            ((deref ast).typed.signed-mutable
                                (llvm-build-srem
                                    builder
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr))
                            (:else
                                (llvm-build-urem
                                    builder
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr)))))
                    ((str-equals symbol "+") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-add
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "-") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-sub
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "<<") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-shl
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol ">>") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-lshr
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "&") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-and
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "|") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-or
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "^") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-xor
                            builder
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "==") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-icmp
                            builder
                            (LLVM_INT_PREDICATE_EQ)
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "!=") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (llvm-build-icmp
                            builder
                            (LLVM_INT_PREDICATE_NE)
                            (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                            (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                            "\0".ptr)))
                    ((str-equals symbol "<") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (cond
                            ((deref a).typed.signed-mutable
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_SLT)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr))
                            (:else
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_ULT)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr)))))
                    ((str-equals symbol "<=") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (cond
                            ((deref a).typed.signed-mutable
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_SLE)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr))
                            (:else
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_ULE)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr)))))
                    ((str-equals symbol ">") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (cond
                            ((deref a).typed.signed-mutable
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_SGT)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr))
                            (:else
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_UGT)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr)))))
                    ((str-equals symbol ">=") (seq
                        (let a = (vec-get (ref (deref ast).children) 1))
                        (let b = (vec-get (ref (deref ast).children) 2))
                        (cond
                            ((deref a).typed.signed-mutable
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_SGE)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr))
                            (:else
                                (llvm-build-icmp
                                    builder
                                    (LLVM_INT_PREDICATE_UGE)
                                    (compile-helper a context module builder function break-block break-phi func-map var-map struct-map)
                                    (compile-helper b context module builder function break-block break-phi func-map var-map struct-map)
                                    "\0".ptr)))))
                    ((str-equals symbol "seq") (seq
                        (vec-push var-map (new-vec (deref ast).children.A))
                        (let i = 1)
                        (let last = (null))
                        (while (< i (deref ast).children.len) (seqn
                            (let node = (vec-get (ref (deref ast).children) i))
                            (set last = (compile-helper node context module builder function break-block break-phi func-map var-map struct-map))
                            (set i = (+ i 1))))
                        (vec-pop var-map)
                        last))
                    ((str-equals symbol "seqn") (seq
                        (vec-push var-map (new-vec (deref ast).children.A))
                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (let node = (vec-get (ref (deref ast).children) i))
                            (compile-helper node context module builder function break-block break-phi func-map var-map struct-map)
                            (set i = (+ i 1))))
                        (vec-pop var-map)
                        (null)))

                    ((str-equals symbol "cond") (seq
                        (let conds = (ref (new-vec (deref ast).children.A)))
                        (let thens = (ref (new-vec (deref ast).children.A)))

                        (let i = 1)
                        (while (< i (deref ast).children.len) (seqn
                            (let pair = (vec-get (ref (deref ast).children) i))
                            (let condy = (vec-get (ref (deref pair).children) 0))
                            (cond
                                ((!= (deref condy).type (AST_NODE_TYPE_KEY)) (seqn
                                    (let then = (llvm-append-basic-block-in-context context function "then"))
                                    (vec-push thens then)
                                    (cond
                                        ((< i (- (deref ast).children.len 1)) (seqn
                                            (let condy = (llvm-append-basic-block-in-context context function "cond"))
                                            (vec-push conds condy)))))))
                            (set i = (+ i 1))))

                        (let last-block = (llvm-append-basic-block-in-context context function "cond-end"))
                        (vec-push conds last-block)

                        (let i = 1)
                        (let phi-blocks = (ref (new-vec (deref ast).children.A)))
                        (let phi-values = (ref (new-vec (deref ast).children.A)))
                        (while (< i (deref ast).children.len) (seqn
                            (vec-push var-map (new-vec (deref ast).children.A))
                            (let pair = (vec-get (ref (deref ast).children) i))
                            (let condy = (vec-get (ref (deref pair).children) 0))
                            (let then = (vec-get (ref (deref pair).children) 1))

                            (cond
                                ((!= (deref condy).type (AST_NODE_TYPE_KEY)) (seqn
                                    (let condy-ast = condy)
                                    (let condy = (compile-helper condy context module builder function break-block break-phi func-map var-map struct-map))
                                    (let next-cond-block = (deref (vec-get conds (- i 1))))
                                    (let then-block = (deref (vec-get thens (- i 1))))
                                    (llvm-build-cond-br
                                        builder
                                        condy
                                        then-block
                                        next-cond-block)

                                    (llvm-position-builder-at-end builder then-block)
                                    (let then = (compile-helper then context module builder function break-block break-phi func-map var-map struct-map))
                                    (vec-push phi-blocks then-block)
                                    (vec-push phi-values then)
                                    (llvm-build-br
                                        builder
                                        last-block)

                                    (llvm-position-builder-at-end builder next-cond-block)))
                                (:else (seqn
                                    (let else = (compile-helper then context module builder function break-block break-phi func-map var-map struct-map))
                                    (vec-push phi-blocks (llvm-get-insert-block builder))
                                    (vec-push phi-values else)
                                    (llvm-build-br
                                        builder
                                        last-block))))
                            (vec-pop var-map)
                            (set i = (+ i 1))))

                        (llvm-position-builder-at-end builder last-block)

                        (cond
                            ((and (== (deref ast).typed.type (TYPE_TYPE_TUPLE)) (== (deref ast).typed.subtypes.len 0))
                                (null))
                            (:else (seq
                                (let phi = (llvm-build-phi builder (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) "\0".ptr))
                                (llvm-add-incoming phi (vec-slice phi-values).ptr (vec-slice phi-blocks).ptr (deref phi-values).len)
                                phi)))))

                    ((str-equals symbol "loop") (seq
                        (vec-push var-map (new-vec (deref ast).children.A))
                        (let loop-block = (llvm-append-basic-block-in-context context function "loop"))
                        (let break-block = (llvm-append-basic-block-in-context context function "loop-end"))
                        (let phi-values = (ref (new-vec (deref ast).children.A)))
                        (let phi-blocks = (ref (new-vec (deref ast).children.A)))
                        (llvm-build-br builder loop-block)
                        (llvm-position-builder-at-end builder loop-block)
                        (let node = (vec-get (ref (deref ast).children) 1))
                        (let node = (compile-helper
                            node
                            context
                            module
                            builder
                            function
                            break-block
                            (inst Pair
                                (a phi-values)
                                (b phi-blocks))
                            func-map
                            var-map
                            struct-map))
                        (llvm-build-br builder loop-block)
                        (llvm-position-builder-at-end builder break-block)
                        (cond
                            ((and (== (deref ast).typed.type (TYPE_TYPE_TUPLE)) (== (deref ast).typed.subtypes.len 0))
                                (null))
                            (:else (seq
                                (let phi = (llvm-build-phi builder (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) "\0".ptr))
                                (llvm-add-incoming phi (vec-slice phi-values).ptr (vec-slice phi-blocks).ptr (deref phi-values).len)
                                phi)))))
                    ((str-equals symbol "break") (seq
                        (let break-value = (cond
                            ((> (deref ast).children.len 1) (seq
                                (let node = (vec-get (ref (deref ast).children) 1))
                                (compile-helper node context module builder function break-block break-phi func-map var-map struct-map)))
                            (:else
                                (null))))
                        (cond
                            ((: u64 (cast break-value)) (seqn
                                (vec-push break-phi.a break-value)
                                (vec-push break-phi.b (llvm-get-insert-block builder)))))
                        (llvm-build-br
                            builder
                            break-block)
                        (llvm-position-builder-at-end builder (llvm-append-basic-block-in-context context function "break-end"))
                        (null)))

                    ((str-equals symbol "let") (seq
                        (let var = (vec-get (ref (deref ast).children) 1))
                        (let var = (deref var).value)
                        (let expr = (vec-get (ref (deref ast).children) 3))
                        (let type = (ast-type-to-llvm-type context (ref (deref expr).typed) struct-map))
                        (let expr = (compile-helper expr context module builder function break-block break-phi func-map var-map struct-map))
                        (let current-block = (llvm-get-insert-block builder))
                        (llvm-position-builder-before builder (llvm-get-basic-block-terminator (llvm-get-first-basic-block function)))
                        (let alloc = (llvm-build-alloca builder (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map) "\0".ptr))
                        (let top = (vec-get var-map (- (deref var-map).len 1)))
                        (let value = (vec-find top matches-key var))
                        (cond
                            ((: u64 (cast value)) (seqn
                                (set (deref value).b.a = type)
                                (set (deref value).b.b = alloc)))
                            (:else (seqn
                                (vec-push top (inst Pair
                                    (a var)
                                    (b (inst Pair
                                        (a type)
                                        (b alloc))))))))
                        (llvm-position-builder-at-end builder current-block)
                        (llvm-build-store builder expr alloc)
                        (llvm-build-load builder type alloc "\0".ptr)))

                    ((str-equals symbol "set") (seq
                        (let lvalue = (vec-get (ref (deref ast).children) 1))
                        (let lvalue = (compile-lvalue lvalue context module builder function break-block break-phi func-map var-map struct-map))
                        (let expr = (vec-get (ref (deref ast).children) 3))
                        (let type = (ast-type-to-llvm-type context (ref (deref expr).typed) struct-map))
                        (let expr = (compile-helper expr context module builder function break-block break-phi func-map var-map struct-map))
                        (llvm-build-store builder expr lvalue)
                        (llvm-build-load builder type lvalue "\0".ptr)))

                    ((str-equals symbol "inst") (seq
                        (let struct-value = (llvm-get-undef (ast-type-to-llvm-type context (ref (deref ast).typed) struct-map)))
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (let name = (deref name).value)
                        (let raw = (vec-find struct-map matches-key name))
                        (let i = 2)
                        (while (< i (deref ast).children.len) (seqn
                            (let pair = (vec-get (ref (deref ast).children) i))
                            (let name = (vec-get (ref (deref pair).children) 0))
                            (let name = (deref name).value)
                            (let value = (vec-get (ref (deref pair).children) 1))
                            (let value = (compile-helper value context module builder function break-block break-phi func-map var-map struct-map))
                            (let j = 0)
                            (while (< j (deref raw).b.fields.len) (seqn
                                (let field = (vec-get (ref (deref raw).b.fields) j))
                                (let field = (deref field).a)
                                (cond
                                    ((str-equals name field)
                                        (break)))
                                (set j = (+ j 1))))
                            (set struct-value = (llvm-build-insert-value builder struct-value value j "\0".ptr))
                            (set i = (+ i 1))))
                        struct-value))

                    (:else
                        (null)))))
            (:else
                (null)))))

    ((== (deref ast).type (AST_NODE_TYPE_ATTR)) (seq
        (let value = (vec-get (ref (deref ast).children) 0))
        (let type = (deref value).typed)
        (let value = (compile-helper value context module builder function break-block break-phi func-map var-map struct-map))
        (let attr = (deref (vec-get (ref (deref ast).children) 1)).value)
        (cond
            ((== type.type (TYPE_TYPE_SLICE)) (cond
                ((str-equals attr "ptr")
                    (llvm-build-extract-value builder value 0 "\0".ptr))
                ((or (str-equals attr "len") (str-equals attr "cap"))
                    (llvm-build-extract-value builder value 1 "\0".ptr))
                (:else
                    (null))))
            ((== type.type (TYPE_TYPE_STRUCT)) (seq
                (let raw = (vec-find struct-map matches-key type.name))
                (let j = 0)
                (while (< j (deref raw).b.fields.len) (seqn
                    (let field = (vec-get (ref (deref raw).b.fields) j))
                    (let field = (deref field).a)
                    (cond
                        ((str-equals attr field)
                            (break)))
                    (set j = (+ j 1))))
                (llvm-build-extract-value builder value j "\0".ptr)))
            (:else
                (null)))))

    (:else
        (null))))

(defun compile-lvalue
    (ast (* Ast))
    (context (* LlvmContext))
    (module (* LlvmModule))
    (builder (* LlvmBuilder))
    (function (* LlvmValue))
    (break-block (* LlvmBasicBlock))
    (break-phi (Pair (* (Vec (* LlvmValue))) (* (Vec (* LlvmBasicBlock)))))
    (func-map (* (Vec (Pair (@ u8) (Vec (Pair Type (* LlvmValue)))))))
    (var-map (* (Vec (Vec (Pair (@ u8) (Pair (* LlvmType) (* LlvmValue)))))))
    (struct-map (* (Vec (Pair (@ u8) StructBack))))
    : (* LlvmValue)
(cond
    ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seq
        (let i = (deref var-map).len)
        (while (> i 0) (seqn
            (set i = (- i 1))
            (let scope = (vec-get var-map i))
            (let value = (vec-find scope matches-key (deref ast).value))
            (cond
                ((: u64 (cast value))
                    (break (deref value).b.b))))
        :else
            (null))))
    ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seq
        (let func-name = (vec-get (ref (deref ast).children) 0))
        (let func-name = (deref func-name).value)
        (cond
            ((str-equals func-name "deref") (seq
                (let v = (vec-get (ref (deref ast).children) 1))
                (compile-helper v context module builder function break-block break-phi func-map var-map struct-map)))
            ((str-equals func-name "get") (seq
                (let v = (vec-get (ref (deref ast).children) 1))
                (let type = (deref v).typed.boxed)
                (let v = (compile-helper v context module builder function break-block break-phi func-map var-map struct-map))
                (let i = (vec-get (ref (deref ast).children) 2))
                (let i = (compile-helper i context module builder function break-block break-phi func-map var-map struct-map))
                (llvm-build-gep builder (ast-type-to-llvm-type context type struct-map) v (ref i) 1 "\0".ptr)))
            (:else
                (null)))))

    ((== (deref ast).type (AST_NODE_TYPE_ATTR)) (seq
        (let lvalue = (vec-get (ref (deref ast).children) 0))
        (let type = (deref lvalue).typed)
        (let lvalue = (compile-lvalue lvalue context module builder function break-block break-phi func-map var-map struct-map))
        (let attr = (vec-get (ref (deref ast).children) 1))
        (let attr = (deref attr).value)
        (let raw = (vec-find struct-map matches-key type.name))
        (let i = 0)
        (while (< i (deref raw).b.fields.len) (seqn
            (let field = (vec-get (ref (deref raw).b.fields) i))
            (let field = (deref field).a)
            (cond
                ((str-equals attr field)
                    (break)))
            (set i = (+ i 1))))
        (let indexes = (alloca 2))
        (set (get indexes 0) = (llvm-const-int (llvm-int-type-in-context context 64) 0 true))
        (set (get indexes 1) = (llvm-const-int (llvm-int-type-in-context context 32) i true))
        (llvm-build-gep builder (ast-type-to-llvm-type context (ref type) struct-map) lvalue indexes.ptr indexes.len "\0".ptr)))

    (:else
        (null))))

(defun compile-using-llvm
    (ast (* Ast))
    (filename (@ u8))
    (contents (@ u8))
(seqn
    (let context = (llvm-context-create))
    (let module = (llvm-module-create-with-name-in-context "uwu" context))
    (let builder = (llvm-create-builder-in-context context))
    (let func-map = (ref (new-vec (deref ast).children.A)))
    (: (* (Vec (Pair (@ u8) (Vec (Pair Type (* LlvmValue)))))) func-map)

    (let struct-map = (ref (new-vec (deref ast).children.A)))
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (let v = (deref (vec-get (ref (deref ast).children) 0)))
        (cond
            ((and (== v.type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defstruct")) (seqn
                (let name = (vec-get (ref (deref ast).children) 1))
                (let name = (deref name).value)
                (let fields = (ref (new-vec (deref ast).children.A)))
                (let j = 2)
                (while (< j (deref ast).children.len) (seqn
                    (let field = (vec-get (ref (deref ast).children) j))
                    (let name = (vec-get (ref (deref field).children) 0))
                    (let name = (deref name).value)
                    (let type = (vec-get (ref (deref field).children) 1))
                    (let type = (deref type).typed)
                    (vec-push fields (inst Pair
                        (a name)
                        (b type)))
                    (set j = (+ j 1))))
                (vec-push struct-map (inst Pair
                    (a name)
                    (b (inst StructBack
                        (fields (deref fields))
                        (monomorphisms (new-vec (deref ast).children.A)))))))))
        (set i = (+ i 1))))

    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (let v = (deref (vec-get (ref (deref ast).children) 0)))
        (let func-type = (deref ast).typed)
        (cond
            ((and (== v.type (AST_NODE_TYPE_SYMBOL)) (and (or (str-equals v.value "defun") (str-equals v.value "defext")) (not (has-generic (ref func-type))))) (seqn
                (let name = (deref (vec-get (ref (deref ast).children) 1)).value)
                (let type = (ref (deref ast).typed))
                (let ret-type = (ast-type-to-llvm-type context (deref type).boxed struct-map))
                (let param-count = (deref type).subtypes.len)
                (let param-types = (alloca param-count))
                (let i = 0)
                (while (< i param-count) (seqn
                    (set (get param-types i) = (ast-type-to-llvm-type context (vec-get (ref (deref type).subtypes) i) struct-map))
                    (set i = (+ i 1))))
                (let signature = (llvm-function-type ret-type param-types false))
                (let name-original = name)
                (cond
                    ((str-equals v.value "defext") (seqn
                        (set name = (deref (vec-get (ref (deref ast).children) (- (deref ast).children.len 1))).value)
                        (set name = (subslice name 1 (- name.len 1))))))
                (let name-vec = (ref (new-vec (deref ast).children.A)))
                (cond
                    ((str-equals v.value "defext") (seqn
                        (let i = 0)
                        (while (< i name.len) (seqn
                            (vec-push name-vec (get name i))
                            (set i = (+ i 1))))))
                    ((str-equals name "main") (seqn
                        (let i = 0)
                        (while (< i name.len) (seqn
                            (vec-push name-vec (get name i))
                            (set i = (+ i 1))))))
                    (:else (seqn
                        (let i = 0)
                        (vec-push name-vec '_')
                        (vec-push name-vec 'a')
                        (vec-push name-vec 'm')
                        (vec-push name-vec 'y')
                        (vec-push name-vec '_')
                        (while (< i name.len) (seqn
                            (vec-push name-vec (get name i))
                            (set i = (+ i 1))))
                        (vec-push name-vec '.')

                        // TODO: make this based on types (it is not sufficient)
                        (let monomorphisms = (vec-find func-map matches-key name-original))
                        (cond
                            ((: u64 (cast monomorphisms)) (seqn
                                (let i = (deref monomorphisms).b.len)
                                (while (!= i 0) (seqn
                                    (let c = (+ '0' (cast (% i 10))))
                                    (vec-push name-vec c)
                                    (set i = (/ i 10))))))
                            (:else (seqn
                                (vec-push name-vec '0')))))))
                (let function = (llvm-add-function module (vec-slice name-vec) signature))
                (cond
                    ((: u64 (cast (let monomorphisms = (vec-find func-map matches-key name-original)))) (seqn
                        (let morphisms = (ref (deref monomorphisms).b))
                        (vec-push morphisms (inst Pair
                            (a func-type)
                            (b function)))
                        (set (deref monomorphisms).b = (deref morphisms))))
                    (:else (seqn
                        (let morphisms = (ref (new-vec (deref ast).children.A)))
                        (vec-push morphisms (inst Pair
                            (a func-type)
                            (b function)))
                        (vec-push func-map (inst Pair
                            (a name-original)
                            (b (deref morphisms))))))))))
        (set i = (+ i 1))))
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (cond
            ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (and (str-equals v.value "defun") (not (has-generic (ref (deref ast).typed))))) (seqn
                (let name = (deref (vec-get (ref (deref ast).children) 1)).value)
                (let type = (ref (deref ast).typed))
                (let function = (vec-find func-map matches-key name))
                (let function = (vec-find (ref (deref function).b) matches-type (deref ast).typed))
                (let function = (deref function).b)
                (let var-map = (ref (new-vec (deref ast).children.A)))
                (let scope = (ref (new-vec (deref ast).children.A)))
                (let entry-block = (llvm-append-basic-block-in-context context function "entry"))
                (llvm-position-builder-at-end builder entry-block)
                (let i = 0)
                (while (< i (deref type).subtypes.len) (seqn
                    (let var = (vec-get (ref (deref ast).children) (+ i 2)))
                    (let var = (vec-get (ref (deref var).children) 0))
                    (let var = (deref var).value)
                    (let value = (llvm-get-param function i))
                    (let alloc = (llvm-build-alloca builder (llvm-type-of value) "\0".ptr))
                    (llvm-build-store builder value alloc)
                    (vec-push scope (inst Pair
                        (a var)
                        (b (inst Pair
                            (a (llvm-type-of value))
                            (b alloc)))))
                    (set i = (+ i 1))))
                (vec-push var-map (deref scope))
                (let next-block = (llvm-append-basic-block-in-context context function "next"))
                (llvm-build-br builder next-block)
                (llvm-position-builder-at-end builder next-block)
                (let expr = (compile-helper
                    (vec-get (ref (deref ast).children) (- (deref ast).children.len 1))
                    context
                    module
                    builder
                    function
                    (null)
                    (inst Pair
                        (a (null))
                        (b (null)))
                    func-map
                    var-map
                    struct-map))
                (llvm-build-ret builder expr))))
        (set i = (+ i 1))))

    (llvm-dump-module module)
    (llvm-verify-module module 0 (null))

    (llvm-initialize-all-target-infos)
    (llvm-initialize-all-targets)
    (llvm-initialize-all-target-mcs)
    (llvm-initialize-all-asm-parsers)
    (llvm-initialize-all-asm-printers)

    (let triple = (llvm-get-default-target-triple))
    (let target = (ref (ref (inst LlvmTarget))))
    (llvm-get-target-from-triple triple target (null))
    (let target = (deref target))
    (let machine = (llvm-create-target-machine target triple "generic\0".ptr "\0".ptr 0 0 0))
    (llvm-target-machine-emit-to-file machine module "a.out.o\0".ptr true (null))))



//
// ==================================================================================================
// MAIN
// ==================================================================================================
//

(defun main (argv (* (* u8))) (argc u64) : i32
(seq
    (let filename = (get-argv argv 1))
    (cond
        ((== filename.ptr (null)) (seqn
            (eprint "please provide a file to compile\n")
            (exit 1))))
    (let file = (file-open filename (FILE_OPEN_FLAG_READ_ONLY)))
    (cond
        ((not (file-is-valid file)) (seqn
            (eprint "error: failed to open file ")
            (eprint filename)
            (eprint "\n")
            (exit 1))))
    (let A = (ref (new-alloc)))
    (let contents = (file-read-all file A))
    (let contents-ref = (vec-slice (ref contents)))
    (file-close file)
    (let lexer = (ref (new-lexer A contents-ref)))
    (let result = (parse lexer))
    (cond (result.success (seq
        (let ast = (ref result.ast))
        (let macros = (ref (new-vec A)))
        (extract-macros macros ast)
        (replace-macros macros ast)
        (let func-map = (ref (create-default-signatures A)))
        (let struct-map = (ref (new-vec A)))
        (let errors = (ref (new-vec A)))
        (extract-structs ast struct-map errors)
        (print-type-errors contents-ref errors)
        (extract-functions ast func-map errors)
        (print-type-errors contents-ref errors)
        (check ast errors func-map struct-map)
        (print-type-errors contents-ref errors)
        (compile-using-llvm ast filename contents-ref)
        (ast-drop ast)
        (vec-drop macros empty-dealloc)))
    (:else (seqn
        (print-parse-error contents-ref (ref result.fail))
        (exit 1))))
    (lexer-drop lexer)
    (vec-drop (ref contents) empty-dealloc)
    0))
